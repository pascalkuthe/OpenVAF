//! Generated by `sourcegen_ast`, do not edit by hand.

use crate::{
    ast::{self, generated::tokens::*, support, AstChildren, AstNode},
    SyntaxKind::{self, *},
    SyntaxNode, SyntaxToken, T,
};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NameRef {
    pub(crate) syntax: SyntaxNode,
}
impl NameRef {
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Path {
    pub(crate) syntax: SyntaxNode,
}
impl Path {
    pub fn qualifier(&self) -> Option<Path> { support::child(&self.syntax) }
    pub fn dot_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![.]) }
    pub fn ident_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![ident]) }
    pub fn root_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![root]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AttrList {
    pub(crate) syntax: SyntaxNode,
}
impl AttrList {
    pub fn l_attr_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["(*"])
    }
    pub fn attrs(&self) -> AstChildren<Attr> { support::children(&self.syntax) }
    pub fn r_attr_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["*)"])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Attr {
    pub(crate) syntax: SyntaxNode,
}
impl Attr {
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    pub fn val(&self) -> Option<Expr> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Type {
    pub(crate) syntax: SyntaxNode,
}
impl Type {
    pub fn integer_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![integer]) }
    pub fn real_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![real]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EmptyStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for EmptyStmt {}
impl EmptyStmt {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for AssignStmt {}
impl AssignStmt {
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    pub fn assign_or_expr(&self) -> Option<AssignOrExpr> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExprStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for ExprStmt {}
impl ExprStmt {
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for IfStmt {}
impl IfStmt {
    pub fn if_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![if]) }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    pub fn else_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![else]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for WhileStmt {}
impl WhileStmt {
    pub fn while_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![while]) }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    pub fn body(&self) -> Option<Stmt> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for ForStmt {}
impl ForStmt {
    pub fn for_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![for]) }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    pub fn body(&self) -> Option<Stmt> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CaseStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for CaseStmt {}
impl CaseStmt {
    pub fn case_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![case]) }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn discriminant(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    pub fn cases(&self) -> AstChildren<Case> { support::children(&self.syntax) }
    pub fn endcase_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![endcase]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EventStmt {
    pub(crate) syntax: SyntaxNode,
}
impl EventStmt {
    pub fn at_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![@]) }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    pub fn block_stmt(&self) -> Option<BlockStmt> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockStmt {
    pub(crate) syntax: SyntaxNode,
}
impl BlockStmt {
    pub fn begin_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![begin]) }
    pub fn block_scope(&self) -> Option<BlockScope> { support::child(&self.syntax) }
    pub fn body(&self) -> AstChildren<BlockItem> { support::children(&self.syntax) }
    pub fn end_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![end]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Assign {
    pub(crate) syntax: SyntaxNode,
}
impl Assign {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SimpleStmt {
    pub(crate) syntax: SyntaxNode,
}
impl SimpleStmt {
    pub fn attrs(&self) -> AstChildren<Attr> { support::children(&self.syntax) }
    pub fn assign_or_expr(&self) -> Option<AssignOrExpr> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Case {
    pub(crate) syntax: SyntaxNode,
}
impl Case {
    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }
    pub fn default_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![default]) }
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    pub fn stmt(&self) -> Option<Stmt> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BlockScope {
    pub(crate) syntax: SyntaxNode,
}
impl BlockScope {
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VarDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for VarDecl {}
impl VarDecl {
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    pub fn vars(&self) -> AstChildren<Var> { support::children(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParamDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for ParamDecl {}
impl ParamDecl {
    pub fn parameter_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![parameter])
    }
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    pub fn paras(&self) -> AstChildren<Param> { support::children(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Literal {
    pub(crate) syntax: SyntaxNode,
}
impl Literal {
    pub fn inf_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![inf]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrefixExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for PrefixExpr {}
impl PrefixExpr {
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BinExpr {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ParenExpr {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ArrayExpr {
    pub fn l_curly_arr_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["'{"])
    }
    pub fn exprs(&self) -> AstChildren<Expr> { support::children(&self.syntax) }
    pub fn r_curly_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['}']) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Call {
    pub(crate) syntax: SyntaxNode,
}
impl ast::ArgListOwner for Call {}
impl Call {
    pub fn function_ref(&self) -> Option<FunctionRef> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SelectExpr {
    pub(crate) syntax: SyntaxNode,
}
impl SelectExpr {
    pub fn condition(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn question_mark_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![?]) }
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PathExpr {
    pub(crate) syntax: SyntaxNode,
}
impl PathExpr {
    pub fn path(&self) -> Option<Path> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PortFlow {
    pub(crate) syntax: SyntaxNode,
}
impl PortFlow {
    pub fn l_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![<]) }
    pub fn port(&self) -> Option<Path> { support::child(&self.syntax) }
    pub fn r_angle_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![>]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArgList {
    pub(crate) syntax: SyntaxNode,
}
impl ArgList {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn args(&self) -> AstChildren<Expr> { support::children(&self.syntax) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SysFun {
    pub(crate) syntax: SyntaxNode,
}
impl SysFun {
    pub fn sysfun_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![sysfun]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SourceFile {
    pub(crate) syntax: SyntaxNode,
}
impl SourceFile {
    pub fn items(&self) -> AstChildren<Item> { support::children(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DisciplineDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for DisciplineDecl {}
impl DisciplineDecl {
    pub fn discipline_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![discipline])
    }
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    pub fn discipline_attrs(&self) -> AstChildren<DisciplineAttr> {
        support::children(&self.syntax)
    }
    pub fn enddiscipline_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![enddiscipline])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NatureDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for NatureDecl {}
impl NatureDecl {
    pub fn nature_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![nature]) }
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    pub fn parent(&self) -> Option<NameRef> { support::child(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    pub fn nature_attrs(&self) -> AstChildren<NatureAttr> { support::children(&self.syntax) }
    pub fn endnature_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![endnature])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ModuleDecl {
    pub fn module_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![module]) }
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn ports(&self) -> AstChildren<ModulePort> { support::children(&self.syntax) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    pub fn module_items(&self) -> AstChildren<ModuleItem> { support::children(&self.syntax) }
    pub fn endmodule_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![endmodule])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DisciplineAttr {
    pub(crate) syntax: SyntaxNode,
}
impl DisciplineAttr {
    pub fn name(&self) -> Option<Path> { support::child(&self.syntax) }
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    pub fn val(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NatureAttr {
    pub(crate) syntax: SyntaxNode,
}
impl NatureAttr {
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    pub fn val(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BodyPortDecl {
    pub(crate) syntax: SyntaxNode,
}
impl BodyPortDecl {
    pub fn port_decl(&self) -> Option<PortDecl> { support::child(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NetDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for NetDecl {}
impl NetDecl {
    pub fn discipline(&self) -> Option<NameRef> { support::child(&self.syntax) }
    pub fn net_type_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![net_type])
    }
    pub fn names(&self) -> AstChildren<Name> { support::children(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnalogBehaviour {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for AnalogBehaviour {}
impl AnalogBehaviour {
    pub fn analog_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![analog]) }
    pub fn stmt(&self) -> Option<Stmt> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Function {
    pub(crate) syntax: SyntaxNode,
}
impl Function {
    pub fn analog_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![analog]) }
    pub fn function_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![function])
    }
    pub fn ty(&self) -> Option<Type> { support::child(&self.syntax) }
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
    pub fn function_items(&self) -> AstChildren<FunctionItem> { support::children(&self.syntax) }
    pub fn endfunction_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![endfunction])
    }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BranchDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for BranchDecl {}
impl ast::ArgListOwner for BranchDecl {}
impl BranchDecl {
    pub fn branch_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![branch]) }
    pub fn names(&self) -> AstChildren<Name> { support::children(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PortDecl {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for PortDecl {}
impl PortDecl {
    pub fn direction(&self) -> Option<Direction> { support::child(&self.syntax) }
    pub fn discipline(&self) -> Option<NameRef> { support::child(&self.syntax) }
    pub fn net_type_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![net_type])
    }
    pub fn names(&self) -> AstChildren<Name> { support::children(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Var {
    pub(crate) syntax: SyntaxNode,
}
impl Var {
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    pub fn default(&self) -> Option<Expr> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}
impl Param {
    pub fn name(&self) -> Option<Name> { support::child(&self.syntax) }
    pub fn eq_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![=]) }
    pub fn default(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn constraints(&self) -> AstChildren<Constraint> { support::children(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Constraint {
    pub(crate) syntax: SyntaxNode,
}
impl Constraint {
    pub fn from_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![from]) }
    pub fn exclude_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![exclude]) }
    pub fn expr(&self) -> Option<Expr> { support::child(&self.syntax) }
    pub fn range(&self) -> Option<Range> { support::child(&self.syntax) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Range {
    pub(crate) syntax: SyntaxNode,
}
impl Range {
    pub fn l_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['(']) }
    pub fn l_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T!['[']) }
    pub fn colon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![:]) }
    pub fn r_paren_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![')']) }
    pub fn r_brack_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![']']) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Direction {
    pub(crate) syntax: SyntaxNode,
}
impl Direction {
    pub fn inout_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![inout]) }
    pub fn input_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![input]) }
    pub fn output_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![output]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionArg {
    pub(crate) syntax: SyntaxNode,
}
impl ast::AttrsOwner for FunctionArg {}
impl FunctionArg {
    pub fn direction(&self) -> Option<Direction> { support::child(&self.syntax) }
    pub fn names(&self) -> AstChildren<Name> { support::children(&self.syntax) }
    pub fn semicolon_token(&self) -> Option<SyntaxToken> { support::token(&self.syntax, T![;]) }
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    PrefixExpr(PrefixExpr),
    BinExpr(BinExpr),
    ParenExpr(ParenExpr),
    ArrayExpr(ArrayExpr),
    Call(Call),
    SelectExpr(SelectExpr),
    PathExpr(PathExpr),
    PortFlow(PortFlow),
    Literal(Literal),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    EmptyStmt(EmptyStmt),
    AssignStmt(AssignStmt),
    ExprStmt(ExprStmt),
    IfStmt(IfStmt),
    WhileStmt(WhileStmt),
    ForStmt(ForStmt),
    CaseStmt(CaseStmt),
    EventStmt(EventStmt),
    BlockStmt(BlockStmt),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssignOrExpr {
    Assign(Assign),
    Expr(Expr),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BlockItem {
    VarDecl(VarDecl),
    ParamDecl(ParamDecl),
    Stmt(Stmt),
}
impl ast::AttrsOwner for BlockItem {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctionRef {
    Path(Path),
    SysFun(SysFun),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Item {
    DisciplineDecl(DisciplineDecl),
    NatureDecl(NatureDecl),
    ModuleDecl(ModuleDecl),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ModulePort {
    PortDecl(PortDecl),
    Name(Name),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ModuleItem {
    BodyPortDecl(BodyPortDecl),
    NetDecl(NetDecl),
    AnalogBehaviour(AnalogBehaviour),
    Function(Function),
    BranchDecl(BranchDecl),
    VarDecl(VarDecl),
    ParamDecl(ParamDecl),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctionItem {
    ParamDecl(ParamDecl),
    VarDecl(VarDecl),
    FunctionArg(FunctionArg),
    Stmt(Stmt),
}
impl ast::AttrsOwner for FunctionItem {}
impl AstNode for Name {
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NameRef {
    fn can_cast(kind: SyntaxKind) -> bool { kind == NAME_REF }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Path {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AttrList {
    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR_LIST }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Attr {
    fn can_cast(kind: SyntaxKind) -> bool { kind == ATTR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Type {
    fn can_cast(kind: SyntaxKind) -> bool { kind == TYPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for EmptyStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == EMPTY_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AssignStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSIGN_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ExprStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == EXPR_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for IfStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == IF_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for WhileStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == WHILE_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ForStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == FOR_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for CaseStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == CASE_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for EventStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == EVENT_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BlockStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Assign {
    fn can_cast(kind: SyntaxKind) -> bool { kind == ASSIGN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SimpleStmt {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SIMPLE_STMT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Case {
    fn can_cast(kind: SyntaxKind) -> bool { kind == CASE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BlockScope {
    fn can_cast(kind: SyntaxKind) -> bool { kind == BLOCK_SCOPE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for VarDecl {
    fn can_cast(kind: SyntaxKind) -> bool { kind == VAR_DECL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParamDecl {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM_DECL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Literal {
    fn can_cast(kind: SyntaxKind) -> bool { kind == LITERAL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PrefixExpr {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PREFIX_EXPR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BinExpr {
    fn can_cast(kind: SyntaxKind) -> bool { kind == BIN_EXPR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ParenExpr {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PAREN_EXPR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ArrayExpr {
    fn can_cast(kind: SyntaxKind) -> bool { kind == ARRAY_EXPR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Call {
    fn can_cast(kind: SyntaxKind) -> bool { kind == CALL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SelectExpr {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SELECT_EXPR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PathExpr {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PATH_EXPR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PortFlow {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PORT_FLOW }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ArgList {
    fn can_cast(kind: SyntaxKind) -> bool { kind == ARG_LIST }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SysFun {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SYS_FUN }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for SourceFile {
    fn can_cast(kind: SyntaxKind) -> bool { kind == SOURCE_FILE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for DisciplineDecl {
    fn can_cast(kind: SyntaxKind) -> bool { kind == DISCIPLINE_DECL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NatureDecl {
    fn can_cast(kind: SyntaxKind) -> bool { kind == NATURE_DECL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for ModuleDecl {
    fn can_cast(kind: SyntaxKind) -> bool { kind == MODULE_DECL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for DisciplineAttr {
    fn can_cast(kind: SyntaxKind) -> bool { kind == DISCIPLINE_ATTR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NatureAttr {
    fn can_cast(kind: SyntaxKind) -> bool { kind == NATURE_ATTR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BodyPortDecl {
    fn can_cast(kind: SyntaxKind) -> bool { kind == BODY_PORT_DECL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for NetDecl {
    fn can_cast(kind: SyntaxKind) -> bool { kind == NET_DECL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for AnalogBehaviour {
    fn can_cast(kind: SyntaxKind) -> bool { kind == ANALOG_BEHAVIOUR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Function {
    fn can_cast(kind: SyntaxKind) -> bool { kind == FUNCTION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for BranchDecl {
    fn can_cast(kind: SyntaxKind) -> bool { kind == BRANCH_DECL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for PortDecl {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PORT_DECL }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Var {
    fn can_cast(kind: SyntaxKind) -> bool { kind == VAR }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Param {
    fn can_cast(kind: SyntaxKind) -> bool { kind == PARAM }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Constraint {
    fn can_cast(kind: SyntaxKind) -> bool { kind == CONSTRAINT }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Range {
    fn can_cast(kind: SyntaxKind) -> bool { kind == RANGE }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for Direction {
    fn can_cast(kind: SyntaxKind) -> bool { kind == DIRECTION }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl AstNode for FunctionArg {
    fn can_cast(kind: SyntaxKind) -> bool { kind == FUNCTION_ARG }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    fn syntax(&self) -> &SyntaxNode { &self.syntax }
}
impl From<PrefixExpr> for Expr {
    fn from(node: PrefixExpr) -> Expr { Expr::PrefixExpr(node) }
}
impl From<BinExpr> for Expr {
    fn from(node: BinExpr) -> Expr { Expr::BinExpr(node) }
}
impl From<ParenExpr> for Expr {
    fn from(node: ParenExpr) -> Expr { Expr::ParenExpr(node) }
}
impl From<ArrayExpr> for Expr {
    fn from(node: ArrayExpr) -> Expr { Expr::ArrayExpr(node) }
}
impl From<Call> for Expr {
    fn from(node: Call) -> Expr { Expr::Call(node) }
}
impl From<SelectExpr> for Expr {
    fn from(node: SelectExpr) -> Expr { Expr::SelectExpr(node) }
}
impl From<PathExpr> for Expr {
    fn from(node: PathExpr) -> Expr { Expr::PathExpr(node) }
}
impl From<PortFlow> for Expr {
    fn from(node: PortFlow) -> Expr { Expr::PortFlow(node) }
}
impl From<Literal> for Expr {
    fn from(node: Literal) -> Expr { Expr::Literal(node) }
}
impl AstNode for Expr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PREFIX_EXPR | BIN_EXPR | PAREN_EXPR | ARRAY_EXPR | CALL | SELECT_EXPR | PATH_EXPR
            | PORT_FLOW => true,
            _ => Literal::can_cast(kind),
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PREFIX_EXPR => Expr::PrefixExpr(PrefixExpr { syntax }),
            BIN_EXPR => Expr::BinExpr(BinExpr { syntax }),
            PAREN_EXPR => Expr::ParenExpr(ParenExpr { syntax }),
            ARRAY_EXPR => Expr::ArrayExpr(ArrayExpr { syntax }),
            CALL => Expr::Call(Call { syntax }),
            SELECT_EXPR => Expr::SelectExpr(SelectExpr { syntax }),
            PATH_EXPR => Expr::PathExpr(PathExpr { syntax }),
            PORT_FLOW => Expr::PortFlow(PortFlow { syntax }),
            _ => Expr::Literal(Literal::cast(syntax)?),
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::PrefixExpr(it) => &it.syntax,
            Expr::BinExpr(it) => &it.syntax,
            Expr::ParenExpr(it) => &it.syntax,
            Expr::ArrayExpr(it) => &it.syntax,
            Expr::Call(it) => &it.syntax,
            Expr::SelectExpr(it) => &it.syntax,
            Expr::PathExpr(it) => &it.syntax,
            Expr::PortFlow(it) => &it.syntax,
            Expr::Literal(it) => it.syntax(),
        }
    }
}
impl From<EmptyStmt> for Stmt {
    fn from(node: EmptyStmt) -> Stmt { Stmt::EmptyStmt(node) }
}
impl From<AssignStmt> for Stmt {
    fn from(node: AssignStmt) -> Stmt { Stmt::AssignStmt(node) }
}
impl From<ExprStmt> for Stmt {
    fn from(node: ExprStmt) -> Stmt { Stmt::ExprStmt(node) }
}
impl From<IfStmt> for Stmt {
    fn from(node: IfStmt) -> Stmt { Stmt::IfStmt(node) }
}
impl From<WhileStmt> for Stmt {
    fn from(node: WhileStmt) -> Stmt { Stmt::WhileStmt(node) }
}
impl From<ForStmt> for Stmt {
    fn from(node: ForStmt) -> Stmt { Stmt::ForStmt(node) }
}
impl From<CaseStmt> for Stmt {
    fn from(node: CaseStmt) -> Stmt { Stmt::CaseStmt(node) }
}
impl From<EventStmt> for Stmt {
    fn from(node: EventStmt) -> Stmt { Stmt::EventStmt(node) }
}
impl From<BlockStmt> for Stmt {
    fn from(node: BlockStmt) -> Stmt { Stmt::BlockStmt(node) }
}
impl AstNode for Stmt {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            EMPTY_STMT | ASSIGN_STMT | EXPR_STMT | IF_STMT | WHILE_STMT | FOR_STMT | CASE_STMT
            | EVENT_STMT | BLOCK_STMT => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            EMPTY_STMT => Stmt::EmptyStmt(EmptyStmt { syntax }),
            ASSIGN_STMT => Stmt::AssignStmt(AssignStmt { syntax }),
            EXPR_STMT => Stmt::ExprStmt(ExprStmt { syntax }),
            IF_STMT => Stmt::IfStmt(IfStmt { syntax }),
            WHILE_STMT => Stmt::WhileStmt(WhileStmt { syntax }),
            FOR_STMT => Stmt::ForStmt(ForStmt { syntax }),
            CASE_STMT => Stmt::CaseStmt(CaseStmt { syntax }),
            EVENT_STMT => Stmt::EventStmt(EventStmt { syntax }),
            BLOCK_STMT => Stmt::BlockStmt(BlockStmt { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::EmptyStmt(it) => &it.syntax,
            Stmt::AssignStmt(it) => &it.syntax,
            Stmt::ExprStmt(it) => &it.syntax,
            Stmt::IfStmt(it) => &it.syntax,
            Stmt::WhileStmt(it) => &it.syntax,
            Stmt::ForStmt(it) => &it.syntax,
            Stmt::CaseStmt(it) => &it.syntax,
            Stmt::EventStmt(it) => &it.syntax,
            Stmt::BlockStmt(it) => &it.syntax,
        }
    }
}
impl From<Assign> for AssignOrExpr {
    fn from(node: Assign) -> AssignOrExpr { AssignOrExpr::Assign(node) }
}
impl From<Expr> for AssignOrExpr {
    fn from(node: Expr) -> AssignOrExpr { AssignOrExpr::Expr(node) }
}
impl AstNode for AssignOrExpr {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            ASSIGN => true,
            _ => Expr::can_cast(kind),
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            ASSIGN => AssignOrExpr::Assign(Assign { syntax }),
            _ => AssignOrExpr::Expr(Expr::cast(syntax)?),
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AssignOrExpr::Assign(it) => &it.syntax,
            AssignOrExpr::Expr(it) => it.syntax(),
        }
    }
}
impl From<VarDecl> for BlockItem {
    fn from(node: VarDecl) -> BlockItem { BlockItem::VarDecl(node) }
}
impl From<ParamDecl> for BlockItem {
    fn from(node: ParamDecl) -> BlockItem { BlockItem::ParamDecl(node) }
}
impl From<Stmt> for BlockItem {
    fn from(node: Stmt) -> BlockItem { BlockItem::Stmt(node) }
}
impl AstNode for BlockItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            VAR_DECL | PARAM_DECL => true,
            _ => Stmt::can_cast(kind),
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            VAR_DECL => BlockItem::VarDecl(VarDecl { syntax }),
            PARAM_DECL => BlockItem::ParamDecl(ParamDecl { syntax }),
            _ => BlockItem::Stmt(Stmt::cast(syntax)?),
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            BlockItem::VarDecl(it) => &it.syntax,
            BlockItem::ParamDecl(it) => &it.syntax,
            BlockItem::Stmt(it) => it.syntax(),
        }
    }
}
impl From<Path> for FunctionRef {
    fn from(node: Path) -> FunctionRef { FunctionRef::Path(node) }
}
impl From<SysFun> for FunctionRef {
    fn from(node: SysFun) -> FunctionRef { FunctionRef::SysFun(node) }
}
impl AstNode for FunctionRef {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PATH | SYS_FUN => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PATH => FunctionRef::Path(Path { syntax }),
            SYS_FUN => FunctionRef::SysFun(SysFun { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FunctionRef::Path(it) => &it.syntax,
            FunctionRef::SysFun(it) => &it.syntax,
        }
    }
}
impl From<DisciplineDecl> for Item {
    fn from(node: DisciplineDecl) -> Item { Item::DisciplineDecl(node) }
}
impl From<NatureDecl> for Item {
    fn from(node: NatureDecl) -> Item { Item::NatureDecl(node) }
}
impl From<ModuleDecl> for Item {
    fn from(node: ModuleDecl) -> Item { Item::ModuleDecl(node) }
}
impl AstNode for Item {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            DISCIPLINE_DECL | NATURE_DECL | MODULE_DECL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            DISCIPLINE_DECL => Item::DisciplineDecl(DisciplineDecl { syntax }),
            NATURE_DECL => Item::NatureDecl(NatureDecl { syntax }),
            MODULE_DECL => Item::ModuleDecl(ModuleDecl { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Item::DisciplineDecl(it) => &it.syntax,
            Item::NatureDecl(it) => &it.syntax,
            Item::ModuleDecl(it) => &it.syntax,
        }
    }
}
impl From<PortDecl> for ModulePort {
    fn from(node: PortDecl) -> ModulePort { ModulePort::PortDecl(node) }
}
impl From<Name> for ModulePort {
    fn from(node: Name) -> ModulePort { ModulePort::Name(node) }
}
impl AstNode for ModulePort {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PORT_DECL | NAME => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PORT_DECL => ModulePort::PortDecl(PortDecl { syntax }),
            NAME => ModulePort::Name(Name { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ModulePort::PortDecl(it) => &it.syntax,
            ModulePort::Name(it) => &it.syntax,
        }
    }
}
impl From<BodyPortDecl> for ModuleItem {
    fn from(node: BodyPortDecl) -> ModuleItem { ModuleItem::BodyPortDecl(node) }
}
impl From<NetDecl> for ModuleItem {
    fn from(node: NetDecl) -> ModuleItem { ModuleItem::NetDecl(node) }
}
impl From<AnalogBehaviour> for ModuleItem {
    fn from(node: AnalogBehaviour) -> ModuleItem { ModuleItem::AnalogBehaviour(node) }
}
impl From<Function> for ModuleItem {
    fn from(node: Function) -> ModuleItem { ModuleItem::Function(node) }
}
impl From<BranchDecl> for ModuleItem {
    fn from(node: BranchDecl) -> ModuleItem { ModuleItem::BranchDecl(node) }
}
impl From<VarDecl> for ModuleItem {
    fn from(node: VarDecl) -> ModuleItem { ModuleItem::VarDecl(node) }
}
impl From<ParamDecl> for ModuleItem {
    fn from(node: ParamDecl) -> ModuleItem { ModuleItem::ParamDecl(node) }
}
impl AstNode for ModuleItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            BODY_PORT_DECL | NET_DECL | ANALOG_BEHAVIOUR | FUNCTION | BRANCH_DECL | VAR_DECL
            | PARAM_DECL => true,
            _ => false,
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            BODY_PORT_DECL => ModuleItem::BodyPortDecl(BodyPortDecl { syntax }),
            NET_DECL => ModuleItem::NetDecl(NetDecl { syntax }),
            ANALOG_BEHAVIOUR => ModuleItem::AnalogBehaviour(AnalogBehaviour { syntax }),
            FUNCTION => ModuleItem::Function(Function { syntax }),
            BRANCH_DECL => ModuleItem::BranchDecl(BranchDecl { syntax }),
            VAR_DECL => ModuleItem::VarDecl(VarDecl { syntax }),
            PARAM_DECL => ModuleItem::ParamDecl(ParamDecl { syntax }),
            _ => return None,
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ModuleItem::BodyPortDecl(it) => &it.syntax,
            ModuleItem::NetDecl(it) => &it.syntax,
            ModuleItem::AnalogBehaviour(it) => &it.syntax,
            ModuleItem::Function(it) => &it.syntax,
            ModuleItem::BranchDecl(it) => &it.syntax,
            ModuleItem::VarDecl(it) => &it.syntax,
            ModuleItem::ParamDecl(it) => &it.syntax,
        }
    }
}
impl From<ParamDecl> for FunctionItem {
    fn from(node: ParamDecl) -> FunctionItem { FunctionItem::ParamDecl(node) }
}
impl From<VarDecl> for FunctionItem {
    fn from(node: VarDecl) -> FunctionItem { FunctionItem::VarDecl(node) }
}
impl From<FunctionArg> for FunctionItem {
    fn from(node: FunctionArg) -> FunctionItem { FunctionItem::FunctionArg(node) }
}
impl From<Stmt> for FunctionItem {
    fn from(node: Stmt) -> FunctionItem { FunctionItem::Stmt(node) }
}
impl AstNode for FunctionItem {
    fn can_cast(kind: SyntaxKind) -> bool {
        match kind {
            PARAM_DECL | VAR_DECL | FUNCTION_ARG => true,
            _ => Stmt::can_cast(kind),
        }
    }
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            PARAM_DECL => FunctionItem::ParamDecl(ParamDecl { syntax }),
            VAR_DECL => FunctionItem::VarDecl(VarDecl { syntax }),
            FUNCTION_ARG => FunctionItem::FunctionArg(FunctionArg { syntax }),
            _ => FunctionItem::Stmt(Stmt::cast(syntax)?),
        };
        Some(res)
    }
    fn syntax(&self) -> &SyntaxNode {
        match self {
            FunctionItem::ParamDecl(it) => &it.syntax,
            FunctionItem::VarDecl(it) => &it.syntax,
            FunctionItem::FunctionArg(it) => &it.syntax,
            FunctionItem::Stmt(it) => it.syntax(),
        }
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignOrExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctionRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Item {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModulePort {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModuleItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctionItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NameRef {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Path {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AttrList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Attr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EmptyStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ExprStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CaseStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for EventStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Assign {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SimpleStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Case {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BlockScope {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for VarDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParamDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PrefixExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArrayExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Call {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SelectExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PathExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PortFlow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ArgList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SysFun {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for SourceFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DisciplineDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NatureDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ModuleDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DisciplineAttr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NatureAttr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BodyPortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NetDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AnalogBehaviour {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Function {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BranchDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PortDecl {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Var {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Constraint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Range {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Direction {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FunctionArg {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
