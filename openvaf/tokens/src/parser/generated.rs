//! Generated by `sourcegen_ast`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    SEMICOLON,
    COMMA,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    L_ANGLE,
    R_ANGLE,
    AT,
    POUND,
    TILDE,
    QUESTION,
    DOLLAR,
    AMP,
    PIPE,
    PLUS,
    STAR,
    SLASH,
    CARET,
    PERCENT,
    UNDERSCORE,
    DOT,
    COLON,
    EQ,
    EQ2,
    BANG,
    NEQ,
    MINUS,
    LTEQ,
    GTEQ,
    AMP2,
    PIPE2,
    ASHL,
    ASHR,
    SHL,
    SHR,
    L_ATTR_PAREN,
    R_ATTR_PAREN,
    ARR_START,
    CONTR,
    POW,
    L_NXOR,
    R_NXOR,
    ANALOG_KW,
    BEGIN_KW,
    BRANCH_KW,
    CASE_KW,
    DEFAULT_KW,
    DISABLE_KW,
    DISCIPLINE_KW,
    ELSE_KW,
    END_KW,
    ENDCASE_KW,
    ENDDISCIPLINE_KW,
    ENDFUNCTION_KW,
    ENDMODULE_KW,
    ENDNATURE_KW,
    EXCLUDE_KW,
    FOR_KW,
    FROM_KW,
    FUNCTION_KW,
    IF_KW,
    INF_KW,
    INOUT_KW,
    INPUT_KW,
    INTEGER_KW,
    MODULE_KW,
    NATURE_KW,
    OUTPUT_KW,
    PARAMETER_KW,
    LOCALPARAM_KW,
    REAL_KW,
    STRING_KW,
    WHILE_KW,
    ROOT_KW,
    INITIAL_STEP_KW,
    FINAL_STEP_KW,
    ALIASPARAM_KW,
    INT_NUMBER,
    STD_REAL_NUMBER,
    SI_REAL_NUMBER,
    STR_LIT,
    ERROR,
    IDENT,
    SYSFUN,
    NET_TYPE,
    WHITESPACE,
    COMMENT,
    ANALOG_BEHAVIOUR,
    ARG,
    ARG_LIST,
    ARRAY_EXPR,
    ASSIGN,
    ASSIGN_STMT,
    ASSIGN_OR_EXPR,
    ATTR,
    ATTR_LIST,
    BIN_EXPR,
    BLOCK_SCOPE,
    BLOCK_STMT,
    BRANCH_DECL,
    CALL,
    CASE,
    CASE_STMT,
    CONSTRAINT,
    DIRECTION,
    DISCIPLINE_DECL,
    DISCIPLINE_ATTR,
    EVENT_STMT,
    FOR_STMT,
    FUNCTION,
    FUNCTION_ARG,
    IF_STMT,
    LITERAL,
    MODULE_DECL,
    MODULE_PORT,
    MODULE_PORTS,
    NAME,
    NAME_REF,
    SYS_FUN,
    BODY_PORT_DECL,
    NATURE_DECL,
    NATURE_ATTR,
    NET_DECL,
    NETS,
    PARAM,
    ALIAS_PARAM,
    PARAM_DECL,
    PAREN_EXPR,
    PATH,
    PATH_EXPR,
    PORT_DECL,
    PORTS,
    PREFIX_EXPR,
    RANGE,
    SELECT_EXPR,
    TYPE,
    VAR,
    VAR_DECL,
    WHILE_STMT,
    EMPTY_STMT,
    EXPR_STMT,
    PORT_FLOW,
    SOURCE_FILE,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        match self {
            ANALOG_KW | BEGIN_KW | BRANCH_KW | CASE_KW | DEFAULT_KW | DISABLE_KW
            | DISCIPLINE_KW | ELSE_KW | END_KW | ENDCASE_KW | ENDDISCIPLINE_KW | ENDFUNCTION_KW
            | ENDMODULE_KW | ENDNATURE_KW | EXCLUDE_KW | FOR_KW | FROM_KW | FUNCTION_KW | IF_KW
            | INF_KW | INOUT_KW | INPUT_KW | INTEGER_KW | MODULE_KW | NATURE_KW | OUTPUT_KW
            | PARAMETER_KW | LOCALPARAM_KW | REAL_KW | STRING_KW | WHILE_KW | ROOT_KW
            | INITIAL_STEP_KW | FINAL_STEP_KW | ALIASPARAM_KW => true,
            _ => false,
        }
    }
    pub fn is_punct(self) -> bool {
        match self {
            SEMICOLON | COMMA | L_PAREN | R_PAREN | L_CURLY | R_CURLY | L_BRACK | R_BRACK
            | L_ANGLE | R_ANGLE | AT | POUND | TILDE | QUESTION | DOLLAR | AMP | PIPE | PLUS
            | STAR | SLASH | CARET | PERCENT | UNDERSCORE | DOT | COLON | EQ | EQ2 | BANG | NEQ
            | MINUS | LTEQ | GTEQ | AMP2 | PIPE2 | ASHL | ASHR | SHL | SHR | L_ATTR_PAREN
            | R_ATTR_PAREN | ARR_START | CONTR | POW | L_NXOR | R_NXOR => true,
            _ => false,
        }
    }
    pub fn is_literal(self) -> bool {
        match self {
            INT_NUMBER | STD_REAL_NUMBER | SI_REAL_NUMBER | STR_LIT => true,
            _ => false,
        }
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "analog" => ANALOG_KW,
            "begin" => BEGIN_KW,
            "branch" => BRANCH_KW,
            "case" => CASE_KW,
            "default" => DEFAULT_KW,
            "disable" => DISABLE_KW,
            "discipline" => DISCIPLINE_KW,
            "else" => ELSE_KW,
            "end" => END_KW,
            "endcase" => ENDCASE_KW,
            "enddiscipline" => ENDDISCIPLINE_KW,
            "endfunction" => ENDFUNCTION_KW,
            "endmodule" => ENDMODULE_KW,
            "endnature" => ENDNATURE_KW,
            "exclude" => EXCLUDE_KW,
            "for" => FOR_KW,
            "from" => FROM_KW,
            "function" => FUNCTION_KW,
            "if" => IF_KW,
            "inf" => INF_KW,
            "inout" => INOUT_KW,
            "input" => INPUT_KW,
            "integer" => INTEGER_KW,
            "module" => MODULE_KW,
            "nature" => NATURE_KW,
            "output" => OUTPUT_KW,
            "parameter" => PARAMETER_KW,
            "localparam" => LOCALPARAM_KW,
            "real" => REAL_KW,
            "string" => STRING_KW,
            "while" => WHILE_KW,
            "root" => ROOT_KW,
            "initial_step" => INITIAL_STEP_KW,
            "final_step" => FINAL_STEP_KW,
            "aliasparam" => ALIASPARAM_KW,
            "reg" | "wreal" | "wire" | "uwire" | "wand" | "wor" | "ground" => NET_TYPE,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            ';' => SEMICOLON,
            ',' => COMMA,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_CURLY,
            '}' => R_CURLY,
            '[' => L_BRACK,
            ']' => R_BRACK,
            '<' => L_ANGLE,
            '>' => R_ANGLE,
            '@' => AT,
            '#' => POUND,
            '~' => TILDE,
            '?' => QUESTION,
            '$' => DOLLAR,
            '&' => AMP,
            '|' => PIPE,
            '+' => PLUS,
            '*' => STAR,
            '/' => SLASH,
            '^' => CARET,
            '%' => PERCENT,
            '_' => UNDERSCORE,
            '.' => DOT,
            ':' => COLON,
            '=' => EQ,
            '!' => BANG,
            '-' => MINUS,
            _ => return None,
        };
        Some(tok)
    }
}
impl std::fmt::Display for SyntaxKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let pretty = match self {
            Self::SEMICOLON => "';'",
            Self::COMMA => "','",
            Self::L_PAREN => "'('",
            Self::R_PAREN => "')'",
            Self::L_CURLY => "'{'",
            Self::R_CURLY => "'}'",
            Self::L_BRACK => "'['",
            Self::R_BRACK => "']'",
            Self::L_ANGLE => "'<'",
            Self::R_ANGLE => "'>'",
            Self::AT => "'@'",
            Self::POUND => "'#'",
            Self::TILDE => "'~'",
            Self::QUESTION => "'?'",
            Self::DOLLAR => "'$'",
            Self::AMP => "'&'",
            Self::PIPE => "'|'",
            Self::PLUS => "'+'",
            Self::STAR => "'*'",
            Self::SLASH => "'/'",
            Self::CARET => "'^'",
            Self::PERCENT => "'%'",
            Self::UNDERSCORE => "'_'",
            Self::DOT => "'.'",
            Self::COLON => "':'",
            Self::EQ => "'='",
            Self::EQ2 => "'=='",
            Self::BANG => "'!'",
            Self::NEQ => "'!='",
            Self::MINUS => "'-'",
            Self::LTEQ => "'<='",
            Self::GTEQ => "'>='",
            Self::AMP2 => "'&&'",
            Self::PIPE2 => "'||'",
            Self::ASHL => "'<<<'",
            Self::ASHR => "'>>>'",
            Self::SHL => "'<<'",
            Self::SHR => "'>>'",
            Self::L_ATTR_PAREN => "'(*'",
            Self::R_ATTR_PAREN => "'*)'",
            Self::ARR_START => "''{'",
            Self::CONTR => "'<+'",
            Self::POW => "'**'",
            Self::L_NXOR => "'~^'",
            Self::R_NXOR => "'^~'",
            Self::ANALOG_KW => "'analog'",
            Self::BEGIN_KW => "'begin'",
            Self::BRANCH_KW => "'branch'",
            Self::CASE_KW => "'case'",
            Self::DEFAULT_KW => "'default'",
            Self::DISABLE_KW => "'disable'",
            Self::DISCIPLINE_KW => "'discipline'",
            Self::ELSE_KW => "'else'",
            Self::END_KW => "'end'",
            Self::ENDCASE_KW => "'endcase'",
            Self::ENDDISCIPLINE_KW => "'enddiscipline'",
            Self::ENDFUNCTION_KW => "'endfunction'",
            Self::ENDMODULE_KW => "'endmodule'",
            Self::ENDNATURE_KW => "'endnature'",
            Self::EXCLUDE_KW => "'exclude'",
            Self::FOR_KW => "'for'",
            Self::FROM_KW => "'from'",
            Self::FUNCTION_KW => "'function'",
            Self::IF_KW => "'if'",
            Self::INF_KW => "'inf'",
            Self::INOUT_KW => "'inout'",
            Self::INPUT_KW => "'input'",
            Self::INTEGER_KW => "'integer'",
            Self::MODULE_KW => "'module'",
            Self::NATURE_KW => "'nature'",
            Self::OUTPUT_KW => "'output'",
            Self::PARAMETER_KW => "'parameter'",
            Self::LOCALPARAM_KW => "'localparam'",
            Self::REAL_KW => "'real'",
            Self::STRING_KW => "'string'",
            Self::WHILE_KW => "'while'",
            Self::ROOT_KW => "'root'",
            Self::INITIAL_STEP_KW => "'initial_step'",
            Self::FINAL_STEP_KW => "'final_step'",
            Self::ALIASPARAM_KW => "'aliasparam'",
            Self::INT_NUMBER => "integer",
            Self::STD_REAL_NUMBER | Self::SI_REAL_NUMBER => "real number",
            Self::STR_LIT => "string literal",
            Self::LITERAL => "literal",
            Self::IDENT | Self::NAME => "identifier",
            Self::SYSFUN => "system function identifier",
            Self::WHITESPACE => "whitespace",
            Self::COMMENT => "comment",
            Self::FUNCTION => "function decl.",
            Self::PORT_DECL => "port decl.",
            Self::NET_DECL => "net decl.",
            Self::ANALOG_BEHAVIOUR => "analog block",
            _ => return std::fmt::Debug::fmt(self, f),
        };
        write!(f, "{}", pretty)
    }
}
#[macro_export]
macro_rules ! T { [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [@] => { $ crate :: SyntaxKind :: AT } ; [#] => { $ crate :: SyntaxKind :: POUND } ; [~] => { $ crate :: SyntaxKind :: TILDE } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [$] => { $ crate :: SyntaxKind :: DOLLAR } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [^] => { $ crate :: SyntaxKind :: CARET } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [_] => { $ crate :: SyntaxKind :: UNDERSCORE } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQ2 } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [!=] => { $ crate :: SyntaxKind :: NEQ } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [<=] => { $ crate :: SyntaxKind :: LTEQ } ; [>=] => { $ crate :: SyntaxKind :: GTEQ } ; [&&] => { $ crate :: SyntaxKind :: AMP2 } ; [||] => { $ crate :: SyntaxKind :: PIPE2 } ; [<<<] => { $ crate :: SyntaxKind :: ASHL } ; [>>>] => { $ crate :: SyntaxKind :: ASHR } ; [<<] => { $ crate :: SyntaxKind :: SHL } ; [>>] => { $ crate :: SyntaxKind :: SHR } ; ["(*"] => { $ crate :: SyntaxKind :: L_ATTR_PAREN } ; ["*)"] => { $ crate :: SyntaxKind :: R_ATTR_PAREN } ; ["'{"] => { $ crate :: SyntaxKind :: ARR_START } ; [<+] => { $ crate :: SyntaxKind :: CONTR } ; [**] => { $ crate :: SyntaxKind :: POW } ; [~^] => { $ crate :: SyntaxKind :: L_NXOR } ; [^~] => { $ crate :: SyntaxKind :: R_NXOR } ; [analog] => { $ crate :: SyntaxKind :: ANALOG_KW } ; [begin] => { $ crate :: SyntaxKind :: BEGIN_KW } ; [branch] => { $ crate :: SyntaxKind :: BRANCH_KW } ; [case] => { $ crate :: SyntaxKind :: CASE_KW } ; [default] => { $ crate :: SyntaxKind :: DEFAULT_KW } ; [disable] => { $ crate :: SyntaxKind :: DISABLE_KW } ; [discipline] => { $ crate :: SyntaxKind :: DISCIPLINE_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [end] => { $ crate :: SyntaxKind :: END_KW } ; [endcase] => { $ crate :: SyntaxKind :: ENDCASE_KW } ; [enddiscipline] => { $ crate :: SyntaxKind :: ENDDISCIPLINE_KW } ; [endfunction] => { $ crate :: SyntaxKind :: ENDFUNCTION_KW } ; [endmodule] => { $ crate :: SyntaxKind :: ENDMODULE_KW } ; [endnature] => { $ crate :: SyntaxKind :: ENDNATURE_KW } ; [exclude] => { $ crate :: SyntaxKind :: EXCLUDE_KW } ; [for] => { $ crate :: SyntaxKind :: FOR_KW } ; [from] => { $ crate :: SyntaxKind :: FROM_KW } ; [function] => { $ crate :: SyntaxKind :: FUNCTION_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [inf] => { $ crate :: SyntaxKind :: INF_KW } ; [inout] => { $ crate :: SyntaxKind :: INOUT_KW } ; [input] => { $ crate :: SyntaxKind :: INPUT_KW } ; [integer] => { $ crate :: SyntaxKind :: INTEGER_KW } ; [module] => { $ crate :: SyntaxKind :: MODULE_KW } ; [nature] => { $ crate :: SyntaxKind :: NATURE_KW } ; [output] => { $ crate :: SyntaxKind :: OUTPUT_KW } ; [parameter] => { $ crate :: SyntaxKind :: PARAMETER_KW } ; [localparam] => { $ crate :: SyntaxKind :: LOCALPARAM_KW } ; [real] => { $ crate :: SyntaxKind :: REAL_KW } ; [string] => { $ crate :: SyntaxKind :: STRING_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [root] => { $ crate :: SyntaxKind :: ROOT_KW } ; [initial_step] => { $ crate :: SyntaxKind :: INITIAL_STEP_KW } ; [final_step] => { $ crate :: SyntaxKind :: FINAL_STEP_KW } ; [aliasparam] => { $ crate :: SyntaxKind :: ALIASPARAM_KW } ; [ident] => { $ crate :: SyntaxKind :: IDENT } ; [net_type] => { $ crate :: SyntaxKind :: NET_TYPE } ; [sysfun] => { $ crate :: SyntaxKind :: SYSFUN } ; }
