// ****************************************************************************
// *  BSIM-IMG 102.9.1 released by Pragya Kushwaha on 11/21/2017              *
// *  BSIM Independent Multi-Gate Model (Verilog-A)                           *
// ****************************************************************************

// ****************************************************************************
// *  Copyright 2017 Regents of the University of California                  *
// *  All rights reserved.                                                    *
// *                                                                          *
// *  Project director: Prof. Chenming Hu                                     *
// *                                                                          *
// *  Current developers: Dr. Pragya Kushwaha (Postdoc, UC Berkeley)          *
// *                      Yen-Kai Lin (Ph.D. student, UC Berkeley)            *
// *                      Juan Duarte (Ph.D. student, UC Berkeley)            *
// *                      Dr. Harshit Agarwal (Postdoc, UC Berkeley)          *
// *                      Dr. Huan-Lin Chang (Postdoc, UC Berkeley)           *
// ****************************************************************************

// ****************************************************************************
// *  Software is distributed as is, completely without warranty or service   *
// *  support. The University of California and its employees are not liable  *
// *  for the condition or performance of the software.                       *
// *                                                                          *
// *  The University of California owns the copyright and grants users a      *
// *  perpetual, irrevocable, worldwide, non-exclusive, royalty-free license  *
// *  with respect to the software as set forth below.                        *
// *                                                                          *
// *  The University of California hereby disclaims all implied warranties.   *
// *                                                                          *
// *  The University of California grants the users the right to modify,      *
// *  copy, and redistribute the software and documentation, both within      *
// *  the user's organization and externally, subject to the following        *
// *  restrictions:                                                           *
// *                                                                          *
// *  1. The users agree not to charge for the University of California code  *
// *     itself but may charge for additions, extensions, or support.         *
// *                                                                          *
// *  2. In any product based on the software, the users agree to             *
// *     acknowledge the University of California that developed the          *
// *     software. This acknowledgment shall appear in the product            *
// *     documentation.                                                       *
// *                                                                          *
// *  3. Redistributions to others of source code and documentation must      *
// *     retain the copyright notice, disclaimer, and list of conditions.     *
// *                                                                          *
// *  4. Redistributions to others in binary form must reproduce the          *
// *     copyright notice, disclaimer, and list of conditions in the          *
// *     documentation and/or other materials provided with the               *
// *     distribution.                                                        *
// *                                                                          *
// *  Agreed to on _________Nov. 21, 2017__________                           *
// *                                                                          *
// *  By: ____University of California, Berkeley___                           *
// *      ____Chenming Hu__________________________                           *
// *      ____Professor in Graduate School ________                           *
// ****************************************************************************

// Clamped exponential function
analog function real lexp;
    input x;
    real x;

    begin
        if (x > `EXPL_THRESHOLD) begin
            lexp = `MAX_EXPL * (1.0 + x - `EXPL_THRESHOLD);
        end else if (x < -`EXPL_THRESHOLD) begin
            lexp = `MIN_EXPL;
        end else begin
            lexp = exp(x);
        end
    end
endfunction

// Clamped log function
analog function real lln;
    input x;
    real x;

    begin
        lln = (x > `N_MINLOG) ? ln(x) : `LN_N_MINLOG;
    end
endfunction

// Hyperbolic smoothing function
analog function real hypsmooth;
    input x, c;
    real x, c;

    begin
        hypsmooth = 0.5 * (x + sqrt(x * x + 4.0 * c * c));
    end
endfunction

// Hyperbolic smooth max function
analog function real hypmax;
    input x, xmin, c;
    real x, xmin, c;

    begin
        hypmax = xmin + 0.5 * (x - xmin - c + sqrt((x - xmin - c) * (x - xmin - c) - 4.0 * xmin * c));
    end
endfunction

// Smooth function to fix minimum value of a variable
analog function real smoothminx;
    input x, x0, deltax;
    real x, x0, deltax;

    begin
        smoothminx = 0.5 * (x + x0 + sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax));
    end
endfunction

// *************************
// *  Instance Parameters  *
// *************************

// Note: Some instance parameters are also model parameters. Please refer to the technical note for details.
`IPRco( L              ,30e-9          ,"m"           ,1e-9        ,inf         ,"Designed Gate Length" )
`IPRco( W              ,1e-6           ,"m"           ,1e-9        ,inf         ,"Designed Gate Width" )
`IPIco( NF             ,1              ,""            ,1           ,inf         ,"Number of fingers" )
`IPRcz( AS             ,0.0            ,"m^2"                                   ,"Source area" )
`IPRcz( AD             ,0.0            ,"m^2"                                   ,"Drain area" )
`IPRcz( PS             ,0.0            ,"m"                                     ,"Source perimeter" )
`IPRcz( PD             ,0.0            ,"m"                                     ,"Drain perimeter" )
`IPRcz( NRS            ,0.0            ,""                                      ,"Number of source diffusion squares" )
`IPRcz( NRD            ,0.0            ,""                                      ,"Number of drain diffusion squares" )

// Variability Handles
`IPRnb( XL             ,0.0            ,"m"                                     ,"L offset for channel length due to mask/etch effect" )
`IPRnb( DTEMP          ,0.0            ,"Celsius"                               ,"Variability in Device Temperature" )
`IPRnb( DELVTRAND      ,0.0            ,"V"                                     ,"Variability in Vth" )
`IPRoz( U0MULT         ,1.0            ,""                                      ,"Variability in carrier mobility" )

// **********************
// *  Model Parameters  *
// **********************
`MPIty( TYPE           ,`ntype         ,""                                      ,"NMOS = 1, PMOS = -1" )
`MPIty( WELLTYPE       ,-TYPE          ,""                                      ,"Well (substrate) type" )
`MPIcc( CHARGEMOD      ,0              ,""            ,0           ,1           ,"0: Computationally efficient charge density model, 1: Accurate inversion charge density model")
`MPIcc( RDSMOD         ,0              ,""            ,0           ,2           ,"0: Bias-dependent S/D resistances internal and bias-independent S/D resistances external, 1: Both bias-dependent and independent of S/D resistances external, 2: Both bias-dependent and independent of S/D resistances internal" )
`MPIcc( GIDLMOD        ,0              ,""            ,0           ,1           ,"0: Turn off GIDL/GISL current, 1: Turn on GIDL/GISL current" )
`MPIcc( IGCMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igc, Igs and Igd, 1: Turn on Igc, Igs and Igd" )
`MPIcc( IGBMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igb" )
`MPIcc( SHMOD          ,0              ,""            ,0           ,1           ,"0: No self-heating" )
`MPIcc( RGATEMOD       ,0              ,""            ,0           ,1           ,"Gate resistance model selector" )
`MPIcc( NQSMOD         ,0              ,""            ,0           ,1           ,"0: Turn off NQS model, 1: NQS gate resistance (with gi node)" )
`MPIcc( NFMOD          ,0              ,""            ,0           ,1           ,"0: W taken as total width like BSIM4, 1: W taken as single finger width  " )
`MPRnb( XW             ,0.0            ,"m"                                     ,"W offset for channel width due to mask/etch effect" )
`MPRnb( LINT           ,0.0            ,"m"                                     ,"Delta L for IV" )
`MPRnb( LL             ,0.0            ,"m^(1+LLN)"                             ,"" )
`MPRnb( LW             ,0.0            ,"m^(1+LWN)"                             ,"" )
`MPRnb( LWL            ,0.0            ,"m^(LWN+LLN+1)"                         ,"" )
`MPRnb( LLN            ,1.0            ,""                                      ,"" )
`MPRnb( LWN            ,1.0            ,""                                      ,"" )
`MPRnb( WINT           ,0.0            ,"m"                                     ,"Delta W for IV" )
`MPRnb( WL             ,0.0            ,"m^(1+WLN)"                             ,"" )
`MPRnb( WW             ,0.0            ,"m^(1+WWN)"                             ,"" )
`MPRnb( WWL            ,0.0            ,"m^(WLN+WWN+1)"                         ,"" )
`MPRnb( WLN            ,1.0            ,""                                      ,"" )
`MPRnb( WWN            ,1.0            ,""                                      ,"" )
`MPRnb( DLC            ,0.0            ,"m"                                     ,"Delta L for CV" )
`MPRnb( LLC            ,0.0            ,"m"                                     ,"" )
`MPRnb( LWC            ,0.0            ,"m"                                     ,"" )
`MPRnb( LWLC           ,0.0            ,"m"                                     ,"" )
`MPRnb( DWC            ,0.0            ,"m"                                     ,"Delta W for CV" )
`MPRnb( WLC            ,0.0            ,"m"                                     ,"" )
`MPRnb( WWC            ,0.0            ,"m"                                     ,"" )
`MPRnb( WWLC           ,0.0            ,"m"                                     ,"" )
`MPRco( EOT1           ,1.0e-9         ,"m"           ,0.1e-9      ,inf         ,"Equivalent front gate dielectric thickness relative to SiO2" )
`MPRco( EOT2           ,10e-9          ,"m"           ,0.1e-9      ,inf         ,"Equivalent back  gate dielectric thickness relative to SiO2" )
`MPRco( EOT1P          ,EOT1           ,"m"           ,0.1e-9      ,inf         ,"Equivalent physical front gate dielectric thickness relative to SiO2" )
`MPRnb( DTOX1          ,0.0            ,"m"                                     ,"Difference between effective dielectric thickness and physical thickness" )
`MPRco( TSI            ,8.0e-9         ,"m"           ,1e-9        ,inf         ,"Body thickness" )
`MPRcc( NBODY          ,1e22           ,"m^-3"        ,1e18        ,5e24        ,"Channel (body) doping" )
`MPRcc( NSD            ,2e26           ,"m^-3"        ,2e25        ,1e27        ,"Source/drain active doping concentration" )
`MPRcz( NBG            ,5.0e23         ,"m^-3"                                  ,"Well/substrate (or also called back-gate) doping, zero for metal" )
`MPRcz( EASUB          ,4.05           ,"eV"                                    ,"Electron affinity of well/substrate" )
`MPRoz( NI0SUB         ,1.1e16         ,"m^-3"                                  ,"Intrinsic carrier constant at 300.15K" )
`MPRoz( BG0SUB         ,1.12           ,"eV"                                    ,"Band gap of well/substrate at 300.15K" )
`MPRoz( NC0SUB         ,2.86e25        ,""                                      ,"Conduction band density of states" )
`MPRoz( PHIG1          ,4.61           ,"eV"                                    ,"Front Gate Workfunction" )
`MPRoz( PHIG2          ,((WELLTYPE == `ptype) ? (EASUB + BG0SUB) : EASUB),"eV"  ,"Back gate workfunction, will be modified according to NBG later in the code" )
`MPRoz( EPSRSUB        ,11.9           ,""                                      ,"Relative dielectric constant of the channel material" )
`MPRoz( EPSROX1        ,3.9            ,""                                      ,"Relative dielectric constant of the front gate dielectric" )

 // Short Channel Effects
`MPRnb( ASCL           ,0.0            ,""                                      ,"Parameter for back-gate dependent scale length" )
`MPRnb( BSCL           ,0.0            ,"V^-1"                                  ,"Parameter for back-gate dependent scale length" )
`MPRnb( CIT            ,0.0            ,"F/(m^2)"                               ,"Parameter for interface trap" )
`MPRnb( CDSC           ,0.14           ,"F/(m^2)"                               ,"Coupling capacitance between S/D and channel" )
`MPRnb( CDSCD          ,0.14           ,"F/(m^2*V)"                             ,"Drain-bias sensitivity of CDSC" )
`MPRnb( CBGCBG0        ,0.0            ,"F/(m^2*V)"                             ,"Backgate-bias sensitivity of SS for long channel" )
`MPRnb( CBGCBG0P       ,0.0            ,"F/(m^2*V^2)"                           ,"Backgate-bias sensitivity of SS for long channel" )
`MPRnb( CBGCBG         ,0.0            ,"F/(m^2*V)"                             ,"Backgate-bias sensitivity of CDSC" )
`MPRnb( CBGCBGP        ,0.0            ,"F/(m^2*V^2)"                           ,"Nonlinear backgate-bias sensitivity of SS" )
`MPRnb( CBGCBGD        ,0.0            ,"F/(m^2*V^2)"                           ,"Backgate-bias sensitivity of CDSCD" )
`MPRnb( DVT0           ,19.20          ,""                                      ,"SCE coefficient" )
`MPRnb( DVT1           ,0.45           ,""                                      ,"SCE exponent coefficient" )
`MPRnb( PHIN           ,0.045          ,"V"                                     ,"Nonuniform vertical doping effect on surface potential" )
`MPRnb( ETA0           ,2.00           ,""                                      ,"DIBL coefficient 1" )
`MPRnb( ETA1           ,0.00           ,""                                      ,"DIBL coefficient for low gate overdrive" )
`MPRnb( DSUB           ,0.375          ,""                                      ,"DIBL coefficient 2 (exponent coefficient)" )
`MPRnb( ETAB           ,0.00           ,""                                      ,"DIBL coefficient - Back Gate dependence" )
`MPRnb( K1RSCE         ,-0.32          ,""                                      ,"Vt Roll-off at moderate Lg" )
`MPRnb( LPE0           ,8.2e-9         ,"m"                                     ,"Equivalent length of pocket region at zero bias" )
`MPRnb( DSC0           ,0.0            ,""                                      ,"Parameter for short channel effect at moderate L and high drain bias" )
`MPRnb( DSC1           ,1.00e-9        ,""                                      ,"Parameter for short channel effect at moderate L and high drain bias" )

// Lateral non-uniform doping effect (IV-CV Vth shift)
`MPRnb( K0             ,0.0            ,"V"                                     ,"Lateral NUD voltage parameter" )
`MPRnb( K01            ,0.0            ,"V/K"                                   ,"Temperature dependence of lateral NUD voltage parameter" )
`MPRnb( K0SI           ,1.0            ,""                                      ,"Correction factor for strong inversion, used in Mnud, after binning should be from (0:inf)" )
`MPRnb( K0SI1          ,0.0            ,"K^-1"                                  ,"Temperature dependence of K0SI" )

// Quantum Mechanical Effects
`MPRnb( QMTCENCV       ,0.0            ,""                                      ,"Prefactor + switch for QM Width and Toxeff correction for CV" )
`MPRnb( ETAQM          ,0.54           ,""                                      ,"Bulk charge coefficient for Tcen" )
`MPRoz( QM0            ,1.00e-3        ,""                                      ,"Knee-Point for Tcen in inversion (Charge normalized to Cox)" )
`MPRnb( PQM            ,0.66           ,""                                      ,"Slope of normalized Tcen in inversion" )
`MPRco( TOXP           ,EOT1           ,"m"           ,0.1e-9      ,inf         ,"physical oxide thickness" )

// Velocity Saturation Model
`MPRnb( VSAT           ,85000          ,"m/s"                                   ,"Saturation Velocity" )
`MPRnb( AVSAT          ,0.0            ,"m/s"                                   ,"" )
`MPRex( BVSAT          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( VSAT1          ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter" )
`MPRnb( AVSAT1         ,AVSAT          ,"m/s"                                   ,"" )
`MPRex( BVSAT1         ,BVSAT          ,"m"           ,0.0                      ,"" )
`MPRnb( VSATCV         ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter for CV" )
`MPRnb( AVSATCV        ,AVSAT          ,"m/s"                                   ,"" )
`MPRex( BVSATCV        ,BVSAT          ,"m"           ,0.0                      ,"" )
`MPRnb( DELTAVSAT      ,1.0            ,"m/s"                                   ,"Velocity saturation parameter" )
`MPRnb( KSATIV         ,1.0            ,""                                      ,"Parameter for strong inversion regime for long channel Vdsat" )
`MPRnb( KSUBIV         ,1.0            ,""                                      ,"Parameter for weak inversion regime for long channel Vdsat" )
`MPRnb( MEXP           ,4.0            ,""                                      ,"Smoothing function factor for Vdsat" )
`MPRnb( AMEXP          ,0.0            ,""                                      ,"" )
`MPRnb( BMEXP          ,1.0            ,""                                      ,"" )
`MPRnb( PTWG           ,0.0            ,"V^-2"                                  ,"Correction factor for velocity saturation" )
`MPRnb( APTWG          ,0.0            ,"V^-2"                                  ,"" )
`MPRex( BPTWG          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( AT             ,-1.56e-3       ,""                                      ,"Saturation Velocity Temperature Coefficient" )
`MPRnb( ATL            ,0.0            ,""                                      ,"Length scaling for AT" )
`MPRnb( TMEXP          ,0.0            ,""                                      ,"" )
`MPRnb( PTWGT          ,0.004          ,""                                      ,"" )
`MPRnb( PTWGB          ,0.0            ,"V^-3"                                  ,"" )
`MPRnb( PTWGB2         ,0.0            ,"V^-3"                                  ,"" )
`MPRnb( APTWGB         ,0.0            ,"V^-3"                                  ,"" )
`MPRex( BPTWGB         ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( APTWGB2        ,0.0            ,"V^-3"                                  ,"" )
`MPRex( BPTWGB2        ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( VSATB          ,0.0            ,"V^-1"                                  ,"" )
`MPRnb( ATB            ,0.0            ,""                                      ,"Back bias sensitivity parameter for saturation velocity temperature coefficient" )
`MPRnb( ATBL           ,0.0            ,""                                      ,"Length scaling for ATB" )
`MPRnb( AVSATB         ,0.0            ,"V^-1"                                  ,"" )
`MPRex( BVSATB         ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRco( DVSATCLAMP     ,0.01           ,"m"           ,0.01        ,inf         ,"Minimum clamp on Dvsat" )

// Mobility Model
`MPRex( U0             ,0.03           ,"m^2/(V*s)"   ,0.0                      ,"Low Field Mobility" )
`MPRnb( ETAMOB         ,2.0            ,""                                      ,"" )
`MPRnb( UP             ,0.0            ,"(um)^LPA"                              ,"" )
`MPRnb( LPA            ,1.0            ,""                                      ,"" )
`MPRnb( UA             ,0.3            ,"(MV/cm)^(-EU)"                         ,"" )
`MPRnb( AUA            ,0.0            ,"(MV/cm)^(-EU)"                         ,"" )
`MPRex( BUA            ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( EU             ,2.5            ,"cm/MV"                                 ,"" )
`MPRnb( AEU            ,0.0            ,"cm/MV"                                 ,"" )
`MPRex( BEU            ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( UC             ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"" )
`MPRnb( AUC            ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"" )
`MPRex( BUC            ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( UD             ,0.0            ,""                                      ,"" )
`MPRnb( AUD            ,0.0            ,""                                      ,"" )
`MPRex( BUD            ,50.0e-9        ,"m"           ,0.0                      ,"" )
`MPRnb( UDB            ,0.0            ,"V^-1"                                  ,"" )
`MPRnb( AUDB           ,0.0            ,"V^-1"                                  ,"" )
`MPRex( BUDB           ,50.0e-9        ,"m"           ,0.0                      ,"" )
`MPRco( DMOBCLAMP      ,0.01           ,"m"           ,0.01        ,inf         ,"Minimum clamp on Dmob" )
`MPRnb( UCS            ,1.0            ,""                                      ,"" )
`MPRnb( UTE            ,0.0            ,""                                      ,"" )
`MPRnb( UTL            ,-1.5e-3        ,""                                      ,"" )
`MPRnb( UA1            ,1.032e-3       ,""                                      ,"" )
`MPRnb( UC1            ,0.0            ,""                                      ,"" )
`MPRnb( UD1            ,0.0            ,""                                      ,"" )
`MPRnb( UCSTE          ,-4.775e-3      ,""                                      ,"" )
`MPRcc( CHARGEWF       ,0.0            ,""            ,-1.0        ,1.0         ,"Average Channel Charge Weighting Factor, +1 :source-side, 0: middle, -1: drain-side" )

// Access Resistance Model
`MPRcz( RDSWMIN        ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 0 S/D extension resistance per unit width at high Vgs" )
`MPRcz( RDSW           ,100.0          ,"ohm*um^WR"                             ,"RDSMOD = 0 zero bias S/D extension resistance per unit width" )
`MPRnb( ARDSW          ,0.0            ,"ohm*um^WR"                             ,"" )
`MPRex( BRDSW          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRcz( RSWMIN         ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 1 source extension resistance per unit width at high Vgs" )
`MPRcz( RSW            ,50.0           ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias source extension resistance per unit width" )
`MPRnb( ARSW           ,0.0            ,"ohm*um^W"                              ,"Pre-exponential coefficient for RSW" )
`MPRex( BRSW           ,100.0e-9       ,"m"           ,0.0                      ,"Exponential coefficient for RSW" )
`MPRcz( RDWMIN         ,RSWMIN         ,"ohm*um^WR"                             ,"RDSMOD = 1 drain extension resistance per unit width at high Vgs" )
`MPRcz( RDW            ,RSW            ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias drain extension resistance per unit width" )
`MPRnb( ARDW           ,ARSW           ,"ohm*um^WR"                             ,"" )
`MPRex( BRDW           ,BRSW           ,"m"           ,0.0                      ,"" )
`MPRnb( PRWG           ,0              ,"V^-1"                                  ,"Gate bias dependence of source/drain extension resistance" )
`MPRnb( PRWB           ,0              ,"V^-1"                                  ,"" )
`MPRnb( WR             ,1.0            ,"V^-1"                                  ,"W dependence parameter of S/D extension resistance" )
`MPRnb( PRT            ,0.001          ,"K^-1"                                  ,"Series Resistance Temperature coefficient" )

// DIBL Model
`MPRnb( PDIBL1         ,1.30           ,""                                      ,"DIBL Output Conductance parameter" )
`MPRnb( PDIBL2         ,2.0e-4         ,""                                      ,"DIBL Output Conductance parameter" )
`MPRnb( DROUT          ,1.06           ,""                                      ,"L dependence of DIBL effect on Rout" )
`MPRnb( PVAG           ,1.0            ,""                                      ,"Vgs dependence on early voltage" )

// Channel Length Modulation Effect
`MPRnb( PCLM           ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter" )
`MPRnb( APCLM          ,0.0            ,""                                      ,"" )
`MPRex( BPCLM          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( PCLMG          ,0.0            ,""                                      ,"Gate bias dependent parameter for channel Length Modulation (CLM)" )
`MPRnb( PCLMCV         ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter for C-V" )

// Geometry dependent Source/Drain Resistance RGEOMOD=0
`MPRcz( RSHS           ,0.0            ,"ohm"                                   ,"Source-side sheet resistance" )
`MPRcz( RSHD           ,RSHS           ,"ohm"                                   ,"Drain-side sheet resistance" )

// Gate Tunneling Current, from gate to channel, Igc
`MPRnb( AIGBINV        ,1.11e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igb in inversion" )
`MPRnb( BIGBINV        ,9.49e-4        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igb in inversion" )
`MPRnb( CIGBINV        ,6.00e-3        ,"V^-1"                                  ,"Parameter for Igb in inversion" )
`MPRnb( EIGBINV        ,1.1            ,"V"                                     ,"Parameter for Igb in inversion" )
`MPRnb( NIGBINV        ,3.0            ,""                                      ,"Parameter for Igb in inversion" )
`MPRnb( AIGBACC        ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igb in accumulation" )
`MPRnb( BIGBACC        ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igb in accumulation" )
`MPRnb( CIGBACC        ,7.5e-2         ,"V^-1"                                  ,"Parameter for Igb in accumulation" )
`MPRnb( NIGBACC        ,1.0            ,""                                      ,"Parameter for Igb in accumulation" )
`MPRnb( AIGC           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igc in inversion" )
`MPRnb( BIGC           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igc in inversion" )
`MPRnb( CIGC           ,0.075          ,"V^-1"                                  ,"Parameter for Igc in inversion" )
`MPRnb( PIGCD          ,1.0            ,""                                      ,"Parameter for Igc partition" )
`MPRnb( DIGC           ,1.0            ,""                                      ,"Parameter for Igc in inversion" )

// Gate Tunneling Current, from gate to S/D, Igs and Igd
`MPRnb( AIGS           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igs, Igd" )
`MPRnb( BIGS           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igs, Igd" )
`MPRnb( CIGS           ,0.075          ,"V^-1"                                  ,"Parameter for Igs, Igd" )
`MPRcz( DLCIGS         ,0              ,""                                      ,"Delta L for Igs model" )
`MPRcz( DLCIGD         ,DLCIGS         ,""                                      ,"Delta L for Igd model" )
`MPRnb( AIGD           ,AIGS           ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igd in inversion" )
`MPRnb( BIGD           ,BIGS           ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igd in inversion" )
`MPRnb( CIGD           ,CIGS           ,"V^-1"                                  ,"Parameter for Igs, Igd" )
`MPRoz( TOXREF         ,1.2e-9         ,"m"                                     ,"Target tox value" )
`MPRnb( NTOX           ,1.0            ,""                                      ,"Exponent for Tox ratio" )
`MPRnb( POXEDGE        ,1.0            ,""                                      ,"Factor for the gate edge Tox" )
`MPRnb( DIGS           ,1.0            ,""                                      ,"Parameter for Igs, Igd" )
`MPRnb( DIGD           ,DIGS           ,""                                      ,"Parameter for Igs, Igd" )

// Gate-induced source/drain leakage
`MPRnb( AGIDL          ,6.055e-12      ,"mho"                                   ,"Pre-exponential coefficient for GIDL" )
`MPRnb( BGIDL          ,0.3e9          ,"V/m"                                   ,"Exponential coefficient for GIDL" )
`MPRnb( EGIDL          ,0.2            ,"V"                                     ,"Band bending parameter for GIDL" )
`MPRnb( PGIDL          ,1.0            ,""                                      ,"Parameter for body-bias effect on GIDL" )
`MPRnb( VBGIDL         ,1.0            ,""                                      ,"Back gate correction factor for GIDL" )
`MPRnb( VBEGIDL        ,0.5            ,"V"                                     ,"Back band bending parameter for GIDL" )
`MPRnb( AGISL          ,AGIDL          ,"mho"                                   ,"Pre-exponential coefficient for GISL" )
`MPRnb( BGISL          ,BGIDL          ,"V/m"                                   ,"Exponential coefficient for GISL" )
`MPRnb( EGISL          ,EGIDL          ,"V"                                     ,"Band bending parameter for GISL" )
`MPRnb( PGISL          ,PGIDL          ,""                                      ,"Parameter for body-bias effect on GISL" )
`MPRnb( VBGISL         ,VBGIDL         ,""                                      ,"Back gate correction factor for GISL" )
`MPRnb( VBEGISL        ,VBEGIDL        ,"V"                                     ,"Back band bending parameter for GISL" )

// Impact Ionization Current
`MPRnb( ALPHA0         ,0.0            ,"m/V"                                   ,"First parameter of Iii" )
`MPRnb( ALPHA1         ,0.0            ,"V^-1"                                  ,"L scaling parameter of Iii" )
`MPRnb( BETA0          ,0.0            ,"V^-1"                                  ,"Vds dependent parameter of Iii" )

// Overlap and Fringing Capacitances
`MPRnb( LOVS           ,0.0            ,"m"                                     ,"Overlap length from FG to S" )
`MPRnb( LOVD           ,LOVS           ,"m"                                     ,"Overlap length from FG to D" )
`MPRcz( CFS            ,0.0            ,"F/m"                                   ,"Outer fringing capacitance at the source side" )
`MPRcz( CFD            ,CFS            ,"F/m"                                   ,"Outer fringing capacitance at the drain side" )
`MPRcz( CGSL           ,0.0            ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped source region" )
`MPRcz( CGDL           ,CGSL           ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped drain region" )
`MPRco( CKAPPAS        ,0.6            ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the source side" )
`MPRco( CKAPPAD        ,CKAPPAS        ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the drain side" )
`MPRnb( CSDBGSW        ,0.0            ,"F/m"                                   ,"Source/drain sidewall fringing capacitance per unit length" )
`MPRnb( PCOVBS0        ,0.0            ,"V"                                     ,"Back-gate dependent overlap capacitance clamping shift voltage for the source side" )
`MPRnb( PCOVBS1        ,0.0            ,""                                      ,"Parameter of back-gate dependent overlap capacitance for the source side" )
`MPRnb( PCOVBD0        ,PCOVBS0        ,"V"                                     ,"Back-gate dependent overlap capacitance clamping shift voltage for the drain side" )
`MPRnb( PCOVBD1        ,PCOVBS1        ,""                                      ,"Parameter of back-gate dependent overlap capacitance for the drain side" )

// Back gate biasing effect, gamma = d_Vth / d_Vbg
// P-well
`MPRnb( KBG0PW         ,1.0            ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( KBG1PW         ,0.0            ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( KBG2PW         ,-1.0           ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( DBGPW          ,0.12           ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( BPFACTORPW     ,0.0            ,""                                      ,"Back-plane (BP) effect, 1 means no BP" )
`MPRnb( VKNEE1PW       ,0.0            ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" )
`MPRco( VKNEE2PW       ,1.0            ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" )

// N-well
`MPRnb( KBG0NW         ,KBG0PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( KBG1NW         ,KBG1PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( KBG2NW         ,KBG2PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( DBGNW          ,DBGPW          ,""                                      ,"Length dependence of body factor" )
`MPRnb( BPFACTORNW     ,BPFACTORPW     ,""                                      ,"Back-plane (BP) effect, 1 means no BP" )
`MPRnb( VKNEE1NW       ,VKNEE1PW       ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" )
`MPRco( VKNEE2NW       ,VKNEE2PW       ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" )

// Flicker Noise
`MPRoc( EF             ,1.0            ,""            ,0.0         ,2.0         ,"Flicker noise frequency exponent" )
`MPRnb( EM             ,4.1e7          ,"V/m"                                   ,"Flicker noise parameter" )
`MPRnb( NOIA           ,6.25e39        ,"(eV^-1)*(s^(1-EF))*(m^-3)"             ,"Flicker noise parameter" )
`MPRnb( NOIB           ,3.125e24       ,"(eV^-1)*(s^(1-EF))*(m^-1)"             ,"Flicker noise parameter" )
`MPRnb( NOIC           ,8.75e7         ,"(eV^-1)*(s^(1-EF))*(m)"                ,"Flicker noise parameter" )
`MPRnb( LINTNOI        ,0.0            ,"m"                                     ,"Lint offset for flicker noise calculation" )

// Thermal Noise
`MPRcz( NTNOI          ,1.0            ,""                                      ,"Thermal noise parameter" )

// Temperature Effects
`MPRco( TNOM           ,27.0           ,"Celsius"     ,-273.15     ,inf         ,"Temperature at which the model is extracted" )
`MPRnb( TBGASUB        ,7.02e-4        ,"eV/K"                                  ,"Bandgap Temperature Coefficient" )
`MPRnb( TBGBSUB        ,1108.0         ,"K"                                     ,"Bandgap Temperature Coefficient" )
`MPRnb( KT1            ,0.0            ,"V"                                     ,"Vth Temperature Coefficient" )
`MPRnb( KT1L           ,0.0            ,"V*m"                                   ,"Vth Temperature L Coefficient" )
`MPRnb( KT2            ,0.0            ,""                                      ,"Vth Temperature Vbg Coefficient" )
`MPRnb( KT2L           ,0.0            ,"m"                                     ,"Vbg Temperature L Coefficient" )
`MPRnb( IIT            ,-0.5           ,""                                      ,"Impact Ionization Temperature Dependence" )
`MPRnb( TGIDL          ,-0.003         ,"K^-1"                                  ,"GIDL Temperature Dependence" )
`MPRnb( TGISL          ,TGIDL          ,"K^-1"                                  ,"GISL Temperature Dependence" )
`MPRnb( IGT            ,2.5            ,""                                      ,"Gate Current Temperature Dependence" )
`MPRnb( TETA0          ,0.0            ,"K^-1"                                  ,"Temperature Dependence for DIBL effects" )

// Self Heating
`MPRcz( RTH0           ,0.01           ,"ohm*m*K/W"                             ,"Thermal resistance" )
`MPRcz( CTH0           ,1.0e-5         ,"W*s/m/K"                               ,"Thermal capacitance" )
`MPRcz( WTH0           ,0.0            ,"m"                                     ,"Width dependence coefficient for Rth and Cth" )


`MPRnb( XGW        ,0.0            ,"m"                                     ,"Distance from gate contact center to device edge" )
`MPRoo( XGL        ,0.0            ,"m"           ,-inf        ,L + XL      ,"Variation in Ldrawn" )
`MPIcc( NGCON      ,1              ,""            ,1           ,2           ,"Number of gate contacts" )
`MPRcz( RSHG       ,0.1            ,"ohm"                                   ,"Gate sheet resistance" )



// For NQSMOD = 1, Set XRCRG1 = 0 to turn off NQS gate resistance
`MPRnb( XRCRG1     ,12.0           ,""                                      ,"Parameter for Rg in NQSMOD = 1" )
`MPRnb( XRCRG2     ,1.0            ,""                                      ,"Parameter for Rg in NQSMOD = 1" )


// GDSMIN added for precision
`MPRcz( GDSMIN         ,1.0e-15        ,"mho"                                   ,"Minimum Conductance" )

// Binning Parameters
`include "bsimimg_binning.include"

// ***************
// *  Variables  *
// ***************

// Common Variables
real Lnew, LeffCV, Leff, Weff, WeffCV, Wnew, L_LLN, W_LWN, LW_LLN_LWN, dLIV, L_WLN, W_WWN, LW_WLN_WWN, dWIV, dLCV, dWCV;
real epssi, cox1, cox1P, cox2, csi, epsratio;
real vfgs, vbgs, vbgd, vbgx, vds, sigvds, vbgxpos;
real vgs_noswap, vds_noswap, vgd_noswap, vbgs_noswap, vbgd_noswap;
real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11;
real qia, qia2, qba, dqi;
real phib, phisub, deltaphi1, deltaphi2;
real Eg, Vtm;
real beta;
real wf, wr;
real Nc;
real qb0;
real dvth_nbody;
real tmp, QMTCENCV_i, Tcen0, Tcen, coxeff;

// Terminal Voltage Conditioning Variables
real vgfb1, vgfb2, vgfb1eff, vgfb2eff;
real vdsx, symmetry_factor;

// Short Channel Effects
real scl, sclm, sclf, teff, temp;
real vbi, nVtm, dvth_dibl, dvth_vtroll, dvth_rsce, dvth_dsc, dvth_all, phist;
real Theta_SCE, Theta_RSCE, Theta_DIBL;

// Lateral Non-uniform Doping Effect
real Mnud;

// Temperature Effects
real Tnom, TRatio, delTemp;
real PhiRef, PhiSD, ni;
real dvth_temp, dvth_temp0;
real BETA0_t, BGIDL_t, BGISL_t, igtemp, ETA0_t;

`bsimimg_sp_global_variables

// Drain Saturation Voltage
real qis, qid, qbs, Dmobs, Vdseff;

real eta_mu, eta_mu_cv, Eeffm, Eeffm_cv, Dmob, Dmob_cv, u0, ueff;
real UA_t, UC_t, UCS_t, UD_t, U0_t, Eeffs, EeffFactor;
real Dr, WeffWRFactor;
real RSourceGeo, RDrainGeo;
real RDSWMIN_i, RDWMIN_i, RSWMIN_i;
real UDB_i;


real Rdrain, Rsource;
real gspr, gdpr;


real rdstemp, Rdsi, Rdss;
real DIBLfactor, PVAGfactor, diffVds, VaDIBL, Vgst2Vtm, Moc, Mclm, MclmCV;
real Dvsat, Vdsat, inv_MEXP;
real VSAT_t, VSATB_t, VSAT1_t, VSATCV_t, MEXP_t, Esat, EsatL, EsatCV, EsatCVL, Esat1, Esat1L;
real K0_t, K0SI_t;
real WVCox, Ta, Tb, Tc;
real Xsat;
real PTWG_t;

// Gate Current
real Vaux_Igbinv, igbinv, igsd_mult, igsd_mult0, igbs, igbd;
real Voxacc, Vaux_Igbacc, vfbzb, igbacc;
real igcs, igcd, igc0, Vdseffx, T1_exp;
real igisl, igidl, vfbsd, vfbsd_bg, igs, igd, vfgs_eff, vfgd_eff;
real Aechvb, Bechvb, Toxratio, Toxratioedge;
real vgbg;

// Impact Ionization current
real Iii;

// IV Variables
integer devsign, welsign;
real ids, ids0, ids0_ov_dqi;

// CV Variables
real qs, qd, qd1, qd2, qfg, qbg;
real IMGTOXP;
real qsi, qdi,qfgi, qbgi;

// Parasitic Capacitance
real qfgs_parasitic, qfgd_parasitic, qfgs_ov, qfgs_of, qfgd_ov, qfgd_of;
real vfgs_ov, vfgd_ov;
real vgd_ov_noswap, vgs_ov_noswap;
real csbox, cdbox, Qsbg, Qdbg;

// Back-gate biasing effects
real kvbg, dvth_vbg, gamma0, vsubdep0, vsubdep, vknee1, vknee2, bpfactor;

// Flicker Noise
real LINTNOI_i;
real litl, Esatnoi, Leffnoi, Leffnoisq, DelClm;
real N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal Noise
real qinv;
real Gtnoi, sid;
real Nt;

// Self Heating
real gth, cth;
real DevTemp;

// Gate resistances

real Grgeltd;

// NQS gate resistance

real gcrg, XRCRG1_i, XRCRG2_i;
real IdsovVds;


// Binning
real Inv_L, Inv_W, Inv_WL;

real RDSW_i, RDW_i, RSW_i;
real PRWG_i, PRWB_i, WR_i;
real PHIG1_i, PHIG2_i;
real NSD_i, NBODY_i;
real CIT_i, CDSC_i, CDSCD_i, CBGCBG_i;
real BPFACTORPW_i, VKNEE1PW_i, VKNEE2PW_i, DBGPW_i, KBG0PW_i, KBG1PW_i, KBG2PW_i;
real BPFACTORNW_i, VKNEE1NW_i, VKNEE2NW_i, DBGNW_i, KBG0NW_i, KBG1NW_i, KBG2NW_i;
real DSC0_i, DSC1_i, ASCL_i, BSCL_i;
real DVT0_i, DVT1_i, PHIN_i;
real ETA0_i, ETA1_i, ETAB_i, DSUB_i, K1RSCE_i, LPE0_i;
real K0_i, K01_i, K0SI_i, K0SI1_i, MEXP_i;
real PTWG_i, PTWGB_i, PTWGB2_i, PTWGT_i;
real U0_i, UA_i, UC_i, UD_i, UCS_i, EU_i, UTL_i, UTE_i, UA1_i, UD1_i, UCSTE_i, ETAMOB_i;
real AT_i, ATB_i, PRT_i, IIT_i, TGIDL_i, TGISL_i, IGT_i;
real PCLM_i, PCLMCV_i, DROUT_i, PDIBL1_i, PDIBL2_i, PVAG_i,  ALPHA0_i, ALPHA1_i, BETA0_i;
real AIGC_i, BIGC_i, CIGC_i, PIGCD_i, DIGC_i;
real AGISL_i, BGISL_i, EGISL_i, PGISL_i, AGIDL_i, BGIDL_i, EGIDL_i, PGIDL_i;
real AIGS_i, BIGS_i, CIGS_i, DIGS_i, AIGD_i, BIGD_i, CIGD_i, DIGD_i;
real VBGIDL_i, VBEGIDL_i, VBGISL_i, VBEGISL_i;
real POXEDGE_i, NTOX_i, LOVS_i, LOVD_i, CFS_i, CFD_i;
real VSAT_i, VSATB_i, VSAT1_i, VSATCV_i;
real KSATIV_i, KSUBIV_i, UP_i;
real AIGBINV_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i;
real AIGBACC_i, BIGBACC_i, CIGBACC_i, NIGBACC_i;

// Threshold operating-point
real A0, k1, qth, qsq1, qsqrt1, qcoth1, Vthop;

// Output variables
`OPP( ID,          "A",                  "Drain current" )
`OPP( IFG,         "A",                  "Front gate current" )
`OPP( IS,          "A",                  "Source current" )
`OPP( III,         "A",                  "Impact ionization current" )
`OPP( IGIDL,       "A",                  "Gate induced drain leakage current" )
`OPP( IGISL,       "A",                  "Gate induced source leakage current" )
`OPP( IDS,         "A",                  "Channel current" )
`OPP( VDSSAT,      "V",                  "Drain-source saturation voltage" )
`OPP( GM,          "A/V",                "Transconductance" )
`OPP( GDS,         "A/V",                "Output conductance" )
`OPP( GMBS,        "A/V",                "Body transconductance" )
`OPP( VFGS,        "V",                  "Front gate-source voltage" )
`OPP( VFGD,        "V",                  "Front gate-drain voltage" )
`OPP( VDS,         "V",                  "Drain-source voltage" )
`OPP( VSBG,        "V",                  "Source-back gate voltage" )
`OPP( VDBG,        "V",                  "Drain-back gate voltage" )
`OPP( QFG,         "C",                  "Total front-gate charge" )
`OPP( QBG,         "C",                  "Total back-gate charge" )
`OPP( QD,          "C",                  "Total drain charge" )
`OPP( QS,          "C",                  "Total source charge" )
`OPP( QFGI,        "C",                  "Intrinsic front gate charge" )
`OPP( QBGI,        "C",                  "Intrinsic back gate charge" )
`OPP( QDI,         "C",                  "Intrinsic drain charge" )
`OPP( QSI,         "C",                  "Intrinsic source charge" )
`OPP( CFGFG,       "F",                  "Total front-gate capacitance" )
`OPP( CFGS,        "F",                  "Total FG-to-S capacitance" )
`OPP( CFGD,        "F",                  "Total FG-to-D capacitance" )
`OPP( CFGBG,       "F",                  "Total FG-to-BG capacitance" )
`OPP( CDFG,        "F",                  "Total D-to-FG capacitance" )
`OPP( CDS,         "F",                  "Total D-to-S capacitance" )
`OPP( CDD,         "F",                  "Total drain capacitance" )
`OPP( CDBG,        "F",                  "Total D-to-BG capacitance" )
`OPP( CSFG,        "F",                  "Total S-to-FG capacitance" )
`OPP( CSS,         "F",                  "Total source capacitance" )
`OPP( CSD,         "F",                  "Total S-to-D capacitance" )
`OPP( CSBG,        "F",                  "Total S-to-BG capacitance" )
`OPP( CBGFG,       "F",                  "Total BG-to-FG capacitance" )
`OPP( CBGS,        "F",                  "Total BG-to-S capacitance" )
`OPP( CBGD,        "F",                  "Total BG-to-D capacitance" )
`OPP( CBGBG,       "F",                  "Total back-gate capacitance" )
`OPP( CFGFGI,      "F",                  "Intrinsic front-gate capacitance" )
`OPP( CFGSI,       "F",                  "Intrinsic FG-to-S capacitance" )
`OPP( CFGDI,       "F",                  "Intrinsic FG-to-D capacitance" )
`OPP( CFGBGI,      "F",                  "Intrinsic FG-to-BG capacitance" )
`OPP( CSFGI,       "F",                  "Intrinsic S-to-FG capacitance" )
`OPP( CSSI,        "F",                  "Intrinsic source capacitance" )
`OPP( CSDI,        "F",                  "Intrinsic S-to-D capacitance" )
`OPP( CSBGI,       "F",                  "Intrinsic S-to-BG capacitance" )
`OPP( CDFGI,       "F",                  "Intrinsic D-to-FG capacitance" )
`OPP( CDSI,        "F",                  "Intrinsic D-to-S capacitance" )
`OPP( CDDI,        "F",                  "Intrinsic drain capacitance" )
`OPP( CDBGI,       "F",                  "Intrinsic D-to-BG capacitance" )
`OPP( CBGFGI,      "F",                  "Intrinsic BG-to-FG capacitance" )
`OPP( CBGSI,       "F",                  "Intrinsic BG-to-S capacitance" )
`OPP( CBGDI,       "F",                  "Intrinsic BG-to-D capacitance" )
`OPP( CBGBGI,      "F",                  "Intrinsic back-gate capacitance" )
`OPP( VTH,         "V",                  "Threshold voltage" )
`OPP( T_TOTAL_K,   "Kelvin",             "Device temperature in Kelvin" )
`OPP( T_TOTAL_C,   "Celsius",            "Device temperature in Celsius" )
`OPP( T_DELTA_SH,  "Kelvin or Celsius",  "Delta temperature by self-heating" )

analog begin

// *************************************
// *  Geometry dependent calculations  *
// *************************************

// Variable initialization

    Rdrain  = 0.0;
    Rsource = 0.0;
    gspr    = 0.0;
    gdpr    = 0.0;
    gcrg    = 0.0;
    Grgeltd = 0.0;

    if ($port_connected(t) == 1) begin
        if (SHMOD == 0 || RTH0 == 0.0) begin
            $strobe("The optional 5th terminal is present but not active because SHMOD = 0 or RTH0 = 0.0");
        end
    end


    if (TYPE == `ntype) begin
        devsign = 1;
    end else begin
        devsign = -1;
    end

    if (WELLTYPE == `ntype) begin
        welsign = 1;
    end else begin
        welsign = -1;
    end

    // Constants
    epssi = EPSRSUB * `EPS0;

    // W calculation for different NFMOD options
    if (NFMOD == 0) begin
        Wnew = W / NF;
    end else begin
        Wnew = W;
    end

    // Leff and Weff for IV and CV
    Lnew       = L + XL;
    Wnew       = Wnew + XW;
    L_LLN      = pow(Lnew, -LLN);
    W_LWN      = pow(Wnew, -LWN);
    LW_LLN_LWN = L_LLN * W_LWN;
    dLIV       = LINT + LL * L_LLN + LW * W_LWN + LWL * LW_LLN_LWN;

    L_WLN      = pow(Lnew, -WLN);
    W_WWN      = pow(Wnew, -WWN);
    LW_WLN_WWN = L_WLN * W_WWN;
    dWIV       = WINT + WL * L_WLN + WW * W_WWN + WWL * LW_WLN_WWN;

    Leff = Lnew - 2.0 * dLIV;

    if (Leff <= 0.0) begin
        $strobe("Fatal: Effective channel length = %e for %M is non-positive", Leff);
        $finish(0);
    end else if (Leff <= 1.0e-9) begin
        $strobe("Warning: Effective channel length = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff);
    end

    Weff = Wnew - 2.0 * dWIV;

    if (Weff <= 0.0) begin
        $strobe("Fatal: Effective channel Width = %e for  %M is non-positive", Weff);
        $finish(0);
    end else if (Weff <= 1.0e-9) begin
        $strobe("Warning: Effective channel width = %e for  %M is <= 1.0e-9. Recommended Weff >= 1e-8", Leff);
    end

    // Leff and Weff for CV
    dLCV   = DLC + LLC * L_LLN + LWC * W_LWN + LWLC * LW_LLN_LWN;
    dWCV   = DWC + WLC * L_WLN + WWC * W_WWN + WWLC * LW_WLN_WWN;
    LeffCV = Lnew - 2.0 * dLCV;

    if (LeffCV <= 0.0) begin
        $strobe("Fatal: Effective channel length for CV = %e for %M is non-positive", LeffCV);
        $finish(0);
    end else if (LeffCV <= 1.0e-9) begin
        $strobe("Warning: Effective channel length for CV = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", LeffCV);
    end

    WeffCV = Wnew - 2.0 * dWCV;

    if (WeffCV <= 0.0) begin
        $strobe("Fatal: Effective channel width for CV = %e for %M is non-positive", WeffCV);
        $finish(0);
    end else if (WeffCV <= 1.0e-9) begin
        $strobe("Warning: Effective channel width for CV = %e for %M is <= 1.0e-9. Recommended Weff >= 1e-8", WeffCV);
    end

    // Binning
    Inv_L  = 1.0e-6 / Leff;
    Inv_W  = 1.0e-6 / Weff;
    Inv_WL = Inv_L * Inv_W;

    // Binning calculations
    RDSW_i   = RDSW + LRDSW * Inv_L + WRDSW * Inv_W + PRDSW * Inv_WL;
    RDW_i    = RDW + LRDW * Inv_L + WRDW * Inv_W + PRDW * Inv_WL;
    RSW_i    = RSW + LRSW * Inv_L + WRSW * Inv_W + PRSW * Inv_WL;
    PRWG_i   = PRWG + LPRWG * Inv_L + WPRWG * Inv_W + PPRWG * Inv_WL;
    PRWB_i   = PRWB + LPRWB * Inv_L + WPRWB * Inv_W + PPRWB * Inv_WL;
    WR_i     = WR + LWR * Inv_L + WWR * Inv_W + PWR * Inv_WL;
    PHIG1_i  = PHIG1 + LPHIG1 * Inv_L + WPHIG1 * Inv_W + PPHIG1 * Inv_WL;
    PHIG2_i  = PHIG2 + LPHIG2 * Inv_L + WPHIG2 * Inv_W + PPHIG2 * Inv_WL;
    NSD_i    = NSD + LNSD * Inv_L + WNSD * Inv_W + PNSD * Inv_WL;
    NBODY_i  = NBODY + LNBODY * Inv_L + WNBODY * Inv_W + PNBODY * Inv_WL;
    CIT_i    = CIT + LCIT * Inv_L + WCIT * Inv_W + PCIT * Inv_WL;
    CDSC_i   = CDSC + LCDSC * Inv_L + WCDSC * Inv_W + PCDSC * Inv_WL;
    CDSCD_i  = CDSCD + LCDSCD * Inv_L + WCDSCD * Inv_W + PCDSCD * Inv_WL;
    CBGCBG_i = CBGCBG + LCBGCBG * Inv_L + WCBGCBG * Inv_W + PCBGCBG * Inv_WL;

    BPFACTORPW_i = BPFACTORPW + LBPFACTORPW * Inv_L + WBPFACTORPW * Inv_W + PBPFACTORPW * Inv_WL;

    if (BPFACTORPW_i < 0.0) begin
        $strobe("Warning: BPFACTORPW_i = %e is negative. Set to 0.0.", BPFACTORPW_i);
        BPFACTORPW_i = 0.0;
    end else if (BPFACTORPW_i > 1.0) begin
        $strobe("Warning: BPFACTORPW_i = %e is larger than 1.0. Set to 1.0.", BPFACTORPW_i);
        BPFACTORPW_i = 1.0;
    end

    VKNEE1PW_i   = VKNEE1PW + LVKNEE1PW * Inv_L + WVKNEE1PW * Inv_W + PVKNEE1PW * Inv_WL;
    VKNEE2PW_i   = VKNEE2PW + LVKNEE2PW * Inv_L + WVKNEE2PW * Inv_W + PVKNEE2PW * Inv_WL;
    DBGPW_i      = DBGPW + LDBGPW * Inv_L + WDBGPW * Inv_W + PDBGPW * Inv_WL;
    KBG0PW_i     = KBG0PW + LKBG0PW * Inv_L + WKBG0PW * Inv_W + PKBG0PW * Inv_WL;
    KBG1PW_i     = KBG1PW + LKBG1PW * Inv_L + WKBG1PW * Inv_W + PKBG1PW * Inv_WL;
    KBG2PW_i     = KBG2PW + LKBG2PW * Inv_L + WKBG2PW * Inv_W + PKBG2PW * Inv_WL;
    BPFACTORNW_i = BPFACTORNW + LBPFACTORNW * Inv_L + WBPFACTORNW * Inv_W + PBPFACTORNW * Inv_WL;

    if (BPFACTORNW_i < 0.0) begin
        $strobe("Warning: BPFACTORNW_i = %e is negative. Set to 0.0.", BPFACTORNW_i);
        BPFACTORNW_i = 0.0;
    end else if (BPFACTORNW_i > 1.0) begin
        $strobe("Warning: BPFACTORNW_i = %e is larger than 1.0. Set to 1.0.", BPFACTORNW_i);
        BPFACTORNW_i = 1.0;
    end

    VKNEE1NW_i = VKNEE1NW + LVKNEE1NW * Inv_L + WVKNEE1NW * Inv_W + PVKNEE1NW * Inv_WL;
    VKNEE2NW_i = VKNEE2NW + LVKNEE2NW * Inv_L + WVKNEE2NW * Inv_W + PVKNEE2NW * Inv_WL;
    DBGNW_i    = DBGNW + LDBGNW * Inv_L + WDBGNW * Inv_W + PDBGNW * Inv_WL;
    KBG0NW_i   = KBG0NW + LKBG0NW * Inv_L + WKBG0NW * Inv_W + PKBG0NW * Inv_WL;
    KBG1NW_i   = KBG1NW + LKBG1NW * Inv_L + WKBG1NW * Inv_W + PKBG1NW * Inv_WL;
    KBG2NW_i   = KBG2NW + LKBG2NW * Inv_L + WKBG2NW * Inv_W + PKBG2NW * Inv_WL;
    DVT0_i     = DVT0 + LDVT0 * Inv_L + WDVT0 * Inv_W + PDVT0 * Inv_WL;
    DVT1_i     = DVT1 + LDVT1 * Inv_L + WDVT1 * Inv_W + PDVT1 * Inv_WL;
    PHIN_i     = PHIN + LPHIN * Inv_L + WPHIN * Inv_W + PPHIN * Inv_WL;
    ETA0_i     = ETA0 + LETA0 * Inv_L + WETA0 * Inv_W + PETA0 * Inv_WL;
    ETA1_i     = ETA1 + LETA1 * Inv_L + WETA1 * Inv_W + PETA1 * Inv_WL;
    ETAB_i     = ETAB + LETAB * Inv_L + WETAB * Inv_W + PETAB * Inv_WL;
    DSUB_i     = DSUB + LDSUB * Inv_L + WDSUB * Inv_W + PDSUB * Inv_WL;
    DSC0_i     = DSC0 + LDSC0 * Inv_L + WDSC0* Inv_W + PDSC0 * Inv_WL;
    DSC1_i     = DSC1 + LDSC1 * Inv_L + WDSC1* Inv_W + PDSC1 * Inv_WL;
    ASCL_i     = ASCL + LASCL * Inv_L + WASCL * Inv_W + PASCL * Inv_WL;
    BSCL_i     = BSCL + LBSCL * Inv_L + WBSCL * Inv_W + PBSCL * Inv_WL;
    K1RSCE_i   = K1RSCE + LK1RSCE * Inv_L + WK1RSCE * Inv_W + PK1RSCE * Inv_WL;
    LPE0_i     = LPE0 + LLPE0 * Inv_L + WLPE0 * Inv_W + PLPE0 * Inv_WL;
    MEXP_i     = MEXP + LMEXP * Inv_L + WMEXP * Inv_W + PMEXP * Inv_WL;
    K0_i       = K0 + LK0 * Inv_L + WK0 * Inv_W + PK0 * Inv_WL;
    K01_i      = K01 + LK01 * Inv_L + WK01 * Inv_W + PK01 * Inv_WL;
    K0SI_i     = K0SI + LK0SI * Inv_L + WK0SI * Inv_W + PK0SI * Inv_WL;
    K0SI1_i    = K0SI1 + LK0SI1 * Inv_L + WK0SI1 * Inv_W + PK0SI1 * Inv_WL;
    PTWG_i     = PTWG + LPTWG * Inv_L + WPTWG * Inv_W + PPTWG * Inv_WL;
    PTWGB_i    = PTWGB + LPTWGB * Inv_L + WPTWGB * Inv_W + PPTWGB * Inv_WL;
    PTWGB2_i   = PTWGB2 + LPTWGB2 * Inv_L + WPTWGB2 * Inv_W + PPTWGB2 * Inv_WL;
    PTWGT_i    = PTWGT + LPTWGT * Inv_L + WPTWGT * Inv_W + PPTWGT * Inv_WL;
    U0_i       = U0 + LU0 * Inv_L + WU0 * Inv_W + PU0 * Inv_WL;
    UA_i       = UA + LUA * Inv_L + WUA * Inv_W + PUA * Inv_WL;
    UC_i       = UC + LUC * Inv_L + WUC * Inv_W + PUC * Inv_WL;
    UD_i       = UD + LUD * Inv_L + WUD * Inv_W + PUD * Inv_WL;
    UCS_i      = UCS + LUCS * Inv_L + WUCS * Inv_W + PUCS * Inv_WL;
    EU_i       = EU + LEU * Inv_L + WEU * Inv_W + PEU * Inv_WL;
    UTL_i      = UTL + LUTL * Inv_L + WUTL * Inv_W + PUTL * Inv_WL;
    UTE_i      = UTE + LUTE * Inv_L + WUTE * Inv_W + PUTE * Inv_WL;
    UA1_i      = UA1 + LUA1 * Inv_L + WUA1 * Inv_W + PUA1 * Inv_WL;
    UD1_i      = UD1 + LUD1 * Inv_L + WUD1 * Inv_W + PUD1 * Inv_WL;
    UCSTE_i    = UCSTE + LUCSTE * Inv_L + WUCSTE * Inv_W + PUCSTE * Inv_WL;
    ETAMOB_i   = ETAMOB + LETAMOB * Inv_L + WETAMOB * Inv_W + PETAMOB * Inv_WL;
    AT_i       = AT + LAT * Inv_L + WAT * Inv_W + PAT * Inv_WL;
    ATB_i      = ATB + LATB * Inv_L + WATB * Inv_W + PATB * Inv_WL;
    PRT_i      = PRT + LPRT * Inv_L + WPRT * Inv_W + PPRT * Inv_WL;
    IIT_i      = IIT + LIIT * Inv_L + WIIT * Inv_W + PIIT * Inv_WL;
    TGIDL_i    = TGIDL + LTGIDL * Inv_L + WTGIDL * Inv_W + PTGIDL * Inv_WL;
    TGISL_i    = TGISL + LTGISL * Inv_L + WTGISL * Inv_W + PTGISL * Inv_WL;
    IGT_i      = IGT + LIGT * Inv_L + WIGT * Inv_W + PIGT * Inv_WL;
    PCLM_i     = PCLM + LPCLM * Inv_L + WPCLM * Inv_W + PPCLM * Inv_WL;
    PCLMCV_i   = PCLMCV + LPCLMCV * Inv_L + WPCLMCV * Inv_W + PPCLMCV * Inv_WL;
    DROUT_i    = DROUT + LDROUT * Inv_L + WDROUT * Inv_W + PDROUT * Inv_WL;
    PDIBL1_i   = PDIBL1 + LPDIBL1 * Inv_L + WPDIBL1 * Inv_W + PPDIBL1 * Inv_WL;
    PDIBL2_i   = PDIBL2 + LPDIBL2 * Inv_L + WPDIBL2 * Inv_W + PPDIBL2 * Inv_WL;
    PVAG_i     = PVAG + LPVAG * Inv_L + WPVAG * Inv_W + PPVAG * Inv_WL;
    ALPHA0_i   = ALPHA0 + LALPHA0 * Inv_L + WALPHA0 * Inv_W + PALPHA0 * Inv_WL;
    ALPHA1_i   = ALPHA1 + LALPHA1 * Inv_L + WALPHA1 * Inv_W + PALPHA1 * Inv_WL;
    BETA0_i    = BETA0 + LBETA0 * Inv_L + WBETA0 * Inv_W + PBETA0 * Inv_WL;
    AIGBINV_i  = AIGBINV + Inv_L * LAIGBINV + Inv_W * WAIGBINV + Inv_WL * PAIGBINV;
    BIGBINV_i  = BIGBINV + Inv_L * LBIGBINV + Inv_W * WBIGBINV + Inv_WL * PBIGBINV;
    CIGBINV_i  = CIGBINV + Inv_L * LCIGBINV + Inv_W * WCIGBINV + Inv_WL * PCIGBINV;
    EIGBINV_i  = EIGBINV + Inv_L * LEIGBINV + Inv_W * WEIGBINV + Inv_WL * PEIGBINV;
    NIGBINV_i  = NIGBINV + Inv_L * LNIGBINV + Inv_W * WNIGBINV + Inv_WL * PNIGBINV;
    AIGBACC_i  = AIGBACC + Inv_L * LAIGBACC + Inv_W * WAIGBACC + Inv_WL * PAIGBACC;
    BIGBACC_i  = BIGBACC + Inv_L * LBIGBACC + Inv_W * WBIGBACC + Inv_WL * PBIGBACC;
    CIGBACC_i  = CIGBACC + Inv_L * LCIGBACC + Inv_W * WCIGBACC + Inv_WL * PCIGBACC;
    NIGBACC_i  = NIGBACC + Inv_L * LNIGBACC + Inv_W * WNIGBACC + Inv_WL * PNIGBACC;
    AIGC_i     = AIGC + LAIGC * Inv_L + WAIGC * Inv_W + PAIGC * Inv_WL;
    BIGC_i     = BIGC + LBIGC * Inv_L + WBIGC * Inv_W + PBIGC * Inv_WL;
    CIGC_i     = CIGC + LCIGC * Inv_L + WCIGC * Inv_W + PCIGC * Inv_WL;
    DIGC_i     = DIGC + LDIGC * Inv_L + WDIGC * Inv_W + PDIGC * Inv_WL;
    PIGCD_i    = PIGCD + LPIGCD * Inv_L + WPIGCD * Inv_W + PPIGCD * Inv_WL;
    PGIDL_i    = PGIDL + LPGIDL * Inv_L + WPGIDL * Inv_W + PPGIDL * Inv_WL;
    AGISL_i    = AGISL + LAGISL * Inv_L + WAGISL * Inv_W + PAGISL * Inv_WL;
    BGISL_i    = BGISL + LBGISL * Inv_L + WBGISL * Inv_W + PBGISL * Inv_WL;
    EGISL_i    = EGISL + LEGISL * Inv_L + WEGISL * Inv_W + PEGISL * Inv_WL;
    PGISL_i    = PGISL + LPGISL * Inv_L + WPGISL * Inv_W + PPGISL * Inv_WL;
    AGIDL_i    = AGIDL + LAGIDL * Inv_L + WAGIDL * Inv_W + PAGIDL * Inv_WL;
    BGIDL_i    = BGIDL + LBGIDL * Inv_L + WBGIDL * Inv_W + PBGIDL * Inv_WL;
    EGIDL_i    = EGIDL + LEGIDL * Inv_L + WEGIDL * Inv_W + PEGIDL * Inv_WL;
    VBGIDL_i   = VBGIDL + LVBGIDL * Inv_L + WVBGIDL * Inv_W + PVBGIDL * Inv_WL;
    VBEGIDL_i  = VBEGIDL + LVBEGIDL * Inv_L + WVBEGIDL * Inv_W + PVBEGIDL * Inv_WL;
    VBGISL_i   = VBGISL + LVBGISL * Inv_L + WVBGISL * Inv_W + PVBGISL * Inv_WL;
    VBEGISL_i  = VBEGISL + LVBEGISL * Inv_L + WVBEGISL * Inv_W + PVBEGISL * Inv_WL;
    AIGS_i     = AIGS + LAIGS * Inv_L + WAIGS * Inv_W + PAIGS * Inv_WL;
    BIGS_i     = BIGS + LBIGS * Inv_L + WBIGS * Inv_W + PBIGS * Inv_WL;
    CIGS_i     = CIGS + LCIGS * Inv_L + WCIGS * Inv_W + PCIGS * Inv_WL;
    DIGS_i     = DIGS + LDIGS * Inv_L + WDIGS * Inv_W + PDIGS * Inv_WL;
    DIGD_i     = DIGD + LDIGD * Inv_L + WDIGD * Inv_W + PDIGD * Inv_WL;
    AIGD_i     = AIGD + LAIGD * Inv_L + WAIGD * Inv_W + PAIGD * Inv_WL;
    BIGD_i     = BIGD + LBIGD * Inv_L + WBIGD * Inv_W + PBIGD * Inv_WL;
    CIGD_i     = CIGD + LCIGD * Inv_L + WCIGD * Inv_W + PCIGD * Inv_WL;
    NTOX_i     = NTOX + LNTOX * Inv_L + WNTOX * Inv_W + PNTOX * Inv_WL;
    POXEDGE_i  = POXEDGE + LPOXEDGE * Inv_L + WPOXEDGE * Inv_W + PPOXEDGE * Inv_WL;
    LOVS_i     = LOVS + LLOVS * Inv_L + WLOVS * Inv_W + PLOVS * Inv_WL;
    LOVD_i     = LOVD + LLOVD * Inv_L + WLOVD * Inv_W + PLOVD * Inv_WL;
    CFS_i      = CFS + LCFS * Inv_L + WCFS * Inv_W + PCFS * Inv_WL;
    CFD_i      = CFD + LCFD * Inv_L + WCFD * Inv_W + PCFD * Inv_WL;
    VSAT_i     = VSAT + LVSAT * Inv_L + WVSAT * Inv_W + PVSAT * Inv_WL;
    VSATB_i    = VSATB + LVSATB * Inv_L + WVSATB * Inv_W + PVSATB * Inv_WL;
    VSAT1_i    = VSAT1 + LVSAT1 * Inv_L + WVSAT1 * Inv_W + PVSAT1 * Inv_WL;
    VSATCV_i   = VSATCV + LVSATCV * Inv_L + WVSATCV * Inv_W + PVSATCV * Inv_WL;
    KSATIV_i   = KSATIV + LKSATIV * Inv_L + WKSATIV * Inv_W + PKSATIV * Inv_WL;
    KSUBIV_i   = KSUBIV + LKSUBIV * Inv_L + WKSUBIV * Inv_W + PKSUBIV * Inv_WL;
    UP_i       = UP + LUP * Inv_L + WUP * Inv_W + PUP * Inv_WL;
    QMTCENCV_i = QMTCENCV;


    if (NQSMOD == 1 && XRCRG1 != 0.0) begin
        XRCRG1_i = XRCRG1 + LXRCRG1 * Inv_L + WXRCRG1 * Inv_W + PXRCRG1 * Inv_WL;
        XRCRG2_i = XRCRG2 + LXRCRG2 * Inv_L + WXRCRG2 * Inv_W + PXRCRG2 * Inv_WL;
    end else begin
        XRCRG1_i = 0.0;
        XRCRG2_i = 0.0;
    end


    cox1     = 3.9 * `EPS0 / EOT1;
    cox1P    = 3.9 * `EPS0 / EOT1P;
    cox2     = 3.9 * `EPS0 / EOT2;
    csi      = epssi / TSI;
    epsratio = EPSRSUB / 3.9;

    // Physical Oxide Thickness
    if (!$param_given(EOT1P)) begin
        IMGTOXP = (EOT1 * EPSROX1 / 3.9) - DTOX1;
    end else begin
        IMGTOXP = EOT1P;
    end

    // Geometrical scaling
    if (LPA > 0.0) begin
        U0_i = U0_i * (1.0 - UP_i * pow(Leff, -LPA));
    end else begin
        U0_i = U0_i * (1.0 - UP_i);
    end
    UA_i  = UA_i + AUA * lexp(-Leff / BUA);
    UC_i  = UC_i + AUC * lexp(-Leff / BUC);
    UDB_i = UDB + AUDB * lexp(-Leff / BUDB);
    UD_i  = UD_i + AUD * lexp(-Leff / BUD);
    EU_i  = EU_i + AEU * lexp(-Leff / BEU);


    if (RDSMOD == 1) begin
        RSW_i = RSW_i + ARSW * lexp(-Leff / BRSW);
        RDW_i = RDW_i + ARDW * lexp(-Leff / BRDW);
    end else begin
    RDSW_i = RDSW_i + ARDSW * lexp(-Leff / BRDSW);
    end


    PCLM_i   = PCLM_i + APCLM * lexp(-Leff / BPCLM);
    MEXP_i   = MEXP_i + AMEXP * pow(Leff * 1.0e6, -BMEXP);
    PTWG_i   = PTWG_i + APTWG * lexp(-Leff / BPTWG);
    PTWGB_i  = PTWGB_i + APTWGB * lexp(-Leff / BPTWGB);
    PTWGB2_i = PTWGB2_i + APTWGB2 * lexp(-Leff / BPTWGB2);
    VSAT_i   = VSAT_i + AVSAT * lexp(-Leff / BVSAT);
    VSATB_i  = VSATB_i + AVSATB * lexp(-Leff / BVSATB);
    VSAT1_i  = VSAT1_i + AVSAT1 * lexp(-Leff / BVSAT1);
    VSATCV_i = VSATCV_i + AVSATCV * lexp(-Leff / BVSATCV);

    // ************************
    // *  Parameter Checking  *
    // ************************
    begin: ParameterCheck

        if (U0_i < 0.0) begin
            $strobe("Warning: U0_i = %e is negative, setting it to default value", U0_i);
            U0_i = 0.03;
        end

        if (UA_i < 0.0) begin
            $strobe("Warning: UA_i = %e is negative, setting it to 0.", UA_i);
            UA_i = 0.0;
        end

        if (EU_i < 0.0) begin
            $strobe("Warning: EU_i = %e is negative, setting it to 0.", EU_i);
            EU_i = 0.0;
        end

        if (UD_i < 0.0) begin
            $strobe("Warning: UD_i = %e is negative, setting it to 0.", UD_i);
            UD_i = 0.0;
        end

        if (UCS_i < 0.0) begin
            $strobe("Warning: UCS_i = %e is negative, setting it to 0.", UCS_i);
            UCS_i = 0.0;
        end

        if (VSATB_i < 0.0) begin
            $strobe("Warning: VSATB_i = %e is negative, setting it to 0.", VSATB_i);
            VSATB_i = 0.0;
        end

        RDSWMIN_i = RDSWMIN;

        if (RDSWMIN_i < 0.0) begin
            $strobe("Warning: RDSWMIN = %e is negative. Set to zero", RDSWMIN_i);
            RDSWMIN_i = 0.0;
        end

        if (RDSW_i < 0.0) begin
            $strobe("Warning: RDSW_i = %e is negative. Set to zero", RDSW_i);
            RDSW_i = 0.0;
        end

        RSWMIN_i = RSWMIN;

        if (RSWMIN_i < 0.0) begin
            $strobe("Warning: RSWMIN = %e is negative. Set to zero", RSWMIN_i);
            RSWMIN_i = 0.0;
        end

        if (RSW_i < 0.0) begin
            $strobe("Warning: RSW_i = %e is negative. Set to zero", RSW_i);
            RSW_i = 0.0;
        end

        RDWMIN_i = RDWMIN;

        if (RDWMIN_i < 0.0) begin
            $strobe("Warning: RDWMIN = %e is negative. Set to zero", RDWMIN_i);
            RDWMIN_i = 0.0;
        end

        if (RDW_i < 0.0) begin
            $strobe("Warning: RDW_i = %e is negative. Set to zero", RDW_i);
            RDW_i = 0.0;
        end

        if (PRWG_i < 0.0) begin
            $strobe("Warning: PRWG_i = %e is negative. Set to zero", PRWG_i);
            PRWG_i = 0.0;
        end

        if (PDIBL1_i < 0.0) begin
            $strobe("Warning: PDIBL1_i = %e is negative.", PDIBL1_i);
        end

        if (PDIBL2_i < 0.0) begin
            $strobe("Warning: PDIBL2_i = %e is negative.", PDIBL2_i);
        end

        if (DROUT_i <= 0.0) begin
            $strobe("Warning: DROUT_i = %e is not positive.", DROUT_i);
        end

        if (MEXP_i < 2.0) begin
            $strobe("Warning: MEXP_i = %e < 2.0.  Setting MEXP_i = 2.", MEXP_i);
            MEXP_i = 2.0;
        end
    end

    // Short Channel Effects
    Theta_RSCE = sqrt(1.0 + LPE0_i / Leff) - 1.0;
    teff       = TSI + epsratio * (EOT1 + EOT2);

    // Variable to be used in drain saturation voltage
    inv_MEXP = 1.0 / MEXP_i;

    // Source/drain to substrate parasitic capacitances
    csbox = cox2 * AS;
    cdbox = cox2 * AD;
    T0    = CSDBGSW * lln(1.0 + TSI / EOT2);
    csbox = csbox + T0 * max(PS - W, 0.0);
    cdbox = cdbox + T0 * max(PD - W, 0.0);

    // For better convergence
    csbox = max(csbox, 0.01e-18);
    cdbox = max(cdbox, 0.01e-18);

    // Mobility Degradation
    eta_mu    = 0.5 * ETAMOB_i;
    eta_mu_cv = 0.5;

    if (TYPE != `ntype) begin
        eta_mu    = 1.0 / 3.0 * ETAMOB_i;
        eta_mu_cv = 1.0 / 3.0;
    end

    EeffFactor   = 1.0e-8 / (epsratio * EOT1);
    WeffWRFactor = 1.0 / (pow(Weff * 1.0e6, WR_i) * NF);
    litl         = sqrt(epsratio * EOT1* TSI);

    if (LINTNOI >= Leff / 2.0) begin
        $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative.  Re-setting LINTNOI = 0.", LINTNOI);
        LINTNOI_i = 0.0;
    end else begin
        LINTNOI_i = LINTNOI;
    end

    // Self-heating Model
    if((SHMOD != 0) && (RTH0 > 0.0)) begin
        gth = (WTH0 + Weff * NF) / RTH0;
        cth = CTH0 * (WTH0 + Weff * NF);
    end else begin
        // set gth to some value to prevent a singular G matrix
        gth = 1.0;
        cth = 0.0;
    end

    // Geometry dependent Source/Drain Resistance
    RSourceGeo = RSHS * NRS;
    RDrainGeo  = RSHD * NRD;

    // Clamping of Source/Drain Resistances
    if (RSourceGeo <= 1.0e-3) begin
        RSourceGeo = 1.0e-3;
    end

    if (RDrainGeo <= 1.0e-3) begin
        RDrainGeo = 1.0e-3;
    end

    if (RDSMOD == 1) begin

        if (RSWMIN_i <= 0.0) begin
            RSWMIN_i = 0.0;
        end

        if (RDWMIN_i <= 0.0) begin
            RDWMIN_i = 0.0;
        end

        if (RSW_i <= 0.0) begin
            RSW_i = 0.0;
        end

        if (RDW_i <= 0.0) begin
            RDW_i = 0.0;
        end

    end else begin

        if (RDSWMIN_i <= 0.0) begin
            RDSWMIN_i = 0.0;
        end

        if (RDSW_i <= 0.0) begin
            RDSW_i = 0.0;
        end

    end

    // Tnom
    if (TNOM <= 0.0) begin
        $strobe("Warning: TNOM = %e is not positive. Set to 300.15 K.", TNOM);
        Tnom = `REFTEMP;
    end else begin
        Tnom = TNOM + `P_CELSIUS0;
    end

    // Gate current
    if (TYPE == `ntype) begin
        Aechvb = 4.97232e-7;
    end else begin
        Aechvb = 3.42537e-7;
    end

    if (TYPE == `ntype) begin
        Bechvb = 7.45669e11;
    end else begin
        Bechvb = 1.16645e12;
    end

    T0           = TOXP * TOXP;
    T1           = TOXP * POXEDGE_i;
    T2           = T1 * T1;
    Toxratio     = lexp(NTOX_i * lln(TOXREF / TOXP)) / T0;
    Toxratioedge = lexp(NTOX_i * lln(TOXREF / T1)) / T2;
    igsd_mult0   = Weff * Aechvb * Toxratioedge;

// Gate process resistance

    Grgeltd = RSHG * (XGW + Weff / 3.0 / NGCON) / (NGCON * NF * (Lnew - XGL));

    if (Grgeltd > 0.001) begin
        Grgeltd = 1.0 / Grgeltd;
    end else begin
        Grgeltd = 1.0e3;
        if (RGATEMOD != 0) begin
            $strobe("Warning: (instance %M) The gate conductance reset to 1.0e3 mho.");
        end
    end


    // ****************************************
    // *  Temperature Dependent Calculations  *
    // ****************************************

    if (SHMOD != 0 && RTH0 > 0.0) begin
        DevTemp = $temperature + Temp(rth_branch) + DTEMP;
    end else begin
        DevTemp = $temperature + DTEMP;
    end

    begin: IMGTempDepCalc

        TRatio  = DevTemp / Tnom;
        delTemp = DevTemp - Tnom;

        // Temperature Dependent Physical Quantities
        Vtm    = `KboQ * DevTemp;
        Eg     = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
        T1     = (DevTemp / 300.15) * sqrt(DevTemp / 300.15);
        ni     = NI0SUB * T1 * lexp(BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm));
        Nc     = NC0SUB * T1;
        vbi    = Vtm * lln(NSD_i * NBODY_i / (ni * ni));
        phib   = Vtm * lln(NBODY_i / ni);
        phisub = (0.5 * Eg - hypsmooth(0.5 * Eg - Vtm * lln(NBG / ni), 1.0e-4));

        // Front- and Back-Gate Workfunctions
        if (NBG != 0.0 & !$param_given(PHIG2)) begin
            if (WELLTYPE == `ptype) begin
                PHIG2_i = PHIG2_i - 0.5 * BG0SUB + phisub;
            end else begin
                PHIG2_i = PHIG2_i + 0.5 * BG0SUB - phisub;
            end
        end

        PhiRef    = (TYPE == `ntype) ? EASUB : EASUB + Eg;
        deltaphi1 = devsign * (PHIG1_i - PhiRef);
        deltaphi2 = devsign * (PHIG2_i - PhiRef);

        PhiSD    = EASUB + Eg / 2.0 - devsign * min(Eg / 2.0, Vtm * lln(NSD_i / ni));
        vfbsd    = devsign * (PHIG1_i - PhiSD);
        vfbsd_bg = devsign * (PHIG2_i - PhiSD);

        // Temperature Effects
        U0_t  = U0_i * pow(TRatio, UTE_i) * (1.0 + hypsmooth(0.9 + UTL_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        u0    = U0_t;
        UC_t  = UC_i * hypsmooth(1.0 + UC1 * delTemp - 1.0e-6, 1.0e-3);
        UA_t  = UA_i * hypsmooth(1.0 + UA1_i * delTemp - 1.0e-6, 1.0e-3);
        UD_t  = UD_i * pow(TRatio, UD1_i);
        UCS_t = UCS_i * pow(TRatio, UCSTE_i);

        rdstemp = hypsmooth(1.0 + PRT_i * delTemp - 1.0e-6, 1.0e-3);
        AT_i    = AT_i * (1.0 +  Inv_L * ATL);
        VSAT_t  = VSAT_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));

        if (VSAT_t < 1000) begin
            $strobe("Warning: VSAT(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT_t);
            VSAT_t = 1000;
        end

        VSAT1_t = VSAT1_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));

        if (VSAT1_t < 1000) begin
            $strobe("Warning: VSAT1(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT1_t);
            VSAT1_t = 1000;
        end

        VSATCV_t = VSATCV_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));

        if (VSATCV_t < 1000) begin
            $strobe("Warning: VSATCV(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSATCV_t);
            VSATCV_t = 1000;
        end

        ETA0_t     = ETA0_i * (1.0 + hypmax(TETA0 * delTemp, -0.9, 1.0e-4));
        ATB_i      = ATB_i *(1.0 + Inv_L * ATBL);
        VSATB_t    = VSATB_i * (1.0 + hypsmooth(0.9 - ATB_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        MEXP_t     = hypsmooth(MEXP_i * (1.0 + TMEXP * delTemp) - 2.0, 1.0e-3) + 2.0;
        K0_t       = K0_i + K01_i * delTemp;
        K0SI_t     = K0SI_i + hypmax(K0SI1_i * delTemp, -K0SI_i, 1.0e-6);
        PTWG_t     = PTWG_i * hypsmooth(1.0 - PTWGT_i * delTemp - 1.0e-6, 1.0e-3);
        dvth_temp0 = (KT1 + KT1L / Leff) * (TRatio - 1.0);
        BETA0_t    = BETA0_i * pow(TRatio, IIT_i);
        BGIDL_t    = BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0e-6, 1.0e-3);
        BGISL_t    = BGISL_i * hypsmooth(1.0 + TGISL_i * delTemp - 1.0e-6, 1.0e-3);
        igtemp     = lexp(IGT_i * lln(TRatio));
        igsd_mult  = igsd_mult0 * igtemp;
    end

    // *********************************
    // *  Bias Dependent Calculations  *
    // *********************************

    // Load Terminal Voltages
    vgs_noswap  = devsign * V(gi, si);
    vds_noswap  = devsign * V(di, si);
    vgd_noswap  = devsign * V(gi, di);
    vbgs_noswap = devsign * V(bg, si);
    vbgd_noswap = devsign * V(bg, di);
    vgbg        = devsign * V(gi, bg);

    // Source-drain Interchange
    sigvds = 1.0;

    if (vds_noswap < 0.0) begin
        sigvds = -1.0;
        vfgs   = vgd_noswap;
        vds    = -vds_noswap;
        vbgs   = vbgd_noswap;
        vbgd   = vbgs_noswap;
    end else begin
        vfgs   = vgs_noswap;
        vds    = vds_noswap;
        vbgs   = vbgs_noswap;
        vbgd   = vbgd_noswap;
    end


    vgd_ov_noswap = devsign * V(ge, di);
    vgs_ov_noswap = devsign * V(ge, si);


    // Terminal Voltage Conditioning
    vdsx  = sqrt(vds * vds + 0.0004) - 0.02;
    symmetry_factor = 0.5 * (vdsx - vds);
    vbgx  = vbgs + symmetry_factor;
    vgfb1 = vfgs - deltaphi1;
    vgfb2 = vbgs - deltaphi2;

    // Back-gate bias dependence
    sclf = sqrt(epsratio * TSI * EOT1);
    sclm = sqrt(TSI * (epsratio * EOT1 + 0.375 * TSI));
    T0   = (vgfb1 * (EOT2 * epsratio) + vgfb2 * (EOT1 * epsratio + TSI)) / teff + symmetry_factor;
    T1   = atan(ASCL_i + BSCL_i * T0) / `M_PI + 0.5;
    scl  = sclm + T1 * (sclf - sclm);

    tmp = DVT1_i * Leff / scl + 1.0e-6;

    if (tmp < 40.0) begin
        Theta_SCE = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_SCE = lexp(-tmp);
    end

    tmp = DSUB_i * Leff / scl + 1.0e-6;

    if (tmp < 40.0) begin
        Theta_DIBL = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_DIBL = lexp(-tmp);
    end

    tmp = DROUT_i * Leff / scl + 1.0e-6;

    if (tmp < 40.0) begin
        DIBLfactor = 0.5 * PDIBL1_i / (cosh(tmp) - 1.0) +PDIBL2_i;
    end else begin
        DIBLfactor = PDIBL1_i * lexp(-tmp) + PDIBL2_i;
    end

    // Back gate biasing effect
    if (WELLTYPE == `ptype) begin
        temp = DBGPW_i * Leff / scl;

        if (temp > 40.0) begin
            T0 = lexp(temp) / 2.0;
        end else begin
            T0 = cosh(temp) - 1.0;
        end

        T1       = KBG0PW_i - 0.5 * KBG1PW_i / T0;
        T2       = KBG2PW_i;
        vknee1   = VKNEE1PW_i;
        vknee2   = VKNEE2PW_i;
        bpfactor = BPFACTORPW_i;
    end else begin
        temp = DBGNW_i * Leff / scl;

        if (temp > 40.0) begin
            T0 = lexp(temp) / 2.0;
        end else begin
            T0 = cosh(temp) - 1.0;
        end

        T1       = KBG0NW_i - 0.5 * KBG1NW_i / T0;
        T2       = KBG2NW_i;
        vknee1   = VKNEE1NW_i;
        vknee2   = VKNEE2NW_i;
        bpfactor = BPFACTORNW_i;
    end

    T0   = T1 - T2;
    kvbg = T2 + 0.5 * (T0 + sqrt(T0 * T0 + 0.0001));

    // Back-gate (substrate) depletion effect
    vsubdep0 = `q * NBG * epssi / (2.0 * cox2 * cox2);

    if (NBG != 0.0) begin
        T0 = sqrt(1.0 + hypsmooth(welsign * (devsign * vbgx - vknee1), 1.0e-2) / vsubdep0) - 1.0;
    end else begin
        T0 = 0.0;
    end

    vsubdep  = vsubdep0 * T0 * T0;
    vsubdep  = -hypmax(-vsubdep, -vknee2, 1.0e-2);
    vgfb2eff = `VGFB2N - symmetry_factor;
    gamma0   = -cox2 * csi / ((cox2 + csi) * cox1);
    dvth_vbg = gamma0 * kvbg * (vgfb2 - (devsign * welsign * bpfactor * vsubdep) - vgfb2eff);

    // SCE, DIBL, RSCE, and SS degradation effects Ref: BSIM4 Model
    vbgxpos     = hypsmooth(vbgx, 1.0e-3);
    phist       = 0.4 + phib + PHIN_i;
    if (phist <0) begin
        dvth_rsce = 0;
    end else begin
        dvth_rsce   = K1RSCE_i * Theta_RSCE * sqrt(phist);
    end
    dvth_vtroll = -DVT0_i * Theta_SCE * (vbi - phist);
    dvth_dibl   = -(ETA0_t + ETAB_i * vbgx) * Theta_DIBL * (vdsx + ETA1_i * sqrt(vdsx));
    dvth_dsc    = -DSC0_i / (Leff + DSC1_i) * vdsx;
    T1          = csi * cox2 / (csi + cox2);
    T2          = (CDSCD_i + CBGCBGD * vbgxpos) * vdsx;
    T3          = CBGCBG0 * vbgx + CBGCBG0P * vbgx * vbgx + Theta_SCE * (CDSC_i + CBGCBG_i * vbgx + CBGCBGP * vbgx * vbgx + T2);
    nVtm        = Vtm * (cox1 + T1 + CIT_i + T3) / (cox1 + T1);

    // Threshold voltage shift because of body doping; Consistent with Noguchi et al., EDL 2001
    dvth_nbody  = `q * NBODY_i * TSI / cox1 * (1.0 - 0.5 * TSI / (TSI + epsratio * EOT2));
    T0          = (KT2 + KT2L / Leff) * vbgx;
    dvth_temp   = dvth_temp0 + T0 * (TRatio - 1.0);
    dvth_all    = dvth_vtroll + dvth_dibl + dvth_rsce + dvth_dsc + dvth_nbody + dvth_temp + dvth_vbg;
    vgfb1eff    = vgfb1 - dvth_all + DELVTRAND;

    // Threshold voltage operating point
    A0     = (2.0 * `q * ni * TSI * TSI) / (epssi * Vtm);
    k1     = cox1 / csi;
    qth    = 1.0;
    qsq1   = k1 * k1 * qth * qth - A0 * lexp(phib * 2.0);
    qsqrt1 = sqrt(qsq1);
    qcoth1 = (1.0 - qsqrt1 / 8.0) / (0.5 - qsqrt1 / 24.0);
    T1     = (1.0 + lln(k1 * k1 * qth * qth + k1 * qth * qcoth1) - lln(A0)) * Vtm;
    Vthop  = devsign * (T1 + dvth_all + DELVTRAND);

    // *******************************************
    // *  Common Surface Potential Calculations  *
    // *******************************************

    `bsimimg_sp_common(vgfb2eff, nVtm, Nc, epssi, epsratio, EOT1, EOT2, TSI, spA)

    // *********************************************************
    // *  Source End Surface Potential and Charge Calculation  *
    // *********************************************************

    `bsimimg_sp(sp_source, vgfb1eff, vgfb2eff, 0.0, EOT1, EOT2, TSI, nVtm, spA, spc, spb, kappa, invnVtm, gsp, b2sp, epsratio, ebs, phifs, phibs, qtots, CHARGEMOD)

    // ******************************
    // *  Drain Saturation Voltage  *
    // ******************************

    qis   = qtots / cox1;
    qbs   = `q * NBODY_i * TSI / cox1;
    T2    = eta_mu * qis + qbs + ebs * epssi / cox1;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffs = EeffFactor * T3;

    begin: source_mobility_calc
        real T2, T3;
        qb0   = 1.0e-2 / cox1;
        T2    = pow(0.5 * (1.0 + abs(qis / qb0)), UCS_t);
        T3    = (UA_t + vbgs * UC_t) * pow(abs(Eeffs), EU_i) + UD_t / T2;
        Dmobs = 1.0 + T3;
        Dmobs = smoothminx(Dmobs, 1.0, DMOBCLAMP);
        Dmobs = Dmobs / U0MULT;
    end

    if (RDSMOD == 1) begin
        Rdss = 0.0;
    end else if (RDSMOD == 0) begin
        T4   = 1.0 + PRWG_i * qis;
        T1   = 1.0 / T4;
        T0   = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NF * rdstemp;
    end else begin
        T4   = 1.0 + PRWG_i * qis;
        T1   = 1.0 / T4;
        T0   = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RSourceGeo + RDrainGeo + RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NF * rdstemp;
    end

    Esat  = 2.0 * VSAT_t / u0 * Dmobs;
    EsatL = Esat * Leff;
    T6    = KSATIV_i * (qis + 2.0 * Vtm * KSUBIV_i);

    if (Rdss == 0.0) begin
        Vdsat = EsatL * T6 / (EsatL + T6);
    end else begin
        WVCox = Weff * VSAT_t * cox1;
        T0    = WVCox * Rdss;
        Ta    = 2.0 * T0;
        Tb    = T6 + EsatL + 3.0 * T6 * T0;
        Tc    = T6 * (EsatL + 2.0 * T6 * T0);
        Vdsat = (Tb - sqrt(Tb * Tb - 2.0 * Ta * Tc)) / Ta;
    end

    Vdsat  = hypsmooth(Vdsat - 1.0e-3, 1.0e-5) + 1.0e-3;
    T7     = pow(vds / Vdsat, MEXP_t);
    T8     = pow(1.0 + T7, inv_MEXP);
    Vdseff = vds / T8;

    if (Vdseff > vds) begin
        Vdseff = vds;
    end

    // ********************************************************
    // *  Drain End Surface Potential and Charge Calculation  *
    // ********************************************************

    `bsimimg_sp(sp_drain, vgfb1eff, vgfb2eff, Vdseff, EOT1, EOT2, TSI, nVtm, spA, spc, spb, kappa, invnVtm, gsp, b2sp, epsratio, ebd, phifd, phibd, qtotd, CHARGEMOD)

    // **********************************
    // *  Average Potential and Charge  *
    // **********************************

    qid = qtotd / cox1;
    qia = 0.5 * (qis + qid);
    dqi = qis - qid;
    qba = `q * NBODY_i * TSI / cox1;
    eba = 0.5 * (ebs + ebd);

    T0 = pow(Vdseff, 2.0) / 6.25e-4;

    if (CHARGEWF != 0.0) begin
        qia2 = 0.5 * (qis + qid) + CHARGEWF * (1.0 - lexp(-T0)) * 0.5 * dqi;
    end else begin
        qia2 = 0.5 * (qis + qid);
    end

    // Multiplication factor for I-V
    beta = u0 * cox1 * Weff / Leff;

    // **************************
    // *  Mobility Degradation  *
    // **************************

    // Eeff is clamped to 0 to avoid numerical problems
    // Average electric field in the inversion layer (in the unit of MV/cm)
    T2    = eta_mu * qia2 + qba + eba * epssi / cox1;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffm = EeffFactor * T3;

    begin: average_mobility_calc
        real T2, T3;
        T2   = pow(0.5 * (1.0 + abs(qia / qb0)), UCS_t);
        T3   = (UA_t + vbgx * UC_t) * pow(abs(Eeffm), EU_i) + (UD_t + vbgx * UDB_i) / T2;
        Dmob = 1.0 + T3;
        Dmob = smoothminx(Dmob, 1.0, DMOBCLAMP);
        Dmob = Dmob / U0MULT;
        ueff = u0 / Dmob;
    end

    // Mobility Degradation for C-V
    Eeffm_cv = EeffFactor * (qba + eta_mu_cv * qia);
    T3       = UA_t * pow(abs(Eeffm_cv), EU_i);
    Dmob_cv  = 1.0 + T3;
    Dmob_cv  = smoothminx(Dmob_cv, 1.0, DMOBCLAMP);
    Dmob_cv  = Dmob_cv / U0MULT;

    // Velocity Saturation
    Esat1  = 2.0 * VSAT1_t / ueff;
    Esat1L = Esat1 * Leff;

    T0     = 0.8 + VSATB_t * vbgx;
    Xsat   = 0.2 + 0.5 * (T0 + sqrt(T0 * T0 + 0.01));
    T0     = dqi / Esat1L * Xsat;
    Dvsat  = (1.0 + sqrt(DELTAVSAT + T0 * T0)) / (1.0 + sqrt(DELTAVSAT));
    Dvsat  = Dvsat + 0.5 * (PTWG_t - PTWGB_i * vbgxpos - PTWGB2_i * vbgx) * qia * dqi * dqi;
    Dvsat  = smoothminx(Dvsat, 1.0, DVSATCLAMP);

    EsatCV  = 2.0 * VSATCV_t * Dmob_cv / u0;
    EsatCVL = EsatCV * LeffCV;

    // Output Conductance
    if (PVAG_i > 0.0) begin
        PVAGfactor = 1.0 + PVAG_i * qia / EsatL;
    end else begin
        PVAGfactor = 1.0 / (1.0 - PVAG_i * qia / EsatL);
    end

    diffVds  = vds - Vdseff;
    Vgst2Vtm = qia + 2.0 * Vtm;

    if (DIBLfactor > 0.0) begin
        T1     = Vgst2Vtm;
        T3     = T1 / (Vdsat + T1);
        VaDIBL = T1 / DIBLfactor * T3 * PVAGfactor;
        Moc    = 1.0 + diffVds / VaDIBL;
    end else begin
        Moc = 1.0;
    end

    if (PCLM_i > 0.0) begin

        if (PCLMG < 0.0) begin
            T1 = 1.0 / (1.0 / PCLM_i - PCLMG * qia);
        end else begin
            T1 = PCLM_i * (1.0 + PCLMG * qia);
        end

        Mclm = 1.0 + T1 * lln(1.0 + (vds - Vdseff) / T1 / (Vdsat + EsatL));

    end else begin
        Mclm = 1.0;
    end

    Moc = Moc * Mclm;

    // Channel Length Modulation factor for C-V
    if (PCLMCV_i > 0.0) begin
        MclmCV = 1.0 + PCLMCV_i * lln(1.0 + (vds - Vdseff) / PCLMCV_i / (Vdsat + EsatCVL));
    end else begin
        MclmCV = 1.0;
    end

    // Lateral Non-uniform doping effect (IV-CV Vth shift) factor
    if (K0_t != 0.0) begin
        T1   = K0_t / (K0SI_t * qia + 2.0 * nVtm);
        Mnud = lexp(-T1);
    end else begin
        Mnud = 1.0;
    end

    // I-V Equation
    ids0        = 0.5 * (qis + qid) * (phifd - phifs) + (qis - qid) * Vtm;
    ids0_ov_dqi = 0.5 * (qis + qid) + Vtm;

    // S/D series resistance
    begin: rdsblock
        real T1, T4;
        real vgs_eff, vgd_eff;
        real T2, T3;
        // RDSMOD = 1: Both bias-dependent and independent of S/D resistances are external
        if (RDSMOD == 1) begin
            Rdsi    = 0.0;
            Dr      = 1.0;
            T2      = vgs_noswap - vfbsd;
            T3      = sqrt(T2 * T2 + 1.0e-4);
            vgs_eff = 0.5 * (T2 + T3);
            T4      = 1.0 + PRWG_i * vgs_eff;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * vbgs_noswap * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rsource = rdstemp * (RSourceGeo + (RSWMIN_i + RSW_i * T0) * WeffWRFactor);
            T2      = vgd_noswap - vfbsd;
            T3      = sqrt(T2 * T2 + 1.0e-4);
            vgd_eff = 0.5 * (T2 + T3);
            T4      = 1.0 + PRWG_i * vgd_eff;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * vbgd_noswap * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdrain  = rdstemp * (RDrainGeo + (RDWMIN_i + RDW_i * T0) * WeffWRFactor);
        end else begin
        // RDSMOD = 0: Bias-dependent S/D resistances are internal and bias-independent S/D resistances are external
            T4      = 1.0 + PRWG_i * qia;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * (vbgd + vbgs) * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdsi    = rdstemp * (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor;
            Dr      = 1.0 + NF * beta * ids0_ov_dqi / (Dmob * Dvsat) * Rdsi;
            Rdrain  = RDrainGeo;
            Rsource = RSourceGeo;
        // RDSMOD = 2: Both bias-dependent and independent of S/D resistances are internal
        if (RDSMOD == 2) begin
            T4      = 1.0 + PRWG_i * qia;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * (vbgd + vbgs) * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdsi    = rdstemp * (RSourceGeo + RDrainGeo + RDSWMIN_i + RDSW_i * T0) * WeffWRFactor;
            Dr      = 1.0 + NF * beta * ids0_ov_dqi / (Dmob * Dvsat) * Rdsi;
            Rdrain  = 0.0;
            Rsource = 0.0;
        end
    end

    end

    ids = beta * ids0 * Moc * Mnud / (Dmob * Dvsat * Dr);
    ids = NF * ids;

    // C-V Equation
    T0  = cox2 / cox1 * csi / (cox2 + csi);
    T1  = (1.0 + T0) / 2.0;
    T2  = vgfb1eff + T0 * vgfb2eff + Vtm * (1.0 + T0);
    T3  = phifs + phifd;
    T4  = phifd - phifs;
    T5  = vgfb1eff - T3 / 2.0;
    T6  = T1 * T4 / (6.0 * (T2 - T1 * T3));
    qfg = T5 + T6 * T4 + dvth_vbg;
    qd1 = T5 / 2.0 + T6 * T4 / 10.0 - (T6 / T1) / 10.0 * (5.0 * T2 - 4.0 * T1 * phifd - 6.0 * T1 * phifs) * (T2 - 2.0 * T1 * phifd) / (T2 - T1 * T3);

    T0 = cox1 / cox2 * csi / (cox1 + csi);
    T1 = (1.0 + T0) / 2.0;
    T2 = vgfb2eff + T0 * vgfb1eff + Vtm * (1.0 + T0);
    T3 = phibs + phibd;
    T4 = phibd - phibs;
    T5 = vgfb2eff - T3 / 2.0;
    T6 = T1 * T4 / (6.0 * (T2 - T1 * T3));

    // Note: q's are normalized to cox1, not cox2.
    qbg = cox2 / cox1 * (T5 + T6 * T4 - dvth_vbg * (cox1 / cox2));
    qd2 = cox2 / cox1 * (T5 / 2.0 + T6 * T4 / 10.0 - (T6 / T1) / 10.0 * (5.0 * T2 - 4.0 * T1 * phibd - 6.0 * T1 * phibs) * (T2 - 2.0 * T1 * phibd) / (T2 - T1 * T3));
    qd  = qd1 + qd2;

    // Quantum Mechanical Effects
    if (QMTCENCV_i > 0.0) begin
        T4     = (qia + ETAQM * qba) / QM0;
        T5     = 1.0 + pow(T4, PQM);
        Tcen0  = TSI;
        Tcen   = Tcen0 / T5;
        coxeff = 3.9 * `EPS0 / (IMGTOXP * 3.9 / EPSROX1 + Tcen * QMTCENCV_i / epsratio);
    end else begin
        coxeff = cox1P;
    end

    T0  = coxeff * WeffCV * LeffCV / MclmCV;
    qfg = qfg * T0;
    qbg = qbg * T0;
    qd  = -qd * T0;
    qs  = -qfg - qbg - qd;

    // Parasitic Capacitances
    // Note: the back gate capacitance is assumed to be negligible due to the thick oxide.
    qfgs_ov = WeffCV * LOVS_i * cox1 * V(ge, si);
    qfgd_ov = WeffCV * LOVD_i * cox1 * V(ge, di);

    // Bias-dependent overlap capacitances
    T0      = vgs_ov_noswap - vfbsd + `DELTA_1 + (vbgs_noswap - vfbsd_bg - PCOVBS0) * PCOVBS1;
    vfgs_ov = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    qfgs_ov = qfgs_ov + devsign * WeffCV * CGSL * (vgs_ov_noswap - vfbsd - vfgs_ov - 0.5 * CKAPPAS * (sqrt(1.0 - 4.0 * vfgs_ov / CKAPPAS)- 1.0));
    T0      = vgd_ov_noswap - vfbsd + `DELTA_1 + (vbgd_noswap - vfbsd_bg - PCOVBD0) * PCOVBD1;
    vfgd_ov = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    qfgd_ov = qfgd_ov + devsign * WeffCV * CGDL * (vgd_ov_noswap - vfbsd - vfgd_ov - 0.5 * CKAPPAD * (sqrt(1.0 - 4.0 * vfgd_ov / CKAPPAD)- 1.0));

    // Outer fringe capacitances
    qfgs_of = WeffCV * CFS_i * V(ge, si);
    qfgd_of = WeffCV * CFD_i * V(ge, di);

    qfgs_parasitic = qfgs_ov + qfgs_of;
    qfgd_parasitic = qfgd_ov + qfgd_of;

    Qsbg = devsign * csbox * V(si, bg);
    Qdbg = devsign * cdbox * V(di, bg);

    // Impact Ionization Current
    T0 = (ALPHA0_i + ALPHA1_i * Leff) / Leff;

    if (T0 <= 0.0 || BETA0_t <= 0.0) begin
        Iii = 0.0;
    end else if (diffVds > BETA0_t / `EXPL_THRESHOLD) begin
        T1  = -BETA0_t / diffVds;
        Iii = T0 * diffVds * ids * lexp(T1);
    end else begin
        Iii = T0 * diffVds * ids * `MIN_EXPL;
    end

    // Gate Current
    igbinv = 0.0;
    igbacc = 0.0;
    igcs   = 0.0;
    igcd   = 0.0;
    igs    = 0.0;
    igd    = 0.0;

    // Igb
    if (IGBMOD != 0) begin
        // Igbinv
        T1          = (qia - EIGBINV_i) / NIGBINV_i / Vtm;
        Vaux_Igbinv = NIGBINV_i * Vtm * lln(1.0 + lexp(T1));
        T2          = AIGBINV_i - BIGBINV_i * qia;
        T3          = 1.0 + CIGBINV_i * qia;
        T4          = -9.82222e11 * TOXP * T2 * T3;
        T5          = lexp(T4);
        T6          = 3.75956e-7;
        igbinv      = Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbinv * T5;
        igbinv      = igbinv * igtemp;

        // Igbacc
        vfbzb       = deltaphi1 - Eg / 2.0 - phib;
        T0          = vfbzb - vgbg;
        T1          = T0 / NIGBACC_i / Vtm;
        Vaux_Igbacc = NIGBACC_i * Vtm * lln(1.0 + lexp(T1));

        if (vfbzb <= 0.0) begin
            Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) - 0.08 * vfbzb));
        end else begin
            Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) + 0.08 * vfbzb));
        end

        T2     = AIGBACC_i - BIGBACC_i * Voxacc;
        T3     = 1.0 + CIGBACC_i * Voxacc;
        T4     = -7.45669e11 * TOXP * T2 * T3;
        T5     = lexp(T4);
        T6     = 4.97232e-7;
        igbacc = Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbacc * T5;
        igbacc = igbacc * igtemp;
    end

    // Gate to Body Tunneling current empirical partition
    T0   = tanh(0.6 * vds_noswap / Vtm);
    wf   = 0.5 + 0.5 * T0;
    wr   = 1.0 - wf;
    igbs = (igbinv + igbacc) * wf;
    igbd = (igbinv + igbacc) * wr;

    if (IGCMOD != 0) begin
        // Igcinv
        T1   = AIGC_i - BIGC_i * (vgfb1 - DIGC_i * phifs);
        T2   = 1.0 + CIGC_i * (vgfb1 - DIGC_i * phifs);
        T3   = -Bechvb * TOXP * T1 * T2;
        T4   = qia * lexp(T3);
        T5   = vgbg + 0.5 * vdsx + 0.5 * (vbgs_noswap + vbgd_noswap);
        igc0 = Weff * Leff * Aechvb * Toxratio * T4 * T5 * igtemp;

        // Gate-current partitioning
        Vdseffx = sqrt(Vdseff * Vdseff + 0.01) - 0.1;
        T1      = PIGCD_i * Vdseffx;
        T1_exp  = lexp(-T1);
        T3      = T1 + T1_exp - 1.0 + 1.0e-4;
        T4      = 1.0 - (T1 + 1.0) * T1_exp + 1.0e-4;
        T5      = T1 * T1 + 2.0e-4;
        igcd    = igc0 * T4 / T5;
        igcs    = igc0 * T3 / T5;

        // Igs
        T0       = vgs_noswap - vfbsd + DIGS_i * gamma0 * (vbgs - vfbsd_bg);
        vfgs_eff = sqrt(T0 * T0 + 1.0e-4);
        T1       = AIGS_i - BIGS_i * vfgs_eff;
        T2       = 1.0 + CIGS_i * vfgs_eff;
        T3       = -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4       = lexp(T3);

        if (sigvds > 0.0) begin
            igs = igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end else begin
            igd = igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end

        // Igd
        T0       = vgd_noswap - vfbsd + DIGD_i * gamma0 * (vbgs - vfbsd_bg);
        vfgd_eff = sqrt(T0 * T0 + 1.0e-4);
        T1       = AIGD_i - BIGD_i * vfgd_eff;
        T2       = 1.0 + CIGD_i * vfgd_eff;
        T3       = -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4       = lexp(T3);

        if (sigvds > 0.0) begin
            igd = igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end else begin
            igs = igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end
    end

    // GIDL/GISL Currents
    igisl = 0.0;
    igidl = 0.0;

    if (GIDLMOD != 0) begin

        T0 = epsratio * EOT1;

        // GIDL
        if (AGIDL_i <= 0.0 || BGIDL_t <= 0.0) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgd_noswap - EGIDL_i + vfbsd + VBGIDL_i * gamma0 * (vbgs - vfbsd_bg - VBEGIDL_i)) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGIDL_t / (T1 + 1.0e-3);
            T3 = lexp(PGIDL_i * lln(T1));
            T6 = vds_noswap * AGIDL_i * Weff * T3 * lexp(-T2);
        end

        if (sigvds > 0.0) begin
            igidl = T6;
        end else begin
            igisl = T6;
        end

        // GISL
        if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgs_noswap - EGISL_i + vfbsd + VBGISL_i * gamma0 * (vbgs - vfbsd_bg - VBEGISL_i)) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGISL_t / (T1 + 1.0e-3);
            T3 = lexp(PGISL_i * lln(T1));
            T6 = -vds_noswap * AGISL_i * Weff * T3 * lexp(-T2);
        end

        if (sigvds > 0.0) begin
            igisl = T6;
        end else begin
            igidl = T6;
        end
    end

    // Thermal noise and flicker noise
    Esatnoi = 2.0 * VSAT_t / ueff;

    // Flicker Noise, Ref: BSIM4 by K. K. Hung et al. TED 1990
    if (NOIA > 0.0 || NOIB > 0.0 || NOIC > 0.0) begin

        Leffnoi   = Leff - 2.0 * LINTNOI_i;
        Leffnoisq = Leffnoi * Leffnoi;

        if (EM <= 0.0) begin
            DelClm = 0.0;
        end else begin
            T0     = (diffVds / litl + EM) / Esatnoi;
            DelClm = litl * lln(T0);

            if (DelClm < 0.0) begin
                DelClm = 0.0;
            end
        end

        T1 = `q * `q * `q * Vtm * abs(ids) * ueff;
        T2 = 1.0e10 * coxeff * Leffnoisq;
        N0 = coxeff * qis / `q;
        Nl = coxeff * qid / `q;

        Nstar = Vtm / `q * (coxeff + CIT_i);
        T3    = NOIA * lln((N0 + Nstar) / (Nl + Nstar));
        T4    = NOIB * (N0 - Nl);
        T5    = 0.5 * NOIC * (N0 * N0 - Nl * Nl);
        T6    = `q * Vtm * ids * ids;

        T7  = 1.0e10 * Leffnoisq * Weff * NF;
        T8  = NOIA + NOIB * Nl + NOIC * Nl * Nl;
        T9  = (Nl + Nstar) * (Nl + Nstar);
        Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;

        T10 = NOIA * `q * Vtm;
        T11 = Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;
        Swi = T10 / T11 * ids * ids;

        T1  = Swi + Ssi;

        if (T1 > 0.0) begin
            FNPowerAt1Hz = (Ssi * Swi) / T1;
        end else begin
            FNPowerAt1Hz = 0.0;
        end

    end else begin
        FNPowerAt1Hz = 0.0;
    end

    // Intrinsic Charges
    qfgi = devsign * NF * qfg;
    qbgi = NF * qbg;

    if (sigvds > 0.0) begin
        qsi = NF * qs;
        qdi = NF * qd;
        qs  = NF * (qs - qfgs_parasitic) + Qsbg;
        qd  = NF * (qd - qfgd_parasitic) + Qdbg;
    end else begin
        qsi = NF * qd;
        qdi = NF * qs;
        T0  = NF * (qd - qfgs_parasitic) + Qsbg;
        qd  = NF * (qs - qfgd_parasitic) + Qdbg;
        qs  = T0;
    end

    qfg = qfgi + NF * (qfgs_parasitic + qfgd_parasitic);
    qbg = NF * qbg - Qsbg - Qdbg;

    qfgs_parasitic = NF * qfgs_parasitic;
    qfgd_parasitic = NF * qfgd_parasitic;

    // Thermal noise
    // Charge-based model (BSIM4: TNOIMOD = 0)
    qinv  = -(qsi + qdi);
    T0    = ueff * qinv;
    T1    = T0 * Rdsi + Leff * Leff;
    Gtnoi = (T0 / T1) * NTNOI;
    Nt    = 4.0 * Vtm * `q;
    sid   = Nt * Gtnoi;

    // NQS gate resistance Ref: BSIM4

    if (NQSMOD == 1 && XRCRG1_i != 0.0) begin
        T0       = ueff * cox1 * Weff / Leff;
        IdsovVds = beta * qia * Moc / (Dmob * Dvsat * Dr);
        gcrg     = NF * XRCRG1_i * (IdsovVds + XRCRG2_i * Vtm * T0);
    end


    // Loading variables
    igidl = NF * igidl;
    igisl = NF * igisl;
    igcd  = NF * igcd;
    igcs  = NF * igcs;
    igs   = NF * igs;
    igd   = NF * igd;

    if (sigvds > 0.0) begin
        I(di, si) <+ devsign * ids + (GDSMIN * V(di, si));
        I(di, si) <+ devsign * (igidl + Iii);
        I(si, di) <+ devsign * igisl;
        I(gi, si) <+ devsign * (igcs + igs);
        I(gi, di) <+ devsign * (igcd + igd);
    end else begin
        I(si, di) <+ devsign * ids + (GDSMIN * V(si, di));
        I(si, di) <+ devsign * (igidl + Iii);
        I(di, si) <+ devsign * igisl;
        I(gi, di) <+ devsign * (igcs + igs);
        I(gi, si) <+ devsign * (igcd + igd);
    end

    I(gi, si)  <+ devsign * igbs;
    I(gi, di)  <+ devsign * igbd;
    I(di, si)  <+ devsign * ddt(qdi);
    I(gi, si)  <+ ddt(qfgi);
    I(bg, si)  <+ devsign * ddt(qbgi);
    I(ge, si)  <+ ddt(qfgs_parasitic);
    I(ge, di)  <+ ddt(qfgd_parasitic);

    I(si, bg)  <+ ddt(Qsbg) * devsign;
    I(di, bg)  <+ ddt(Qdbg) * devsign;


    if (RDSMOD == 2) begin
        V(d, di) <+ 0.0;
        V(s, si) <+ 0.0;
    end else begin
        gdpr = 1.0 / Rdrain;
        gspr = 1.0 / Rsource;
        I(d, di) <+ white_noise(Nt * gdpr, "Rd");
        I(s, si) <+ white_noise(Nt * gspr, "Rs");
    end


// NQSMOD1 Gate Resistance Model

    if (NQSMOD == 1 && XRCRG1_i != 0.0)
        I(ge, gi) <+ V(ge, gi) * gcrg;
    else
        V(ge, gi) <+ 0.0;


    if (RGATEMOD == 0) begin
        V(fg, ge) <+ 0.0;
    end else begin: Rgate
        real Ggate, Gnoise;
        Ggate  = Grgeltd;
        Gnoise = Grgeltd;
        I(fg, ge) <+ V(fg, ge) * Ggate;
        I(fg, ge) <+ white_noise(Nt * Gnoise, "Rg");
    end


    // Flicker Noise
    I(di,si) <+ flicker_noise(FNPowerAt1Hz, EF, "flicker");

    // Channel thermal noise and induced gate noise stamping
    // Implementation of correlated noise follows C. C. McAndrew, WCM 2005
    I(di, si) <+ white_noise(sid, "Id");

    // Gate current shot noise
    if (IGCMOD != 0) begin
        if (sigvds > 0.0) begin
            I(gi, si) <+ white_noise(2.0 * `q * abs(igcs + igs), "Igs");
            I(gi, di) <+ white_noise(2.0 * `q * abs(igcd + igd), "Igd");
        end else begin
            I(gi, di) <+ white_noise(2.0 * `q * abs(igcs + igs), "Igd");
            I(gi, si) <+ white_noise(2.0 * `q * abs(igcd + igd), "Igs");
        end
    end

    if (IGBMOD != 0) begin
        I(gi, si) <+ white_noise(2.0 * `q * abs(igbs), "Igb");
        I(gi, di) <+ white_noise(2.0 * `q * abs(igbd), "Igb");
    end

   // Stamping external S/D Resistance
    if (RDSMOD == 2) begin
      V(d, di) <+ 0.0;
      V(s, si) <+ 0.0;
   end else begin
      I(d, di) <+ V(d, di) / Rdrain;
      I(s, si) <+ V(s, si) / Rsource;
   end


    // Self-heating
    if (SHMOD != 0 && RTH0 > 0.0) begin
        if (RDSMOD != 2) begin
            Pwr(ith_branch) <+ -(devsign * sigvds * V(di, si) * ids + V(d, di) * V(d, di) / Rdrain + V(s, si) * V(s, si) / Rsource);
        end else begin
            Pwr(ith_branch) <+ -(devsign * sigvds * V(di, si) * ids);
        end
        Pwr(rth_branch) <+ Temp(rth_branch) * gth;
        Pwr(rth_branch) <+ ddt(Temp(rth_branch) * cth);
    end else begin
        Temp(t) <+ 0.0;
    end

    // Operation-point info
    IDS = devsign * sigvds * ids;

    // Drain-source saturation voltage
    VDSSAT = Vdsat;

    // Threshold voltage
    VTH = Vthop;

    // Transconductance
    GM = ddx(IDS, V(gi));

    // Output conductance
    GDS = ddx(IDS, V(di));

    // Body transconductance
    GMBS = ddx(IDS, V(bg));

    if (sigvds > 0.0) begin
        VFGS = V(fg, s);
        VFGD = V(fg, d);
        VDS  = V(d, s);
        VSBG = V(s, bg);
        VDBG = V(d, bg);
    end else begin
        VFGS = V(fg, d);
        VFGD = V(fg, s);
        VDS  = V(s, d);
        VSBG = V(d, bg);
        VDBG = V(s, bg);
    end

    // Total Source/Drain Currents (Physical)
    if (sigvds > 0.0) begin
        ID = IDS - devsign * (igd + igcd + igbd) + devsign * (Iii + igidl - igisl);
        IS = -IDS - devsign * (igs + igcs + igbs) + devsign* (igisl - igidl);
    end else begin
        ID = -IDS - devsign * (igs + igcs + igbd) + devsign * (igisl - igidl);
        IS = IDS - devsign * (igd + igcd + igbs) + devsign * (Iii + igidl - igisl);
    end

    // Total Gate Current
    IFG = devsign * (igs + igd + igcs + igcd + igbs + igbd);

    // Impact Ionization Current
    III = devsign * Iii;

    if (sigvds > 0.0) begin
        IGIDL = devsign * igidl;
        IGISL = devsign * igisl;
    end else begin
        IGIDL = devsign * igisl;
        IGISL = devsign * igidl;
    end

    // Intrinsic Charges
    QFGI = qfgi;
    QBGI = devsign * qbgi;
    QDI  = devsign * qdi;
    QSI  = devsign * qsi;

    // Total Charges
    QFG = qfg;
    QBG = devsign * qbg;
    QD  = devsign * qd;
    QS  = devsign * qs;

    // Intrinsic Capacitances
    CFGFGI = ddx(QFGI, V(gi));
    CFGSI  = -ddx(QFGI, V(si));
    CFGDI  = -ddx(QFGI, V(di));
    CFGBGI = -ddx(QFGI, V(bg));

    CSFGI  = -ddx(QSI, V(gi));
    CSSI   = ddx(QSI, V(si));
    CSDI   = -ddx(QSI, V(di));
    CSBGI  = -ddx(QSI, V(bg));

    CDFGI  = -ddx(QDI, V(gi));
    CDSI   = -ddx(QDI, V(si));
    CDDI   = ddx(QDI, V(di));
    CDBGI  = -ddx(QDI, V(bg));

    CBGFGI = -ddx(QBGI, V(gi));
    CBGSI  = -ddx(QBGI, V(si));
    CBGDI  = -ddx(QBGI, V(di));
    CBGBGI = ddx(QBGI, V(bg));

    // Total Capacitances
    CFGFG  = CFGFGI + ddx(devsign * (qfgs_parasitic + qfgd_parasitic), V(ge));
    CFGS   = -ddx(QFG, V(si));
    CFGD   = -ddx(QFG, V(di));
    CFGBG  = -ddx(QFG, V(bg));

    CSFG   = CSFGI + ddx(devsign * qfgs_parasitic, V(ge));
    CSS    = ddx(QS, V(si));
    CSD    = -ddx(QS, V(di));
    CSBG   = -ddx(QS, V(bg));

    CDFG   = CDFGI + ddx(devsign * qfgd_parasitic, V(ge));
    CDS    = -ddx(QD, V(si));
    CDD    = ddx(QD, V(di));
    CDBG   = -ddx(QD, V(bg));

    CBGFG  = -ddx(QBG, V(gi));
    CBGS   = -ddx(QBG, V(si));
    CBGD   = -ddx(QBG, V(di));
    CBGBG  = ddx(QBG, V(bg));

    // Output for self-heating temperature
    T_TOTAL_K  = DevTemp;
    T_TOTAL_C  = DevTemp - `P_CELSIUS0;
    T_DELTA_SH = Temp(t);

end
