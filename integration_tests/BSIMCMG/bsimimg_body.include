// ****************************************************************************
// *  BSIM-IMG 103.0.0 released by Pragya Kushwaha on 1/2/2020                *
// *  BSIM Independent Multi-Gate Model (Verilog-A)                           *
// ****************************************************************************

// ****************************************************************************
// *  Copyright Â© 2020 University of California                               *
// *                                                                          *
// *  Project director: Prof. Chenming Hu                                     *
// *                                                                          *
// *  Current developers: Pragya Kushwaha (Postdoc, UC Berkeley)              *
// *                      Harshit Agarwal (Postdoc, UC Berkeley)              *
// *                      Avirup Dasgupta (Postdoc, UC Berkeley)              *
// *                      Girish Pahwa    (Postdoc, UC Berkeley)              *
// *                      Chetan K. Dabhi (Ph.D., IIT Kanpur)                 *
// ****************************************************************************

/*
Licensed under Educational Community License, Version 2.0 (the "License"); you may
not use this file except in compliance with the License. You may obtain a copy of the license at
http://opensource.org/licenses/ECL-2.0
Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT 
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations
under the License.

BSIM-IMG model is supported by the members of Silicon Integration Initiative's Compact Model Coalition. A link to the most recent version of this
standard can be found at: http://www.si2.org/cmc 
*/

// Clamped exponential function
analog function real lexp;
    input x;
    real x;

    begin
        if (x > `EXPL_THRESHOLD) begin
            lexp = `MAX_EXPL * (1.0 + x - `EXPL_THRESHOLD);
        end else if (x < -`EXPL_THRESHOLD) begin
            lexp = `MIN_EXPL;
        end else begin
            lexp = exp(x);
        end
    end
endfunction

// Clamped log function
analog function real lln;
    input x;
    real x;

    begin
        lln = ln(max(x, `N_MINLOG));
    end
endfunction

// Hyperbolic smoothing function
analog function real hypsmooth;
    input x, c;
    real x, c;

    begin
        hypsmooth = 0.5 * (x + sqrt(x * x + 4.0 * c * c));
    end
endfunction

// Hyperbolic smooth max function
analog function real hypmax;
    input x, xmin, c;
    real x, xmin, c;

    begin
        hypmax = xmin + 0.5 * (x - xmin - c + sqrt((x - xmin - c) * (x - xmin - c) - 4.0 * xmin * c));
    end
endfunction

// Smooth function to fix minimum value of a variable
analog function real smoothminx;
    input x, x0, deltax;
    real x, x0, deltax;
    begin
        smoothminx = 0.5 * (x + x0 + sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax));
    end
endfunction

// Smoothing function for (min of x, x0 with deltax)
analog function real minx;
    input x, x0, deltax;
    real x, x0, deltax;

    begin
        minx = 0.5 * (x + x0 - sqrt((x - x0) * (x - x0) + 0.25 * deltax * deltax));
    end
endfunction

// ***************************
// **  Instance Parameters  **
// ***************************
// Note: Some instance parameters are also model parameters. Please refer to the technical note for details.

`IPRco( L              ,3.0e-8         ,"m"           ,1.0e-9      ,inf         ,"Designed Gate Length" )
`IPRco( W              ,1.0e-6         ,"m"           ,1.0e-9      ,inf         ,"Designed Gate Width" )
`IPIco( NF             ,1              ,""            ,1           ,inf         ,"Number of fingers" )
`IPRcz( AS             ,0.0            ,"m^2"                                   ,"Source area" )
`IPRcz( AD             ,0.0            ,"m^2"                                   ,"Drain area" )
`IPRcz( PS             ,0.0            ,"m"                                     ,"Source perimeter" )
`IPRcz( PD             ,0.0            ,"m"                                     ,"Drain perimeter" )
`IPRcz( NRS            ,0.0            ,""                                      ,"Number of source diffusion squares" )
`IPRcz( NRD            ,0.0            ,""                                      ,"Number of drain diffusion squares" )

// Variability Handles
`IPRnb( DTEMP          ,0.0            ,"Celsius"                               ,"Variability in Device Temperature" )
`IPRnb( DELVTRAND      ,0.0            ,"V"                                     ,"Variability in Vth" )
`IPRoz( U0MULT         ,1.0            ,""                                      ,"Variability in carrier mobility" )

// ************************
// **  Model Parameters  **
// ************************
`MPIty( TYPE           ,`ntype         ,""                                      ,"NMOS=1, PMOS=-1" )
`MPIty( WELLTYPE       ,-TYPE          ,""                                      ,"Well (substrate) type" )
`MPIcc( RDSMOD         ,0              ,""            ,0           ,2           ,"0: Internal s/d resistance model, 1: External s/d resistance model, 2: Both bias dependent and independent part of source/drain resistance internal" )
`MPIcc( GIDLMOD        ,0              ,""            ,0           ,1           ,"0: Turn off GIDL/GISL current, 1: Turn on GIDL/GISL current" )
`MPIcc( IGCMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igc, Igs and Igd, 1: Turn on Igc, Igs and Igd" )
`MPIcc( IGBMOD         ,0              ,""            ,0           ,1           ,"0: Turn off Igb" )
`MPIcc( SHMOD          ,0              ,""            ,0           ,1           ,"0: No self-heating" )
`MPIcc( RGATEMOD       ,0              ,""            ,0           ,1           ,"Gate resistance model selector" )
`MPIcc( NQSMOD         ,0              ,""            ,0           ,1           ,"0: Turn off NQS model; 1: NQS gate resistance (with gi node)" )
`MPIcc( NFMOD          ,0              ,""            ,0           ,1           ,"0: W taken as total width like BSIM4, 1: W taken as single finger width  " )
`MPIcc( FNMOD          ,0              ,""            ,0           ,1           ,"Flicker noise model 0: Old, 1: Improved" )
`MPRnb( XL             ,0.0            ,"m"                                     ,"L offset for channel length due to mask/etch effect" )
`MPRnb( XW             ,0.0            ,"m"                                     ,"W offset for channel width due to mask/etch effect" )
`MPRnb( LINT           ,0.0            ,"m"                                     ,"Delta L for IV" )
`MPRnb( LL             ,0.0            ,"m^(1+LLN)"                             ,"" )
`MPRnb( LW             ,0.0            ,"m^(1+LWN)"                             ,"" )
`MPRnb( LWL            ,0.0            ,"m^(LWN+LLN+1)"                         ,"" )
`MPRnb( LLN            ,1.0            ,""                                      ,"" )
`MPRnb( LWN            ,1.0            ,""                                      ,"" )
`MPRnb( WINT           ,0.0            ,"m"                                     ,"Delta W for IV" )
`MPRnb( WL             ,0.0            ,"m^(1+WLN)"                             ,"" )
`MPRnb( WW             ,0.0            ,"m^(1+WWN)"                             ,"" )
`MPRnb( WWL            ,0.0            ,"m^(WLN+WWN+1)"                         ,"" )
`MPRnb( WLN            ,1.0            ,""                                      ,"" )
`MPRnb( WWN            ,1.0            ,""                                      ,"" )
`MPRnb( DLC            ,0.0            ,"m"                                     ,"Delta L for CV" )
`MPRnb( LLC            ,0.0            ,"m"                                     ,"" )
`MPRnb( LWC            ,0.0            ,"m"                                     ,"" )
`MPRnb( LWLC           ,0.0            ,"m"                                     ,"" )
`MPRnb( DWC            ,0.0            ,"m"                                     ,"Delta W for CV" )
`MPRnb( WLC            ,0.0            ,"m"                                     ,"" )
`MPRnb( WWC            ,0.0            ,"m"                                     ,"" )
`MPRnb( WWLC           ,0.0            ,"m"                                     ,"" )

`MPRco( EOT1           ,1.0e-9         ,"m"           ,0.1e-9      ,inf         ,"Equivalent front gate dielectric thickness relative to SiO2" )
`MPRco( EOT2           ,1.0e-8         ,"m"           ,0.1e-9      ,inf         ,"Equivalent back  gate dielectric thickness relative to SiO2" )
`MPRco( EOT1P          ,EOT1           ,"m"           ,0.1e-9      ,inf         ,"Equivalent physical front gate dielectric thickness relative to SiO2" )
`MPRnb( DTOX1          ,0.0            ,"m"                                     ,"Difference between effective dielectric thickness and physical thickness" )
`MPRco( TSI            ,8.0e-9         ,"m"           ,1.0e-9      ,inf         ,"Body thickness" )
`MPRcc( NBODY          ,1.0e22         ,"m^-3"        ,1.0e18      ,5.0e24      ,"Channel (body) doping" )
`MPRcc( NSD            ,2.0e26         ,"m^-3"        ,2.0e25      ,1.0e27      ,"Source/drain active doping concentration" )
`MPRcz( NBG            ,5.0e23         ,"m^-3"                                  ,"Well/substrate (or also called back-gate) doping, zero for metal" )
`MPRcz( EASUB          ,4.05           ,"eV"                                    ,"Electron affinity of well/substrate" )
`MPRoz( NI0SUB         ,1.1e16         ,"m^-3"                                  ,"Intrinsic carrier constant at 300.15K" )
`MPRoz( BG0SUB         ,1.12           ,"eV"                                    ,"Band gap of well/substrate at 300.15K" )
`MPRoz( NC0SUB         ,2.86e25        ,""                                      ,"Conduction band density of states" )
`MPRoz( PHIG1          ,4.61           ,"eV"                                    ,"Front Gate Workfunction" )
`MPRoz( PHIG2          ,((WELLTYPE == `ptype) ? (EASUB + BG0SUB) : EASUB),"eV"  ,"Back gate workfunction, will be modified according to NBG later in the code" )
`MPRoz( EPSRSUB        ,11.9           ,""                                      ,"Relative dielectric constant of the channel material" )
`MPRoz( EPSROX1        ,3.9            ,""                                      ,"Relative dielectric constant of the front gate dielectric" )

 // Short Channel Effects
`MPRnb( ASCL           ,0.0            ,""                                      ,"Parameter for back-gate dependent scale length" )
`MPRnb( BSCL           ,0.0            ,"V^-1"                                  ,"Parameter for back-gate dependent scale length" )
`MPRnb( CIT            ,0.0            ,"F/(m^2)"                               ,"Parameter for interface trap" )
`MPRnb( CDSC           ,0.14           ,"F/(m^2)"                               ,"Coupling capacitance between S/D and channel" )
`MPRnb( CDSCD          ,0.14           ,"F/(m^2*V)"                             ,"Drain-bias sensitivity of CDSC" )
`MPRnb( CBGCBG0        ,0.0            ,"F/(m^2*V)"                             ,"Backgate-bias sensitivity of SS for long channel" )
`MPRnb( CBGCBG0P       ,0.0            ,"F/(m^2*V^2)"                           ,"Backgate-bias sensitivity of SS for long channel" )
`MPRnb( CBGCBG         ,0.0            ,"F/(m^2*V)"                             ,"Backgate-bias sensitivity of CDSC" )
`MPRnb( CBGCBGP        ,0.0            ,"F/(m^2*V^2)"                           ,"Nonlinear backgate-bias sensitivity of SS" )
`MPRnb( CBGCBGD        ,0.0            ,"F/(m^2*V^2)"                           ,"Backgate-bias sensitivity of CDSCD" )
`MPRnb( DVT0           ,19.2           ,""                                      ,"SCE coefficient" )
`MPRnb( DVT1           ,0.45           ,""                                      ,"SCE exponent coefficient" )
`MPRnb( PHIN           ,0.045          ,"V"                                     ,"Nonuniform vertical doping effect on surface potential" )
`MPRnb( ETA0           ,2.0            ,""                                      ,"DIBL coefficient 1" )
`MPRnb( ETA1           ,0.00           ,""                                      ,"DIBL coefficient for low gate overdrive" )
`MPRnb( DSUB           ,0.375          ,""                                      ,"DIBL coefficient 2 (exponent coefficient)" )
`MPRnb( DVTP0          ,0              ,""                                      ,"Coefficient for Drain-Induced Vth Shift (DITS)" )
`MPRnb( DVTP1          ,0              ,""                                      ,"DITS exponent coefficient" )
`MPRnb( ADVTP0         ,0.0            ,""                                      ,"Pre-exponential Coefficient for DITS" )
`MPRex( BDVTP0         ,100.0e-9       ,""            ,0.0                      ,"Exponential coefficient for DITS" )
`MPRnb( ADVTP1         ,0.0            ,""                                      ,"Pre-exponential coefficient for DVTP1" )
`MPRex( BDVTP1         ,100.0e-9       ,""            ,0.0                      ,"Exponential coefficient for DVTP1" )
`MPRnb( DVTP2          ,0.0            ,""                                      ,"DITS Model Parameter" )
`MPRnb( ETAB           ,0.00           ,""                                      ,"DIBL coefficient - Back Gate dependence" )
`MPRnb( K1RSCE         ,-0.32          ,""                                      ,"Vt Roll-off at moderate Lg" )
`MPRnb( LPE0           ,8.2e-9         ,"m"                                     ,"Equivalent length of pocket region at zero bias" )
`MPRnb( DSC0           ,0.0            ,""                                      ,"Parameter for short channel effect at moderate L and high drain bias" )
`MPRnb( DSC1           ,1.0e-9         ,""                                      ,"Parameter for short channel effect at moderate L and high drain bias" )

// Lateral non-uniform doping effect (IV-CV Vth shift)
`MPRnb( K0             ,0.0            ,"V"                                     ,"Lateral NUD voltage parameter" )
`MPRnb( K01            ,0.0            ,"V/K"                                   ,"Temperature dependence of lateral NUD voltage parameter" )
`MPRnb( K0SI           ,1.0            ,""                                      ,"Correction factor for strong inversion, used in Mnud, after binning should be from (0:inf)" )
`MPRnb( K0SI1          ,0.0            ,"K^-1"                                  ,"Temperature dependence of K0SI" )
`MPRnb( K0SISAT        ,0.0            ,""                                      ,"Correction factor for strong inversion, used in Mnud" )
`MPRnb( K0SISAT1       ,0.0            ,""                                      ,"Temperature dependence of K0SISAT" )

// Quantum Mechanical Effects

`MPRnb( QMTCENCV       ,0.0            ,""                                      ,"Prefactor + switch for QM Width and Toxeff correction for CV" )
`MPRnb( ETAQM          ,0.54           ,""                                      ,"Bulk charge coefficient for Tcen" )
`MPRoz( QM0            ,1.0e-3         ,""                                      ,"Knee-Point for Tcen in inversion (Charge normalized to Cox)" )
`MPRnb( PQM            ,0.66           ,""                                      ,"Slope of normalized Tcen in inversion" )
`MPRco( TOXP           ,EOT1           ,"m"           ,0.1e-9      ,inf         ,"Physical oxide thickness" )

// Velocity Saturation Model
`MPRnb( VSAT           ,85000          ,"m/s"                                   ,"Saturation Velocity" )
`MPRnb( AVSAT          ,0.0            ,"m/s"                                   ,"" )
`MPRex( BVSAT          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( VSAT1          ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter" )
`MPRnb( AVSAT1         ,AVSAT          ,"m/s"                                   ,"" )
`MPRex( BVSAT1         ,BVSAT          ,"m"           ,0.0                      ,"" )
`MPRnb( VSATCV         ,VSAT           ,"m/s"                                   ,"Velocity Saturation parameter for CV" )
`MPRnb( AVSATCV        ,AVSAT          ,"m/s"                                   ,"" )
`MPRex( BVSATCV        ,BVSAT          ,"m"           ,0.0                      ,"" )
`MPRnb( DELTAVSAT      ,1.0            ,"m/s"                                   ,"Velocity saturation parameter" )
`MPRnb( KSATIV         ,1.0            ,""                                      ,"Parameter for strong inversion regime for long channel Vdsat" )
`MPRnb( KSUBIV         ,1.0            ,""                                      ,"Parameter for weak inversion regime for long channel Vdsat" )
`MPRnb( KSATIVB        ,0.0            ,""                                      ,"Parameter for strong inversion regime for long channel Vdsat" )
`MPRnb( MEXP           ,4.0            ,""                                      ,"Smoothing function factor for Vdsat" )
`MPRnb( AMEXP          ,0.0            ,""                                      ,"" )
`MPRnb( BMEXP          ,1.0            ,""                                      ,"" )
`MPRnb( PTWG           ,0.0            ,"V^-2"                                  ,"Correction factor for velocity saturation" )
`MPRnb( APTWG          ,0.0            ,"V^-2"                                  ,"" )
`MPRex( BPTWG          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( AT             ,-1.56e-3       ,""                                      ,"Saturation Velocity Temperature Coefficient" )
`MPRnb( ATL            ,0.0            ,""                                      ,"Length scaling for AT" )
`MPRnb( TMEXP          ,0.0            ,""                                      ,"" )
`MPRnb( PTWGT          ,0.004          ,""                                      ,"" )
`MPRnb( PTWGB          ,0.0            ,"V^-3"                                  ,"" )
`MPRnb( PTWGB2         ,0.0            ,"V^-3"                                  ,"" )
`MPRnb( APTWGB         ,0.0            ,"V^-3"                                  ,"" )
`MPRex( BPTWGB         ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( APTWGB2        ,0.0            ,"V^-3"                                  ,"" )
`MPRex( BPTWGB2        ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( VSATB          ,0.0            ,"V^-1"                                  ,"" )
`MPRnb( ATB            ,0.0            ,""                                      ,"Back bias sensitivity parameter for saturation velocity temperature coefficient" )
`MPRnb( ATBL           ,0.0            ,""                                      ,"Length scaling for ATB" )
`MPRnb( AVSATB         ,0.0            ,"V^-1"                                  ,"" )
`MPRex( BVSATB         ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRco( DVSATCLAMP     ,0.01           ,"m"           ,0.01        ,inf         ,"Minimum clamp on Dvsat" )

// Mobility Model
`MPRex( U0             ,0.03           ,"m^2/(V*s)"   ,0.0                      ,"Low Field Mobility" )
`MPRnb( ETAMOB         ,2.0            ,""                                      ,"" )
`MPRnb( UP             ,0.0            ,"(um)^LPA"                              ,"" )
`MPRnb( LPA            ,1.0            ,""                                      ,"" )
`MPRnb( UA             ,0.3            ,"(MV/cm)^(-EU)"                         ,"" )
`MPRnb( AUA            ,0.0            ,"(MV/cm)^(-EU)"                         ,"" )
`MPRex( BUA            ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( EU             ,2.5            ,"cm/MV"                                 ,"" )
`MPRnb( AEU            ,0.0            ,"cm/MV"                                 ,"" )
`MPRex( BEU            ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( UC             ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"" )
`MPRnb( AUC            ,0.0            ,"(1/V)*(MV/cm)^(-EU)"                   ,"" )
`MPRex( BUC            ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( UD             ,0.0            ,""                                      ,"" )
`MPRnb( AUD            ,0.0            ,""                                      ,"" )
`MPRex( BUD            ,50.0e-9        ,"m"           ,0.0                      ,"" )
`MPRnb( UDB            ,0.0            ,"V^-1"                                  ,"" )
`MPRnb( AUDB           ,0.0            ,"V^-1"                                  ,"" )
`MPRex( BUDB           ,50.0e-9        ,"m"           ,0.0                      ,"" )
`MPRco( DMOBCLAMP      ,0.01           ,"m"           ,0.01        ,inf         ,"Minimum clamp on Dmob" )
`MPRnb( UCS            ,1.0            ,""                                      ,"" )
`MPRnb( UTE            ,0.0            ,""                                      ,"" )
`MPRnb( UTL            ,-1.5e-3        ,""                                      ,"" )
`MPRnb( UA1            ,1.032e-3       ,""                                      ,"" )
`MPRnb( UC1            ,0.0            ,""                                      ,"" )
`MPRnb( UD1            ,0.0            ,""                                      ,"" )
`MPRnb( UCSTE          ,-4.775e-3      ,""                                      ,"" )
`MPRcc( CHARGEWF       ,0.0            ,""            ,-1.0        ,1.0         ,"Average Channel Charge Weighting Factor, +1:source-side, 0:middle, -1:drain-side" )
`MPRnb( EUB            ,0.0            ,""                                      ,"" )
`MPRnb( AEUB           ,0.0            ,""                                      ,"" )
`MPRex( BEUB           ,100.0e-9       ,""            ,0.0                      ,"" )
`MPRnb( U02            ,0.03           ,"m^2/(V*s)"                             ,"Low Field Mobility" )
`MPRnb( UA2            ,0.3            ,"(MV/cm)^(-EU2)"                        ,"" )
`MPRnb( AUA2           ,0.0            ,"(MV/cm)^(-EU2)"                        ,"" )
`MPRex( BUA2           ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( EU2            ,2.5            ,"cm/MV"                                 ,"" )
`MPRnb( AEU2           ,0.0            ,"cm/MV"                                 ,"" )
`MPRex( BEU2           ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( UC2            ,0.0            ,"(1/V)*(MV/cm)^(-EU2)"                  ,"" )
`MPRnb( AUC2           ,0.0            ,"(1/V)*(MV/cm)^(-EU2)"                  ,"" )
`MPRex( BUC2           ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( UD2            ,0.0            ,""                                      ,"" )
`MPRnb( AUD2           ,0.0            ,""                                      ,"" )
`MPRex( BUD2           ,50.0e-9        ,"m"           ,0.0                      ,"" )
`MPRnb( UDB2           ,0.0            ,"V^-1"                                  ,"" )
`MPRnb( AUDB2          ,0.0            ,"V^-1"                                  ,"" )
`MPRex( BUDB2          ,50.0e-9        ,"m"           ,0.0                      ,"" )
`MPRnb( UCS2           ,1.0            ,""                                      ,"" )
`MPRnb( EUB2           ,0.0            ,""                                      ,"" )
`MPRnb( AEUB2          ,0.0            ,""                                      ,"" )
`MPRex( BEUB2          ,100.0e-9       ,""            ,0.0                      ,"" )
`MPRnb( ETAMOB2        ,2.0            ,""                                      ,"" )
`MPRnb( UP2            ,0.0            ,"(um)^LPA2"                             ,"" )
`MPRnb( LPA2           ,1.0            ,""                                      ,"" )
`MPRcc( CHARGEWF2      ,0.0            ,""            ,-1.0        ,1.0         ,"Average Channel Charge Weighting Factor, +1:source-side, 0:middle, -1:drain-side" )

// Access Resistance Model
`MPRcz( RDSWMIN        ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 0 S/D extension resistance per unit width at high Vgs" )
`MPRcz( RDSW           ,100.0          ,"ohm*um^WR"                             ,"RDSMOD = 0 zero bias S/D extension resistance per unit width" )
`MPRnb( ARDSW          ,0.0            ,"ohm*um^WR"                             ,"" )
`MPRex( BRDSW          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRcz( RSWMIN         ,0.0            ,"ohm*um^WR"                             ,"RDSMOD = 1 source extension resistance per unit width at high Vgs" )
`MPRcz( RSW            ,50.0           ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias source extension resistance per unit width" )
`MPRnb( ARSW           ,0.0            ,"ohm*um^W"                              ,"pre-exponential coefficient for RSW" )
`MPRex( BRSW           ,100.0e-9       ,"m"           ,0.0                      ,"exponential coefficient for RSW" )
`MPRcz( RDWMIN         ,RSWMIN         ,"ohm*um^WR"                             ,"RDSMOD = 1 drain extension resistance per unit width at high Vgs" )
`MPRcz( RDW            ,RSW           ,"ohm*um^WR"                             ,"RDSMOD = 1 zero bias drain extension resistance per unit width" )
`MPRnb( ARDW           ,ARSW            ,"ohm*um^WR"                             ,"" )
`MPRex( BRDW           ,BRSW       ,"m"           ,0.0                      ,"" )
`MPRnb( PRWG           ,0              ,"V^-1"                                  ,"Gate bias dependence of source/drain extension resistance" )
`MPRnb( PRWB           ,0              ,"V^-1"                                  ,"" )
`MPRnb( WR             ,1.0            ,"V^-1"                                  ,"W dependence parameter of S/D extension resistance" )
`MPRnb( PRT            ,0.001          ,"K^-1"                                  ,"Series Resistance Temperature coefficient" )

// DIBL Model
`MPRnb( PDIBL1         ,1.30           ,""                                      ,"DIBL Output Conductance parameter" )
`MPRnb( PDIBL2         ,2.0e-4         ,""                                      ,"DIBL Output Conductance parameter" )
`MPRnb( DROUT          ,1.06           ,""                                      ,"L dependence of DIBL effect on Rout" )
`MPRnb( PVAG           ,1.0            ,""                                      ,"Vgs dependence on early voltage" )

// Channel Length Modulation Effect
`MPRnb( PCLM           ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter" )
`MPRnb( APCLM          ,0.0            ,""                                      ,"" )
`MPRex( BPCLM          ,100.0e-9       ,"m"           ,0.0                      ,"" )
`MPRnb( PCLMG          ,0.0            ,""                                      ,"Gate bias dependent parameter for channel Length Modulation (CLM)" )
`MPRnb( PCLMCV         ,0.013          ,""                                      ,"Channel Length Modulation (CLM) parameter for C-V" )

// Geometry dependent Source/Drain Resistance RGEOMOD=0
`MPRcz( RSHS           ,0.0            ,"ohm"                                   ,"Source-side sheet resistance" )
`MPRcz( RSHD           ,RSHS           ,"ohm"                                   ,"Drain-side sheet resistance" )

// Gate Tunneling Current from Gate to Channel (Igc)
`MPRnb( AIGBINV        ,1.11e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igb in inversion" )
`MPRnb( BIGBINV        ,9.49e-4        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igb in inversion" )
`MPRnb( CIGBINV        ,6.0e-3         ,"V^-1"                                  ,"Parameter for Igb in inversion" )
`MPRnb( EIGBINV        ,1.1            ,"V"                                     ,"Parameter for Igb in inversion" )
`MPRnb( NIGBINV        ,3.0            ,""                                      ,"Parameter for Igb in inversion" )
`MPRnb( AIGBACC        ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igb in accumulation" )
`MPRnb( BIGBACC        ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igb in accumulation" )
`MPRnb( CIGBACC        ,7.5e-2         ,"V^-1"                                  ,"Parameter for Igb in accumulation" )
`MPRnb( NIGBACC        ,1.0            ,""                                      ,"Parameter for Igb in accumulation" )
`MPRnb( AIGC           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igc in inversion" )
`MPRnb( BIGC           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igc in inversion" )
`MPRnb( CIGC           ,0.075          ,"V^-1"                                  ,"Parameter for Igc in inversion" )
`MPRnb( PIGCD          ,1.0            ,""                                      ,"Parameter for Igc partition" )
`MPRnb( DIGC           ,1.0            ,""                                      ,"Parameter for Igc in inversion" )

// Gate Tunneling Current from Gate to S/D (Igs and Igd)
`MPRnb( AIGS           ,1.36e-2        ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igs, Igd" )
`MPRnb( BIGS           ,1.71e-3        ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igs, Igd" )
`MPRnb( CIGS           ,0.075          ,"V^-1"                                  ,"Parameter for Igs, Igd" )
`MPRcz( DLCIGS         ,0.0            ,"m"                                     ,"Delta L for Igs model" )
`MPRcz( DLCIGD         ,DLCIGS         ,"m"                                     ,"Delta L for Igd model" )
`MPRnb( AIGD           ,AIGS           ,"((F*s^2/g)^0.5)*m^-1"                  ,"Parameter for Igd in inversion" )
`MPRnb( BIGD           ,BIGS           ,"((F*s^2/g)^0.5)*(m*V)^-1"              ,"Parameter for Igd in inversion" )
`MPRnb( CIGD           ,CIGS           ,"V^-1"                                  ,"Parameter for Igs, Igd" )
`MPRoz( TOXREF         ,1.2e-9         ,"m"                                     ,"Target tox value" )
`MPRnb( NTOX           ,1.0            ,""                                      ,"Exponent for Tox ratio" )
`MPRnb( POXEDGE        ,1.0            ,""                                      ,"Factor for the gate edge Tox" )
`MPRnb( DIGS           ,1.0            ,""                                      ,"Parameter for Igs, Igd" )
`MPRnb( DIGD           ,DIGS           ,""                                      ,"Parameter for Igs, Igd" )

// Gate-Induced Source/Drain Leakage
`MPRnb( AGIDL          ,6.055e-12      ,"mho"                                   ,"Pre-exponential coeff. for GIDL" )
`MPRnb( BGIDL          ,0.3e9          ,"V/m"                                   ,"Exponential coeff. for GIDL" )
`MPRnb( EGIDL          ,0.2            ,"V"                                     ,"Band bending parameter for GIDL" )
`MPRnb( PGIDL          ,1.0            ,""                                      ,"Exponent of electric field for GIDL" )
`MPRnb( VBGIDL         ,1.0            ,""                                      ,"Back gate correction factor for GIDL" )
`MPRnb( VBEGIDL        ,0.5            ,"V"                                     ,"Back band bending parameter for GIDL" )
`MPRnb( AGISL          ,AGIDL          ,"mho"                                   ,"Pre-exponential coeff. for GISL" )
`MPRnb( BGISL          ,BGIDL          ,"V/m"                                   ,"Exponential coeff. for GISL" )
`MPRnb( EGISL          ,EGIDL          ,"V"                                     ,"Band bending parameter for GISL" )
`MPRnb( PGISL          ,PGIDL          ,""                                      ,"Exponent of electric field for GISL" )
`MPRnb( VBGISL         ,VBGIDL         ,""                                      ,"Back gate correction factor for GISL" )
`MPRnb( VBEGISL        ,VBEGIDL        ,"V"                                     ,"Back band bending parameter for GISL" )

// Impact Ionization Current
`MPRnb( ALPHA0         ,0.0            ,"m/V"                                   ,"First parameter of Iii" )
`MPRnb( ALPHA1         ,0.0            ,"V^-1"                                  ,"L scaling parameter of Iii" )
`MPRnb( BETA0          ,0.0            ,"V^-1"                                  ,"Vds dependent parameter of Iii" )

// Overlap Cap and Fringing Cap
`MPRnb( LOVS           ,0.0            ,"m"                                     ,"Overlap length for fg/s fg/d overlap" )
`MPRnb( LOVD           ,LOVS           ,"m"                                     ,"Overlap length for fg/s fg/d overlap" )
`MPRcz( CFS            ,0.0            ,"F/m"                                   ,"Outer Fringe Cap" )
`MPRcz( CFD            ,CFS            ,"F/m"                                   ,"Outer Fringe Cap" )
`MPRcz( CGSL           ,0.0            ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped source region" )
`MPRcz( CGDL           ,CGSL           ,"F/m"                                   ,"Overlap capacitance between gate and lightly-doped drain region" )
`MPRco( CKAPPAS        ,0.6            ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the source side" )
`MPRco( CKAPPAD        ,CKAPPAS        ,"V"           ,0.02        ,inf         ,"Coefficient of bias-dependent overlap capacitance for the drain side" )
`MPRnb( CSDBGSW        ,0.0            ,"F/m"                                   ,"Source/drain sidewall fringing capacitance per unit length" )
`MPRnb( PCOVBS0        ,0.0            ,"V"                                     ,"Back-gate dependent overlap capacitance clamping shift voltage for the source side" )
`MPRnb( PCOVBS1        ,0.0            ,""                                      ,"Parameter of back-gate dependent overlap capacitance for the source side" )
`MPRnb( PCOVBD0        ,PCOVBS0        ,"V"                                     ,"Back-gate dependent overlap capacitance clamping shift voltage for the drain side" )
`MPRnb( PCOVBD1        ,PCOVBS1        ,""                                      ,"Parameter of back-gate dependent overlap capacitance for the drain side" )

// Back Gate Biasing Effect, Gamma = d_Vth / d_Vbg
// P-well
`MPRnb( KBG0PW         ,1.0            ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( KBG1PW         ,0.0            ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( KBG2PW         ,-1.0           ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( DBGPW          ,0.12           ,""                                      ,"Length dependence of substrate factor" )
`MPRnb( BPFACTORPW     ,0.0            ,""                                      ,"Back-plane (BP) effect, 1 means no BP" )
`MPRnb( VKNEE1PW       ,0.0            ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" )
`MPRco( VKNEE2PW       ,1.0            ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" )

// N-well
`MPRnb( KBG0NW         ,KBG0PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( KBG1NW         ,KBG1PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( KBG2NW         ,KBG2PW         ,""                                      ,"Length dependence of body factor" )
`MPRnb( DBGNW          ,DBGPW          ,""                                      ,"Length dependence of body factor" )
`MPRnb( BPFACTORNW     ,BPFACTORPW     ,""                                      ,"Back-plane (BP) effect, 1 means no BP" )
`MPRnb( VKNEE1NW       ,VKNEE1PW       ,"V"                                     ,"Back gate voltage at which the substrate depletion below the BOX starts" )
`MPRco( VKNEE2NW       ,VKNEE2PW       ,"V"           ,0.0         ,inf         ,"Maximum potential drop below the BOX" )

// Flicker Noise
`MPRoc( EF             ,1.0            ,""            ,0.0         ,2.0         ,"Flicker noise frequency exponent" )
`MPRoz( EM             ,4.1e7          ,"V/m"                                   ,"Flicker noise parameter" )
`MPRoz( NOIA           ,6.25e39        ,"eV^-1* s^1-EF *m^-3"                   ,"Flicker noise parameter" )
`MPRoz( NOIB           ,3.125e24       ,"eV^-1* s^1-EF *m^-1"                   ,"Flicker noise parameter" )
`MPRoz( NOIC           ,8.75e7         ,"eV^-1* s^1-EF *m"                      ,"Flicker noise parameter" )
`MPRoz( NOIA2          ,NOIA           ,"eV^-1* s^1-EF *m^-3"                   ,"Noise parameter for FNMOD=1" )
`MPRoz( SMOOTH         ,2              ,""                                      ,"Smoothing Parameter" )
`MPRoz( MPOWER         ,1.2            ,""                                      ,"Sub-threshold to strong inversion transition slope Parameter" )
`MPRoz( QSREF          ,50m            ,""                                      , "Charge at threshold condition" )

// Thermal Noise
`MPRcz( NTNOI          ,1.0            ,""                                      ,"Thermal noise parameter" )
`MPRnb( LINTNOI        ,0.0            ,"m"                                     ,"Lint offset for flicker noise calculation" )

// Temperature Effect
`MPRco( TNOM           ,27.0           ,"Celsius"     ,-273.15     ,inf         ,"Temperature at which the model is extracted" )
`MPRnb( TMAXC          ,400.0          ,"Celsius"                               ,"Maximum Device Temperature" )
`MPRnb( TBGASUB        ,7.02e-4        ,"eV/K"                                  ,"Bandgap Temperature Coefficient" )
`MPRnb( TBGBSUB        ,1108.0         ,"K"                                     ,"Bandgap Temperature Coefficient" )
`MPRnb( KT1            ,0.0            ,"V"                                     ,"Vth Temperature Coefficient" )
`MPRnb( KT1L           ,0.0            ,"V*m"                                   ,"Vth Temperature L Coefficient" )
`MPRnb( KT2            ,0.0            ,""                                      ,"Vth Temperature Vbg Coefficient" )
`MPRnb( KT2L           ,0.0            ,"m"                                     ,"Vbg Temperature L Coefficient" )
`MPRnb( IIT            ,-0.5           ,""                                      ,"Impact Ionization Temperature Dependence" )
`MPRnb( TGIDL          ,-0.003         ,"K^-1"                                  ,"GIDL Temperature Dependence" )
`MPRnb( TGISL          ,TGIDL         ,"K^-1"                                  ,"GISL Temperature Dependence" )
`MPRnb( IGT            ,2.5            ,""                                      ,"Gate Current Temperature Dependence" )
`MPRnb( TETA0          ,0.0            ,"K^-1"                                  ,"Temperature Dependence for DIBL effects" )

// Self-Heating
`MPRcz( RTH0           ,0.01           ,"ohm*m*K/W"                             ,"Thermal resistance" )
`MPRcz( CTH0           ,1.0e-5         ,"W*s/m/K"                               ,"Thermal capacitance" )
`MPRcz( WTH0           ,0.0            ,"m"                                     ,"Width dependence coefficient for Rth and Cth" )

`MPRnb( XGW            ,0.0            ,"m"                                     ,"Distance from gate contact center to device edge" )
`MPRoo( XGL            ,0.0            ,"m"           ,-inf        ,L + XL      ,"Variation in Ldrawn" )
`MPIcc( NGCON          ,1              ,""            ,1           ,2           ,"Number of gate contacts" )
`MPRcz( RSHG           ,0.1            ,"ohm"                                   ,"Gate sheet resistance" )

// For NQSMOD = 1, Set XRCRG1 = 0 to turn off NQS gate resistance
`MPRnb( XRCRG1         ,12.0           ,""            ,"Parameter for Rg in NQSMOD = 1" )
`MPRnb( XRCRG2         ,1.0            ,""            ,"Parameter for Rg in NQSMOD = 1" )

// Binning Parameters
`include "bsimimg_binning.include"

// *****************
// **  Variables  **
// *****************

// Common Variables
real Lnew, LeffCV, Leff, Weff, WeffCV, Wnew, L_LLN, W_LWN, LW_LLN_LWN, dLIV, L_WLN, W_WWN, LW_WLN_WWN, dWIV, dLCV, dWCV;
real epssi, cox1, cox1P, cox2, csi, epsratio;
real vfgs, vbgs, vbgd, vbgx, vds, sigvds, vbgxpos;
real vgs_noswap, vds_noswap, vgd_noswap, vbgs_noswap, vbgd_noswap;
real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11;
real qia, qia2, qba, dqi;
real phib, phisub, deltaphi1, deltaphi2;
real Eg, Vtm;
real beta;
real wf, wr;
real qb0;
real dvth_nbody;
real tmp, QMTCENCV_i, Tcen0, Tcen, coxeff;
real ETAQM_i, QM0_i, PQM_i;

// Terminal Voltage Conditioning Variables
real vgfb1, vgfb2, vgfb1eff, vgfb2eff;
real vdsx, symmetry_factor;

// Short Channel Effects
real scl, sclm, sclf, teff, temp;
real vbi, nVtm, dvth_dibl, dvth_vtroll, dvth_rsce, dvth_dsc, dvth_all, phist;
real Theta_SCE, Theta_RSCE, Theta_DIBL;

// DITS Model parameters
real Theta_DITS, DVTP0_i, DVTP1_i;

// Lateral Non-uniform Doping Effect
real Mnud;

// Temperature Effects
real Tnom, TRatio, delTemp;
real PhiRef, PhiSD, ni;
real dvth_temp, dvth_temp0;
real BETA0_t, BGIDL_t, BGISL_t, igtemp, ETA0_t;
real K0SISAT_t;

// Drain Saturation Voltage
real qis, qid, qbs, Dmobs, Vdseff;
real eta_mu, eta_mu_cv, Eeffm, Eeffm2, Eeffm_cv, Dmob, Dmob_cv, utotal;
real UA_t, UC_t, UCS_t, UD_t, U0_t, Eeffs, Eeffs2, EeffFactor;
real Dr, WeffWRFactor;
real RSourceGeo, RDrainGeo;
real RDSWMIN_i, RDWMIN_i, RSWMIN_i;
real UDB_i, UDB2_i;
real w1, w2, ueff1, ueff2, eta_mu2, EeffFactor2, qib2;
real Rdrain, Rsource;
real gspr, gdpr;
real rdstemp, Rdsi, Rdss;
real DIBLfactor, PVAGfactor, diffVds, VaDIBL, Vgst2Vtm, Moc, Mclm, MclmCV;
real Dvsat, Vdsat, inv_MEXP;
real VSAT_t,VSATB_t,VSAT1_t, VSATCV_t, MEXP_t, Esat, EsatL, EsatCV, EsatCVL, Esat1, Esat1L;
real K0_t, K0SI_t;
real WVCox, Ta, Tb, Tc;
real Xsat;
real PTWG_t;

// Gate Current
real Vaux_Igbinv, igbinv, igsd_mult, igsd_mult0, igbs, igbd;
real Voxacc, Vaux_Igbacc, vfbzb, igbacc;
real igcs, igcd, igc0, Vdseffx, T1_exp;
real igisl, igidl, vfbsd, igs, igd, vfgs_eff, vfgd_eff;
real Aechvb, Bechvb, Toxratio, Toxratioedge;
real vgbg, phifs;

// Impact Ionization Current
real Iii;

// I-V Variables
integer devsign, welsign;
real ids, ids0, ids0_ov_dqi;

// C-V Variables
real qs, qd, qfg, qbg;
real IMGTOXP;
real qsi, qdi, qfgi, qbgi;

// Parasitic Capacitances
real qfgs_parasitic, qfgd_parasitic, qfgs_ov, qfgs_of, qfgd_ov, qfgd_of;
real vfgs_ov, vfgd_ov;
real vgd_ov_noswap, vgs_ov_noswap;
real csbox, cdbox, Qsbg, Qdbg;
real vfbsd_bg;

// Back-gate Biasing Effects
real kvbg, dvth_vbg, gamma0, vsubdep0, vsubdep, vknee1, vknee2, bpfactor;

// Flicker Noise
real LINTNOI_i;
real NOIA2_i, MPOWER_i, QSREF_i;
real litl, Esatnoi, Leffnoi, Leffnoisq, DelClm;
real NOIAeff, N0, Nl, Nstar, Ssi, Swi, FNPowerAt1Hz;

// Thermal Noise
real qinv;
real Gtnoi, sid;
real Nt;

// Self-Heating
real gth, cth;
real DevTemp, TMAXK;

// Gate Resistances
real Grgeltd;

// NQS Gate Resistance
real gcrg, XRCRG1_i, XRCRG2_i;
real IdsovVds;

// Binning
real Inv_L, Inv_W, Inv_WL;
real RDSW_i, RDW_i, RSW_i;
real PRWG_i, PRWB_i, WR_i;
real PHIG1_i, PHIG2_i;
real NSD_i, NBODY_i;
real CIT_i, CDSC_i, CDSCD_i, CBGCBG_i;
real BPFACTORPW_i, VKNEE1PW_i, VKNEE2PW_i, DBGPW_i, KBG0PW_i, KBG1PW_i, KBG2PW_i;
real BPFACTORNW_i, VKNEE1NW_i, VKNEE2NW_i, DBGNW_i, KBG0NW_i, KBG1NW_i, KBG2NW_i;
real DSC0_i, DSC1_i, ASCL_i, BSCL_i;
real DVT0_i, DVT1_i, PHIN_i;
real ETA0_i, ETA1_i, ETAB_i, DSUB_i, K1RSCE_i, LPE0_i;
real K0_i, K01_i, K0SI_i, K0SI1_i, MEXP_i;
real PTWG_i, PTWGB_i, PTWGB2_i, PTWGT_i;
real U0_i, UA_i, UC_i, UD_i, UCS_i, EU_i, UTL_i, UTE_i, UA1_i, UD1_i, UCSTE_i, EUB_i, ETAMOB_i;
real U02_i, UA2_i, UC2_i, UD2_i, UCS2_i, EU2_i, EUB2_i, ETAMOB2_i, UP2_i;
real AT_i, ATB_i, PRT_i, IIT_i, TGIDL_i, TGISL_i, IGT_i;
real PCLM_i, PCLMCV_i, DROUT_i, PDIBL1_i, PDIBL2_i, PVAG_i,  ALPHA0_i, ALPHA1_i, BETA0_i;
real AIGC_i, BIGC_i, CIGC_i, PIGCD_i, DIGC_i;
real AGISL_i, BGISL_i, EGISL_i, PGISL_i, AGIDL_i, BGIDL_i, EGIDL_i, PGIDL_i;
real AIGS_i, BIGS_i, CIGS_i, DIGS_i, AIGD_i, BIGD_i, CIGD_i, DIGD_i;
real VBGIDL_i, VBEGIDL_i, VBGISL_i, VBEGISL_i;
real POXEDGE_i, NTOX_i, LOVS_i, LOVD_i, CFS_i, CFD_i;
real VSAT_i, VSATB_i, VSAT1_i, VSATCV_i;
real KSATIV_i, KSUBIV_i, UP_i, KSATIVB_i;
real AIGBINV_i, BIGBINV_i, CIGBINV_i, EIGBINV_i, NIGBINV_i;
real AIGBACC_i, BIGBACC_i, CIGBACC_i, NIGBACC_i;
real K0SISAT_i, K0SISAT1_i;

// New Core

real k1, k2, A0, xg1, xg2, PHISsat, delta, phi2sub;
real f, df;

real q2, phi2;
real qfronts, qfrontd, qbacks, qbackd;
real qtots, qtotd;
real qicores, qicored;

// Newton Method Variables
real q, q1, dq2, qsqrt, dqsqrt;
real dqcoth, dqcothqdqsqrt, qcoth;
real dlogsinhqsqdqsqrt;
real phi1,lnA0,phi1_0,k1_2,PHISsatback2,PHISsatback;
real keq_k2 ;
real qt, auxb1,aaux, coth1;
real csc1;   
// Threshold Operating Point
real qth, qsq1, qsqrt1, qcoth1, Vthop;
real g, dg1, dg2;

// Output Variables
`OPM(ID,      "A",    "Drain Current")
`OPM(IFG,     "A",    "Front Gate Current")
`OPM(IS,      "A",    "Source Current")
`OPM(III,     "A",    "Impact Ionization Current")
`OPM(IGIDL,   "A",    "Gate Induced Drain Leakage Current")
`OPM(IGISL,   "A",    "Gate Induced Source Leakage Current")
`OPM(IDS,     "A",    "Channel Current")
`OPP(VDSSAT,  "V",    "Drain-Source Saturation Voltage")
`OPM(GM,      "A/V",  "Transconductance")
`OPM(GDS,     "A/V",  "Output Conductance")
`OPM(GMBS,    "A/V",  "Body Transconductance")
`OPD(ROUT,    "V/A",  "Output Resistance")
`OPP(VFGS,    "V",    "Front Gate-Source Voltage")
`OPP(VFGD,    "V",    "Front Gate-Drain Voltage")
`OPP(VDS,     "V",    "Drain-Source Voltage")
`OPP(VSBG,    "V",    "Source-Back Gate Voltage")
`OPP(VDBG,    "V",    "Drain-Back Gate Voltage")
`OPM(QFG,     "C",    "Front Gate Charge")
`OPM(QBG,     "C",    "Back Gate Charge")
`OPM(QD,      "C",    "Drain Charge")
`OPM(QS,      "C",    "Source Charge")
`OPM(CFGD,    "F",    "Total fg-d MOSFET Capacitance")
`OPM(CFGFG,   "F",    "Total fg-fg MOSFET Capacitance")
`OPM(CFGS,    "F",    "Total fg-s MOSFET Capacitance")
`OPM(CFGBG,   "F",    "Total fg-bg MOSFET Capacitance")
`OPM(CBGD,    "F",    "Total bg-d MOSFET Capacitance")
`OPM(CBGFG,   "F",    "Total bg-fg MOSFET Capacitance")
`OPM(CBGS,    "F",    "Total bg-s MOSFET Capacitance")
`OPM(CBGBG,   "F",    "Total bg-bg MOSFET Capacitance")
`OPM(CDD,     "F",    "Total d-d MOSFET Capacitance")
`OPM(CDFG,    "F",    "Total d-fg MOSFET Capacitance")
`OPM(CDS,     "F",    "Total d-s MOSFET Capacitance")
`OPM(CDBG,    "F",    "Total d-bg MOSFET Capacitance")
`OPM(CSBG,    "F",    "Total s-bg MOSFET Capacitance")
`OPM(CSFG,    "F",    "Total s-fg MOSFET Capacitance")
`OPM(QFGI,    "C",    "Intrinsic Front Gate Charge")
`OPM(QBGI,    "C",    "Intrinsic Back Gate Charge")
`OPM(QDI,     "C",    "Intrinsic Drain Charge")
`OPM(QSI,     "C",    "Intrinsic Source Charge")
`OPM(CFGDI,   "F",    "Intrinsic fg-d MOSFET Capacitance")
`OPM(CFGFGI,  "F",    "Intrinsic fg-fg MOSFET Capacitance")
`OPM(CFGSI,   "F",    "Intrinsic fg-s MOSFET Capacitance")
`OPM(CSFGI,   "F",    "Intrinsic s-fg MOSFET Capacitance")
`OPM(CFGBGI,  "F",    "Intrinsic fg-bg MOSFET Capacitance")
`OPM(CBGDI,   "F",    "Intrinsic bg-d MOSFET Capacitance")
`OPM(CBGFGI,  "F",    "Intrinsic bg-fg MOSFET Capacitance")
`OPM(CBGSI,   "F",    "Intrinsic bg-s MOSFET Capacitance")
`OPM(CSBGI,   "F",    "Intrinsic s-bg MOSFET Capacitance")
`OPM(CBGBGI,  "F",    "Intrinsic bg-bg MOSFET Capacitance")
`OPM(CDDI,    "F",    "Intrinsic d-d MOSFET Capacitance")
`OPM(CDFGI,   "F",    "Intrinsic d-fg MOSFET Capacitance")
`OPM(CDSI,    "F",    "Intrinsic d-s MOSFET Capacitance")
`OPM(CDBGI,   "F",    "Intrinsic d-bg MOSFET Capacitance")
`OPP(VTH,         "V",                  "Threshold Voltage")
`OPP(T_TOTAL_K,   "Kelvin",             "Device temperature in Kelvin" )
`OPP(T_TOTAL_C,   "Celsius",            "Device temperature in Celsius" )
`OPP(T_DELTA_SH,  "Kelvin or Celsius",  "Delta temperature by self-heating" )

analog begin

    // ***************************************
    // **  Geometry-Dependent Calculations  **
    // ***************************************

    // Variable Initialization
        Rdrain  = 0.0;
        Rsource = 0.0;
        gspr    = 0.0;
        gdpr    = 0.0;
        Grgeltd = 0.0;

    if ($port_connected(t) == 1) begin
        if (SHMOD == 0 || RTH0 == 0.0) begin
            $strobe("The optional 5th terminal is present but not active because SHMOD = 0 or RTH0 = 0.0");
        end
    end

    if (TYPE == `ntype) begin
        devsign = 1;
    end else begin
        devsign = -1;
    end

    if (WELLTYPE == `ntype) begin
        welsign = 1;
    end else begin
        welsign = -1;
    end

    // Constants
    epssi = EPSRSUB * `EPS0;

    // W calculation for different NFMOD options
    if (NFMOD == 0) begin
        Wnew = W / NF;
    end else begin
        Wnew = W;
    end

    //Leff and Weff for IV and CV
    Lnew        = L + XL;
    Wnew        = Wnew + XW;
    L_LLN       = pow(Lnew, -LLN);
    W_LWN       = pow(Wnew, -LWN);
    LW_LLN_LWN  = L_LLN * W_LWN;
    dLIV        = LINT + LL * L_LLN + LW * W_LWN + LWL * LW_LLN_LWN;
    L_WLN       = pow(Lnew, -WLN);
    W_WWN       = pow(Wnew, -WWN);
    LW_WLN_WWN  = L_WLN * W_WWN;
    dWIV        = WINT + WL * L_WLN + WW * W_WWN + WWL * LW_WLN_WWN;

    Leff = Lnew - 2.0 * dLIV;
    if (Leff <= 0.0) begin
        $strobe("Fatal: Effective channel length = %e for %M is non-positive", Leff);
        $finish(0);
    end else if (Leff <= 1.0e-9) begin
        $strobe("Warning: Effective channel length = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", Leff);
    end

    Weff = Wnew - 2.0 * dWIV;
    if (Weff <= 0) begin
        $strobe("Fatal: Effective channel Width = %e for %M is non-positive", Weff);
        $finish(0);
    end else if (Weff<=1.0e-9) begin
        $strobe("Warning: Effective channel width = %e for %M is <= 1.0e-9. Recommended Weff >= 1e-8", Leff);
    end

    // Leff and Weff for CV
    dLCV   = DLC + LLC * L_LLN + LWC * W_LWN + LWLC * LW_LLN_LWN;
    dWCV   = DWC + WLC * L_WLN + WWC * W_WWN + WWLC * LW_WLN_WWN;
    LeffCV = Lnew - 2.0 * dLCV;

    if (LeffCV <= 0.0) begin
        $strobe("Fatal: Effective channel length for CV = %e for %M is non-positive", LeffCV);
        $finish(0);
    end else if (LeffCV <= 1.0e-9) begin
        $strobe("Warning: Effective channel length for CV = %e for %M is <= 1.0e-9. Recommended Leff >= 1e-8", LeffCV);
    end

    WeffCV = Wnew - 2.0 * dWCV;
    if (WeffCV <= 0.0) begin
        $strobe("Fatal: Effective channel width for CV = %e for %M is non-positive", WeffCV);
        $finish(0);
    end else if (WeffCV <= 1.0e-9) begin
        $strobe("Warning: Effective channel width for CV = %e for %M is <= 1.0e-9. Recommended Weff >= 1e-8", WeffCV);
    end

    // Binning
    Inv_L  = 1.0e-6 / Leff;
    Inv_W  = 1.0e-6 / Weff;
    Inv_WL = Inv_L * Inv_W;

    // Binning Calculations
    RDSW_i     = RDSW + LRDSW * Inv_L + WRDSW * Inv_W + PRDSW * Inv_WL;
    RDW_i      = RDW + LRDW * Inv_L + WRDW * Inv_W + PRDW * Inv_WL;
    RSW_i      = RSW + LRSW * Inv_L + WRSW * Inv_W + PRSW * Inv_WL;
    PRWG_i     = PRWG + LPRWG * Inv_L + WPRWG * Inv_W + PPRWG * Inv_WL;
    PRWB_i     = PRWB + LPRWB * Inv_L + WPRWB * Inv_W + PPRWB * Inv_WL;
    WR_i       = WR + LWR * Inv_L + WWR * Inv_W + PWR * Inv_WL;
    PHIG1_i    = PHIG1 + LPHIG1 * Inv_L + WPHIG1 * Inv_W + PPHIG1 * Inv_WL;
    PHIG2_i    = PHIG2 + LPHIG2 * Inv_L + WPHIG2 * Inv_W + PPHIG2 * Inv_WL;
    NSD_i      = NSD + LNSD * Inv_L + WNSD * Inv_W + PNSD * Inv_WL;
    NBODY_i    = NBODY + LNBODY * Inv_L + WNBODY * Inv_W + PNBODY * Inv_WL;
    CIT_i      = CIT + LCIT * Inv_L + WCIT * Inv_W + PCIT * Inv_WL;
    CDSC_i     = CDSC + LCDSC * Inv_L + WCDSC * Inv_W + PCDSC * Inv_WL;
    CDSCD_i    = CDSCD + LCDSCD * Inv_L + WCDSCD * Inv_W + PCDSCD * Inv_WL;
    CBGCBG_i   = CBGCBG + LCBGCBG * Inv_L + WCBGCBG * Inv_W + PCBGCBG * Inv_WL;
    BPFACTORPW_i = BPFACTORPW + LBPFACTORPW * Inv_L + WBPFACTORPW * Inv_W + PBPFACTORPW * Inv_WL;
    NOIA2_i    = NOIA2 + LNOIA2 * Inv_L + WNOIA2 * Inv_W + PNOIA2 * Inv_WL;
    QSREF_i    = QSREF + LQSREF * Inv_L + WQSREF * Inv_W + PQSREF * Inv_WL;
    MPOWER_i   = MPOWER + LMPOWER * Inv_L + WMPOWER * Inv_W + PMPOWER * Inv_WL;
   
    if (BPFACTORPW_i < 0.0) begin
        $strobe("Warning: BPFACTORPW_i = %e is negative. Set to 0.0.", BPFACTORPW_i);
        BPFACTORPW_i = 0.0;
    end else if (BPFACTORPW_i > 1.0) begin
        $strobe("Warning: BPFACTORPW_i = %e is larger than 1.0. Set to 1.0.", BPFACTORPW_i);
        BPFACTORPW_i = 1.0;
    end
    
    VKNEE1PW_i   = VKNEE1PW + LVKNEE1PW * Inv_L + WVKNEE1PW * Inv_W + PVKNEE1PW * Inv_WL;
    VKNEE2PW_i   = VKNEE2PW + LVKNEE2PW * Inv_L + WVKNEE2PW * Inv_W + PVKNEE2PW * Inv_WL;
    DBGPW_i      = DBGPW + LDBGPW * Inv_L + WDBGPW * Inv_W + PDBGPW * Inv_WL;
    KBG0PW_i     = KBG0PW + LKBG0PW * Inv_L + WKBG0PW * Inv_W + PKBG0PW * Inv_WL;
    KBG1PW_i     = KBG1PW + LKBG1PW * Inv_L + WKBG1PW * Inv_W + PKBG1PW * Inv_WL;
    KBG2PW_i     = KBG2PW + LKBG2PW * Inv_L + WKBG2PW * Inv_W + PKBG2PW * Inv_WL;
    BPFACTORNW_i = BPFACTORNW + LBPFACTORNW * Inv_L + WBPFACTORNW * Inv_W + PBPFACTORNW * Inv_WL;
    
    if (BPFACTORNW_i < 0.0) begin
        $strobe("Warning: BPFACTORNW_i = %e is negative. Set to 0.0.", BPFACTORNW_i);
        BPFACTORNW_i = 0.0;
    end else if (BPFACTORNW_i > 1.0) begin
        $strobe("Warning: BPFACTORNW_i = %e is larger than 1.0. Set to 1.0.", BPFACTORNW_i);
        BPFACTORNW_i = 1.0;
    end
    
    VKNEE1NW_i = VKNEE1NW + LVKNEE1NW * Inv_L + WVKNEE1NW * Inv_W + PVKNEE1NW * Inv_WL;
    VKNEE2NW_i = VKNEE2NW + LVKNEE2NW * Inv_L + WVKNEE2NW * Inv_W + PVKNEE2NW * Inv_WL;
    DBGNW_i    = DBGNW + LDBGNW * Inv_L + WDBGNW * Inv_W + PDBGNW * Inv_WL;
    KBG0NW_i   = KBG0NW + LKBG0NW * Inv_L + WKBG0NW * Inv_W + PKBG0NW * Inv_WL;
    KBG1NW_i   = KBG1NW + LKBG1NW * Inv_L + WKBG1NW * Inv_W + PKBG1NW * Inv_WL;
    KBG2NW_i   = KBG2NW + LKBG2NW * Inv_L + WKBG2NW * Inv_W + PKBG2NW * Inv_WL;
    DVT0_i     = DVT0 + LDVT0 * Inv_L + WDVT0 * Inv_W + PDVT0 * Inv_WL;
    DVT1_i     = DVT1 + LDVT1 * Inv_L + WDVT1 * Inv_W + PDVT1 * Inv_WL;
    PHIN_i     = PHIN + LPHIN * Inv_L + WPHIN * Inv_W + PPHIN * Inv_WL;
    ETA0_i     = ETA0 + LETA0 * Inv_L + WETA0 * Inv_W + PETA0 * Inv_WL;
    ETA1_i     = ETA1 + LETA1 * Inv_L + WETA1 * Inv_W + PETA1 * Inv_WL;
    ETAB_i     = ETAB + LETAB * Inv_L + WETAB * Inv_W + PETAB * Inv_WL;
    DSUB_i     = DSUB + LDSUB * Inv_L + WDSUB * Inv_W + PDSUB * Inv_WL;
    DSC0_i     = DSC0 + LDSC0 * Inv_L + WDSC0* Inv_W + PDSC0 * Inv_WL;
    DSC1_i     = DSC1 + LDSC1 * Inv_L + WDSC1* Inv_W + PDSC1 * Inv_WL;
    ASCL_i     = ASCL + LASCL * Inv_L + WASCL * Inv_W + PASCL * Inv_WL;
    BSCL_i     = BSCL + LBSCL * Inv_L + WBSCL * Inv_W + PBSCL * Inv_WL;
    K1RSCE_i   = K1RSCE + LK1RSCE * Inv_L + WK1RSCE * Inv_W + PK1RSCE * Inv_WL;
    LPE0_i     = LPE0 + LLPE0 * Inv_L + WLPE0 * Inv_W + PLPE0 * Inv_WL;
    MEXP_i     = MEXP + LMEXP * Inv_L + WMEXP * Inv_W + PMEXP * Inv_WL;
    K0_i       = K0 + LK0 * Inv_L + WK0 * Inv_W + PK0 * Inv_WL;
    K01_i      = K01 + LK01 * Inv_L + WK01 * Inv_W + PK01 * Inv_WL;
    K0SI_i     = K0SI + LK0SI * Inv_L + WK0SI * Inv_W + PK0SI * Inv_WL;
    K0SI1_i    = K0SI1 + LK0SI1 * Inv_L + WK0SI1 * Inv_W + PK0SI1 * Inv_WL;
    K0SISAT_i  = K0SISAT + LK0SISAT * Inv_L + NK0SISAT * Inv_W + PK0SISAT * Inv_WL;
    K0SISAT1_i = K0SISAT1 + LK0SISAT1 * Inv_L + NK0SISAT1 * Inv_W + PK0SISAT1 * Inv_WL;
    PTWG_i     = PTWG + LPTWG * Inv_L + WPTWG * Inv_W + PPTWG * Inv_WL;
    PTWGB_i    = PTWGB + LPTWGB * Inv_L + WPTWGB * Inv_W + PPTWGB * Inv_WL;
    PTWGB2_i   = PTWGB2 + LPTWGB2 * Inv_L + WPTWGB2 * Inv_W + PPTWGB2 * Inv_WL;
    PTWGT_i    = PTWGT + LPTWGT * Inv_L + WPTWGT * Inv_W + PPTWGT * Inv_WL;
    U0_i       = U0 + LU0 * Inv_L + WU0 * Inv_W + PU0 * Inv_WL;
    UA_i       = UA + LUA * Inv_L + WUA * Inv_W + PUA * Inv_WL;
    UC_i       = UC + LUC * Inv_L + WUC * Inv_W + PUC * Inv_WL;
    UD_i       = UD + LUD * Inv_L + WUD * Inv_W + PUD * Inv_WL;
    UCS_i      = UCS + LUCS * Inv_L + WUCS * Inv_W + PUCS * Inv_WL;
    EU_i       = EU + LEU * Inv_L + WEU * Inv_W + PEU * Inv_WL;
    EUB_i      = EUB + LEUB * Inv_L + WEUB * Inv_W + PEUB * Inv_WL;	
    UTL_i      = UTL + LUTL * Inv_L + WUTL * Inv_W + PUTL * Inv_WL;
    UTE_i      = UTE + LUTE * Inv_L + WUTE * Inv_W + PUTE * Inv_WL;
    UA1_i      = UA1 + LUA1 * Inv_L + WUA1 * Inv_W + PUA1 * Inv_WL;
    UD1_i      = UD1 + LUD1 * Inv_L + WUD1 * Inv_W + PUD1 * Inv_WL;
    UCSTE_i    = UCSTE + LUCSTE * Inv_L + WUCSTE * Inv_W + PUCSTE * Inv_WL;
    ETAMOB_i   = ETAMOB + LETAMOB * Inv_L + WETAMOB * Inv_W + PETAMOB * Inv_WL;
    U02_i      = U02 + LU02 * Inv_L + WU02 * Inv_W + PU02 * Inv_WL;
    UA2_i      = UA2 + LUA2 * Inv_L + WUA2 * Inv_W + PUA2 * Inv_WL;
    UC2_i      = UC2 + LUC2 * Inv_L + WUC2 * Inv_W + PUC2 * Inv_WL;
    UD2_i      = UD2 + LUD2 * Inv_L + WUD2 * Inv_W + PUD2 * Inv_WL;
    UCS2_i     = UCS2 + LUCS2 * Inv_L + WUCS2 * Inv_W + PUCS2 * Inv_WL;
    EU2_i      = EU2 + LEU2 * Inv_L + WEU2 * Inv_W + PEU2 * Inv_WL;
    EUB2_i     = EUB2 + LEUB2 * Inv_L + WEUB2 * Inv_W + PEUB2 * Inv_WL;
    ETAMOB2_i  = ETAMOB2 + LETAMOB2 * Inv_L + WETAMOB2 * Inv_W + PETAMOB2 * Inv_WL;
    AT_i       = AT + LAT * Inv_L + WAT * Inv_W + PAT * Inv_WL;
    ATB_i      = ATB + LATB * Inv_L + WATB * Inv_W + PATB * Inv_WL;
    PRT_i      = PRT + LPRT * Inv_L + WPRT * Inv_W + PPRT * Inv_WL;
    IIT_i      = IIT + LIIT * Inv_L + WIIT * Inv_W + PIIT * Inv_WL;
    TGIDL_i    = TGIDL + LTGIDL * Inv_L + WTGIDL * Inv_W + PTGIDL * Inv_WL;
    TGISL_i    = TGISL + LTGISL * Inv_L + WTGISL * Inv_W + PTGISL * Inv_WL;
    IGT_i      = IGT + LIGT * Inv_L + WIGT * Inv_W + PIGT * Inv_WL;
    PCLM_i     = PCLM + LPCLM * Inv_L + WPCLM * Inv_W + PPCLM * Inv_WL;
    PCLMCV_i   = PCLMCV + LPCLMCV * Inv_L + WPCLMCV * Inv_W + PPCLMCV * Inv_WL;
    DROUT_i    = DROUT + LDROUT * Inv_L + WDROUT * Inv_W + PDROUT * Inv_WL;
    PDIBL1_i   = PDIBL1 + LPDIBL1 * Inv_L + WPDIBL1 * Inv_W + PPDIBL1 * Inv_WL;
    PDIBL2_i   = PDIBL2 + LPDIBL2 * Inv_L + WPDIBL2 * Inv_W + PPDIBL2 * Inv_WL;
    PVAG_i     = PVAG + LPVAG * Inv_L + WPVAG * Inv_W + PPVAG * Inv_WL;
    ALPHA0_i   = ALPHA0 + LALPHA0 * Inv_L + WALPHA0 * Inv_W + PALPHA0 * Inv_WL;
    ALPHA1_i   = ALPHA1 + LALPHA1 * Inv_L + WALPHA1 * Inv_W + PALPHA1 * Inv_WL;
    BETA0_i    = BETA0 + LBETA0 * Inv_L + WBETA0 * Inv_W + PBETA0 * Inv_WL;
    AIGBINV_i  = AIGBINV + Inv_L * LAIGBINV + Inv_W * WAIGBINV + Inv_WL * PAIGBINV;
    BIGBINV_i  = BIGBINV + Inv_L * LBIGBINV + Inv_W * WBIGBINV + Inv_WL * PBIGBINV;
    CIGBINV_i  = CIGBINV + Inv_L * LCIGBINV + Inv_W * WCIGBINV + Inv_WL * PCIGBINV;
    EIGBINV_i  = EIGBINV + Inv_L * LEIGBINV + Inv_W * WEIGBINV + Inv_WL * PEIGBINV;
    NIGBINV_i  = NIGBINV + Inv_L * LNIGBINV + Inv_W * WNIGBINV + Inv_WL * PNIGBINV;
    AIGBACC_i  = AIGBACC + Inv_L * LAIGBACC + Inv_W * WAIGBACC + Inv_WL * PAIGBACC;
    BIGBACC_i  = BIGBACC + Inv_L * LBIGBACC + Inv_W * WBIGBACC + Inv_WL * PBIGBACC;
    CIGBACC_i  = CIGBACC + Inv_L * LCIGBACC + Inv_W * WCIGBACC + Inv_WL * PCIGBACC;
    NIGBACC_i  = NIGBACC + Inv_L * LNIGBACC + Inv_W * WNIGBACC + Inv_WL * PNIGBACC;
    AIGC_i     = AIGC + LAIGC * Inv_L + WAIGC * Inv_W + PAIGC * Inv_WL;
    BIGC_i     = BIGC + LBIGC * Inv_L + WBIGC * Inv_W + PBIGC * Inv_WL;
    CIGC_i     = CIGC + LCIGC * Inv_L + WCIGC * Inv_W + PCIGC * Inv_WL;
    DIGC_i     = DIGC + LDIGC * Inv_L + WDIGC * Inv_W + PDIGC * Inv_WL;
    PIGCD_i    = PIGCD + LPIGCD * Inv_L + WPIGCD * Inv_W + PPIGCD * Inv_WL;
    PGIDL_i    = PGIDL + LPGIDL * Inv_L + WPGIDL * Inv_W + PPGIDL * Inv_WL;
    AGISL_i    = AGISL + LAGISL * Inv_L + WAGISL * Inv_W + PAGISL * Inv_WL;
    BGISL_i    = BGISL + LBGISL * Inv_L + WBGISL * Inv_W + PBGISL * Inv_WL;
    EGISL_i    = EGISL + LEGISL * Inv_L + WEGISL * Inv_W + PEGISL * Inv_WL;
    PGISL_i    = PGISL + LPGISL * Inv_L + WPGISL * Inv_W + PPGISL * Inv_WL;
    AGIDL_i    = AGIDL + LAGIDL * Inv_L + WAGIDL * Inv_W + PAGIDL * Inv_WL;
    BGIDL_i    = BGIDL + LBGIDL * Inv_L + WBGIDL * Inv_W + PBGIDL * Inv_WL;
    EGIDL_i    = EGIDL + LEGIDL * Inv_L + WEGIDL * Inv_W + PEGIDL * Inv_WL;
    VBGIDL_i   = VBGIDL + LVBGIDL * Inv_L + WVBGIDL * Inv_W + PVBGIDL * Inv_WL;
    VBGISL_i   = VBGISL + LVBGISL * Inv_L + WVBGISL * Inv_W + PVBGISL * Inv_WL;
    VBEGIDL_i  = VBEGIDL + LVBEGIDL * Inv_L + WVBEGIDL * Inv_W + PVBEGIDL * Inv_WL;
    VBEGISL_i  = VBEGISL + LVBEGISL * Inv_L + WVBEGISL * Inv_W + PVBEGISL * Inv_WL;
    AIGS_i     = AIGS + LAIGS * Inv_L + WAIGS * Inv_W + PAIGS * Inv_WL;
    BIGS_i     = BIGS + LBIGS * Inv_L + WBIGS * Inv_W + PBIGS * Inv_WL;
    CIGS_i     = CIGS + LCIGS * Inv_L + WCIGS * Inv_W + PCIGS * Inv_WL;
    DIGS_i     = DIGS + LDIGS * Inv_L + WDIGS * Inv_W + PDIGS * Inv_WL;
    AIGD_i     = AIGD + LAIGD * Inv_L + WAIGD * Inv_W + PAIGD * Inv_WL;
    BIGD_i     = BIGD + LBIGD * Inv_L + WBIGD * Inv_W + PBIGD * Inv_WL;
    CIGD_i     = CIGD + LCIGD * Inv_L + WCIGD * Inv_W + PCIGD * Inv_WL;
    DIGD_i     = DIGD + LDIGD * Inv_L + WDIGD * Inv_W + PDIGD * Inv_WL;
    NTOX_i     = NTOX + LNTOX * Inv_L + WNTOX * Inv_W + PNTOX * Inv_WL;
    POXEDGE_i  = POXEDGE + LPOXEDGE * Inv_L + WPOXEDGE * Inv_W + PPOXEDGE * Inv_WL;
    LOVS_i     = LOVS + LLOVS * Inv_L + WLOVS * Inv_W + PLOVS * Inv_WL;
    LOVD_i     = LOVD + LLOVD * Inv_L + WLOVD * Inv_W + PLOVD * Inv_WL;
    CFS_i      = CFS + LCFS * Inv_L + WCFS * Inv_W + PCFS * Inv_WL;
    CFD_i      = CFD + LCFD * Inv_L + WCFD * Inv_W + PCFD * Inv_WL;
    VSAT_i     = VSAT + LVSAT * Inv_L + WVSAT * Inv_W + PVSAT * Inv_WL;
    VSATB_i    = VSATB + LVSATB * Inv_L + WVSATB * Inv_W + PVSATB * Inv_WL;
    VSAT1_i    = VSAT1 + LVSAT1 * Inv_L + WVSAT1 * Inv_W + PVSAT1 * Inv_WL;
    VSATCV_i   = VSATCV + LVSATCV * Inv_L + WVSATCV * Inv_W + PVSATCV * Inv_WL;
    KSATIV_i   = KSATIV + LKSATIV * Inv_L + WKSATIV * Inv_W + PKSATIV * Inv_WL;
    KSUBIV_i   = KSUBIV + LKSUBIV * Inv_L + WKSUBIV * Inv_W + PKSUBIV * Inv_WL;
    KSATIVB_i  = KSATIVB + LKSATIVB * Inv_L + WKSATIVB * Inv_W + PKSATIVB * Inv_WL;
    UP_i       = UP + LUP * Inv_L + WUP * Inv_W + PUP * Inv_WL;
    UP2_i      = UP2 + LUP2 * Inv_L + WUP2 * Inv_W + PUP2 * Inv_WL;
    QMTCENCV_i = QMTCENCV + LQMTCENCV * Inv_L + WQMTCENCV * Inv_W + PQMTCENCV * Inv_WL;
    ETAQM_i    = ETAQM + LETAQM * Inv_L + WETAQM * Inv_W + PETAQM * Inv_WL; 
    QM0_i      = QM0 + LQM0 * Inv_L + WQM0 * Inv_W + PQM0 * Inv_WL; 
    PQM_i      = PQM + LPQM * Inv_L + WPQM * Inv_W + PPQM * Inv_WL;

    if (NQSMOD == 1 && XRCRG1 != 0.0) begin
        XRCRG1_i = XRCRG1 + LXRCRG1 * Inv_L + WXRCRG1 * Inv_W + PXRCRG1 * Inv_WL;
        XRCRG2_i = XRCRG2 + LXRCRG2 * Inv_L + WXRCRG2 * Inv_W + PXRCRG2 * Inv_WL;
    end else begin
        XRCRG1_i = 0.0;
        XRCRG2_i = 0.0;
    end

    cox1     = 3.9 * `EPS0 / EOT1;
    cox1P    = 3.9 * `EPS0 / EOT1P;
    cox2     = 3.9 * `EPS0 / EOT2;
    csi      = epssi / TSI;
    epsratio = EPSRSUB / 3.9;

    // Physical Oxide Thickness
    if (!$param_given(EOT1P)) begin
        IMGTOXP = (EOT1 * EPSROX1 / 3.9) - DTOX1;
    end else begin
        IMGTOXP = EOT1P;
    end

    // Geometrical Scaling
    if (LPA > 0.0) begin
        U0_i = U0_i * (1.0 - UP_i * pow(Leff, -LPA));
    end else begin
        U0_i = U0_i * (1.0 - UP_i);
    end

    UA_i    = UA_i + AUA * lexp(-Leff / BUA);
    UC_i    = UC_i + AUC * lexp(-Leff / BUC);
    UDB_i   = UDB + AUDB * lexp(-Leff / BUDB);
    UD_i    = UD_i + AUD * lexp(-Leff / BUD);
    EU_i    = EU_i + AEU * lexp(-Leff / BEU);
    EUB_i   = EUB_i + AEUB * lexp(-Leff / BEUB);

    if (LPA2 > 0.0) begin
        U02_i = U02_i * (1.0 - UP2_i * pow(Leff, -LPA2));
    end else begin
        U02_i = U02_i * (1.0 - UP2_i);
    end

    UA2_i    = UA2_i + AUA2 * lexp(-Leff / BUA2);
    UC2_i    = UC2_i + AUC2 * lexp(-Leff / BUC2);
    UDB2_i   = UDB2 + AUDB2 * lexp(-Leff / BUDB2);
    UD2_i    = UD2_i + AUD2 * lexp(-Leff / BUD2);
    EU2_i    = EU2_i + AEU2 * lexp(-Leff / BEU2);
    EUB2_i   = EUB2_i + AEUB2 * lexp(-Leff / BEUB2);
	
    if (RDSMOD == 1) begin
        RSW_i = RSW_i + ARSW * lexp(-Leff / BRSW);
        RDW_i = RDW_i + ARDW * lexp(-Leff / BRDW);
    end else begin
    RDSW_i = RDSW_i + ARDSW * lexp(-Leff / BRDSW);
    end

    PCLM_i   = PCLM_i + APCLM * lexp(-Leff / BPCLM);
    MEXP_i   = MEXP_i + AMEXP * pow(Leff * 1.0e6, -BMEXP);
    PTWG_i   = PTWG_i + APTWG * lexp(-Leff / BPTWG);
    PTWGB_i  = PTWGB_i + APTWGB * lexp(-Leff / BPTWGB);
    PTWGB2_i = PTWGB2_i + APTWGB2 * lexp(-Leff / BPTWGB2);
    VSAT_i   = VSAT_i + AVSAT * lexp(-Leff / BVSAT);
    VSATB_i  = VSATB_i + AVSATB * lexp(-Leff / BVSATB);
    VSAT1_i  = VSAT1_i + AVSAT1 * lexp(-Leff / BVSAT1);
    VSATCV_i = VSATCV_i + AVSATCV * lexp(-Leff / BVSATCV);

    // Scaling for DITS Parameters
    DVTP0_i = DVTP0 + ADVTP0 * lexp(-Leff / BDVTP0);
    DVTP1_i = DVTP1 + ADVTP1 * lexp(-Leff / BDVTP1);

    // **************************
    // **  Parameter Checking  **
    // **************************

    begin: ParameterCheck
        if (U0_i < 0.0) begin
            $strobe("Warning: U0_i = %e is negative, setting it to default value", U0_i);
            U0_i = 0.03;
        end

        if (UA_i < 0.0) begin
            $strobe("Warning: UA_i = %e is negative, setting it to 0.", UA_i);
            UA_i = 0.0;
        end

        if (EU_i < 0.0) begin
            $strobe("Warning: EU_i = %e is negative, setting it to 0.", EU_i);
            EU_i = 0.0;
        end

        if (UD_i < 0.0) begin
            $strobe("Warning: UD_i = %e is negative, setting it to 0.", UD_i);
            UD_i = 0.0;
        end

        if (UCS_i < 0.0) begin
            $strobe("Warning: UCS_i = %e is negative, setting it to 0.", UCS_i);
            UCS_i = 0.0;
        end

        if (VSATB_i < 0.0) begin
            $strobe("Warning: VSATB_i = %e is negative, setting it to 0.", VSATB_i);
            VSATB_i = 0.0;
        end

        if (DVT1_i <= 0.0) begin
            $strobe("Fatal: DVT1_i = %e is not positive.", DVT1_i);
            $finish(0);
        end

        if (DSUB_i <= 0.0) begin
            $strobe("Fatal: DSUB_i = %e is not positive.", DSUB_i);
            $finish(0);
        end

        RDSWMIN_i = RDSWMIN;
        if (RDSWMIN_i < 0.0) begin
            $strobe("Warning: RDSWMIN = %e is negative, setting it to 0.", RDSWMIN_i);
            RDSWMIN_i = 0.0;
        end

        if (RDSW_i < 0.0) begin
            $strobe("Warning: RDSW_i = %e is negative, setting it to 0.", RDSW_i);
            RDSW_i = 0.0;
        end

        RSWMIN_i = RSWMIN;
        if (RSWMIN_i < 0.0) begin
            $strobe("Warning: RSWMIN = %e is negative, setting it to 0.", RSWMIN_i);
            RSWMIN_i = 0.0;
        end

        if (RSW_i < 0.0) begin
            $strobe("Warning: RSW_i = %e is negative, setting it to 0.", RSW_i);
            RSW_i = 0.0;
        end

        RDWMIN_i = RDWMIN;
        if (RDWMIN_i < 0.0) begin
            $strobe("Warning: RDWMIN = %e is negative, setting it to 0.", RDWMIN_i);
            RDWMIN_i = 0.0;
        end

        if (RDW_i < 0.0) begin
            $strobe("Warning: RDW_i = %e is negative, setting it to 0.", RDW_i);
            RDW_i = 0.0;
        end

        if (PRWG_i < 0.0) begin
            $strobe("Warning: PRWG_i = %e is negative, setting it to 0.", PRWG_i);
            PRWG_i = 0.0;
        end

        if (PDIBL1_i < 0.0) begin
            $strobe("Warning: PDIBL1_i = %e is negative.", PDIBL1_i);
        end

        if (PDIBL2_i < 0.0) begin
            $strobe("Warning: PDIBL2_i = %e is negative.", PDIBL2_i);
        end

        if (DROUT_i <= 0.0) begin
            $strobe("Warning: DROUT_i = %e is not positive.", DROUT_i);
        end

        if (MEXP_i < 2.0) begin
            $strobe("Warning: MEXP_i = %e < 2. Set MEXP_i to 2.", MEXP_i);
            MEXP_i = 2.0;
        end

    end

    // Short Channel Effects
    Theta_RSCE = sqrt(1.0 + LPE0_i / Leff) - 1.0;
    teff       = TSI + epsratio * (EOT1 + EOT2);

    // Variable to be used in Drain Saturation Voltage
    inv_MEXP = 1.0 / MEXP_i;

    // Source/drain to substrate parasitic capacitances
    csbox = cox2 * AS;
    cdbox = cox2 * AD;
    T0    = CSDBGSW * lln(1.0 + TSI / EOT2);
    csbox = csbox + T0 * max(PS - W, 0.0);
    cdbox = cdbox + T0 * max(PD - W, 0.0);

    // For better convergence
    csbox = max(csbox, 0.01e-18);
    cdbox = max(cdbox, 0.01e-18);

    // Mobility Degradation
    eta_mu    = 0.5 * ETAMOB_i;
    eta_mu_cv = 0.5;
    eta_mu2   = 0.5 * ETAMOB2_i;
	
    if (TYPE != `ntype) begin
        eta_mu    = 1.0 / 3.0 * ETAMOB_i;
        eta_mu_cv = 1.0 / 3.0;
        eta_mu2   = 1.0 / 3.0 * ETAMOB2_i;
    end

    EeffFactor   = 1.0e-8 / (epsratio * EOT1);
    WeffWRFactor = 1.0 / (pow((Weff) * 1.0e6, WR_i) * NF);
    litl         = sqrt(epsratio * EOT1 * TSI);
    EeffFactor2  = 1.0e-8 / (epsratio * EOT2);

    if (LINTNOI >= Leff / 2.0) begin
        $strobe("Warning: LINTNOI = %e is too large - Leff for noise is negative. Re-setting LINTNOI = 0.", LINTNOI);
        LINTNOI_i = 0.0;
    end else begin
        LINTNOI_i = LINTNOI;
    end

    // Self-heating Model
    if((SHMOD != 0) && (RTH0 > 0.0)) begin
        gth = (WTH0 + Weff * NF) / RTH0;
        cth = CTH0 * (WTH0 + Weff * NF);
    end else begin
        // set gth to some value to prevent a singular G matrix
        gth = 1.0;
        cth = 0.0;
    end

    // Geometry dependent Source/Drain Resistance
    RSourceGeo = RSHS * NRS;
    RDrainGeo  = RSHD * NRD;

    // Clamping of Source/Drain Resistances
    if (RSourceGeo <= 1.0e-3) begin
        RSourceGeo = 1.0e-3;
    end

    if (RDrainGeo <= 1.0e-3) begin
        RDrainGeo = 1.0e-3;
    end

    if (RDSMOD == 1) begin
        if (RSWMIN_i <= 0.0) begin
            RSWMIN_i = 0.0;
        end

        if (RDWMIN_i <= 0.0) begin
            RDWMIN_i = 0.0;
        end

        if (RSW_i <= 0.0) begin
            RSW_i = 0.0;
        end

        if (RDW_i <= 0.0) begin
            RDW_i = 0.0;
        end
    end else begin
        if (RDSWMIN_i <= 0.0) begin
            RDSWMIN_i = 0.0;
        end

        if (RDSW_i <= 0.0) begin
            RDSW_i = 0.0;
        end
    end

    // Tnom
    if (TNOM <= 0.0) begin
        $strobe("Warning: TNOM = %e is not positive. Set to 300.15 K.", TNOM);
        Tnom = `REFTEMP;
    end else begin
        Tnom = TNOM + `P_CELSIUS0;
    end

    // Gate Current
    if (TYPE == `ntype) begin
        Aechvb = 4.97232e-7;  // NMOS
    end else begin
        Aechvb = 3.42537e-7;  // PMOS
    end

    if (TYPE == `ntype) begin
        Bechvb = 7.45669e11;  // NMOS
    end else begin
        Bechvb = 1.16645e12;  // PMOS
    end

    T0 = TOXP * TOXP;
    T1 = TOXP * POXEDGE_i;
    T2 = T1 * T1;

    Toxratio     = lexp(NTOX_i * lln(TOXREF / TOXP)) / T0;
    Toxratioedge = lexp(NTOX_i * lln(TOXREF / T1)) / T2;
    igsd_mult0   = Weff * Aechvb * Toxratioedge;

    // Gate Resistance
    Grgeltd = RSHG * (XGW + Weff / 3.0 / NGCON) / (NGCON * NF * (Lnew - XGL));

    if (Grgeltd > 0.001) begin
        Grgeltd = 1.0 / Grgeltd;
    end else begin
        Grgeltd = 1.0e3;
        if (RGATEMOD != 0) begin
            $strobe("Warning: (instance %M) The gate conductance reset to 1.0e3 mho.");
        end
    end


    // ******************************************
    // **  Temperature-Dependent Calculations  **
    // ******************************************

    if (SHMOD != 0 && RTH0 > 0.0) begin
        DevTemp = $temperature + Temp(rth_branch) + DTEMP;
    end else begin
        DevTemp = $temperature + DTEMP;
    end

       TMAXK  = TMAXC + `P_CELSIUS0; // TMAX in Kelvin

    if (DevTemp > TMAXK) begin
        $strobe("Warning: DevTemp = %e is more than TMAXK. Set to TMAXK.", DevTemp);
    end

        DevTemp  = minx(DevTemp, TMAXK,  1.0e-2); //Limiting maximum temperature

    begin: IMGTempDepCalc

        TRatio  = DevTemp / Tnom;
        delTemp = DevTemp - Tnom;

        // Temperature-Dependent Quantities
        Vtm    = `KboQ * DevTemp;
        Eg     = BG0SUB - TBGASUB * DevTemp * DevTemp / (DevTemp + TBGBSUB);
        T1     = (DevTemp / 300.15) * sqrt(DevTemp / 300.15);
        ni     = NI0SUB * T1 * lexp(BG0SUB / (2.0 * `KboQ * 300.15) - Eg / (2.0 * Vtm));
        vbi    = Vtm * lln(NSD_i * NBODY_i / (ni * ni));
        phib   = Vtm * lln(NBODY_i / ni);
        phisub = (0.5 * Eg - hypsmooth(0.5 * Eg - Vtm * lln(NBG / ni), 1.0e-4));

        // Front- and Back-Gate Workfunctions
        if ((NBG != 0.0) && (!$param_given(PHIG2))) begin
            if (WELLTYPE == `ptype) begin
                PHIG2_i = PHIG2_i - 0.5 * BG0SUB + phisub;
            end else begin
                PHIG2_i = PHIG2_i + 0.5 * BG0SUB - phisub;
            end
        end

        PhiRef    = EASUB + Eg / 2.0;
        deltaphi1 = devsign * (PHIG1_i - PhiRef);
        deltaphi2 = devsign * (PHIG2_i - PhiRef);

        PhiSD = EASUB + Eg / 2.0 - devsign * min(Eg / 2.0, Vtm * lln(NSD_i / ni));
        vfbsd = devsign * (PHIG1_i - PhiSD);  // for GIDL and Cov
        vfbsd_bg = devsign * (PHIG2_i - PhiSD);  // Flat-band voltage of back MOS for GIDL and COV Calculation		

        // Temperature Effects
        U0_t  = U0_i * pow(TRatio, UTE_i) * (1.0 + hypsmooth(0.9 + UTL_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        UC_t  = UC_i * hypsmooth(1.0 + UC1 * delTemp - 1.0e-6, 1.0e-3);
        UA_t  = UA_i * hypsmooth(1.0 + UA1_i * delTemp - 1.0e-6, 1.0e-3);
        UD_t  = UD_i * pow(TRatio, UD1_i);
        UCS_t = UCS_i * pow(TRatio, UCSTE_i);

        rdstemp = hypsmooth(1.0 + PRT_i * delTemp - 1.0e-6, 1.0e-3);
        AT_i    = AT_i * (1.0 + Inv_L * ATL);
        VSAT_t  = VSAT_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));

        if (VSAT_t < 1000) begin
            $strobe("Warning: VSAT(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT_t);
            VSAT_t = 1000;
        end

        VSAT1_t = VSAT1_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        if (VSAT1_t < 1000) begin
            $strobe("Warning: VSAT1(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSAT1_t);
            VSAT1_t = 1000;
        end

        VSATCV_t = VSATCV_i * (1.0 + hypsmooth(0.9 - AT_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        if (VSATCV_t < 1000) begin
            $strobe("Warning: VSATCV(%f) = %e is less than 1K, setting it to 1K.", DevTemp, VSATCV_t);
            VSATCV_t = 1000;
        end

        ETA0_t     = ETA0_i * (1.0 + hypmax(TETA0 * delTemp, -0.9, 1e-4));
        ATB_i      = ATB_i *(1.0 +  Inv_L * ATBL);
        VSATB_t    = VSATB_i * (1.0 + hypsmooth(0.9 - ATB_i * delTemp, 1.0e-3) - hypsmooth(0.9, 1.0e-3));
        MEXP_t     = hypsmooth(MEXP_i * (1.0 + TMEXP * delTemp)-2.0 , 1.0e-3) + 2.0;
        K0_t       = K0_i + K01_i * delTemp;
        K0SI_t     = K0SI_i + hypmax(K0SI1_i  * delTemp, -K0SI_i, 1.0e-6);
        K0SISAT_t  = K0SISAT_i + K0SISAT1_i * delTemp;
        PTWG_t     = PTWG_i * hypsmooth(1.0 - PTWGT_i * delTemp - 1.0e-6, 1.0e-3);
        dvth_temp0 = (KT1 + KT1L / Leff) * (TRatio - 1.0);
        BETA0_t    = BETA0_i * pow(TRatio, IIT_i);
        BGIDL_t    = BGIDL_i * hypsmooth(1.0 + TGIDL_i * delTemp - 1.0e-6, 1.0e-3);
        BGISL_t    = BGISL_i * hypsmooth(1.0 + TGISL_i * delTemp - 1.0e-6, 1.0e-3);
        igtemp     = lexp(IGT_i * lln(TRatio));
        igsd_mult  = igsd_mult0 * igtemp;
    end

    // ***********************************
    // **  Bias-Dependent Calculations  **
    // ***********************************

    // Load Terminal Voltages
    vgs_noswap  = devsign * V(gi, si);
    vds_noswap  = devsign * V(di, si);
    vgd_noswap  = devsign * V(gi, di);
    vbgs_noswap = devsign * V(bg, si);
    vbgd_noswap = devsign * V(bg, di);
    vgbg        = devsign * V(gi, bg);

    // Source-Drain Change
    sigvds = 1.0;

    if (vds_noswap < 0.0) begin
        sigvds = -1.0;
        vfgs   = vgd_noswap;
        vds    = -vds_noswap;
        vbgs   = vbgd_noswap;
        vbgd   = vbgs_noswap;
    end else begin
        vfgs   = vgs_noswap;
        vds    = vds_noswap;
        vbgs   = vbgs_noswap;
        vbgd   = vbgd_noswap;
    end

    vgd_ov_noswap = devsign * V(ge, di);
    vgs_ov_noswap = devsign * V(ge, si);

    vdsx  = sqrt(vds * vds + 0.0004) - 0.02;
    symmetry_factor = 0.5 * (vdsx - vds);
    vbgx  = vbgs + symmetry_factor;
    vgfb1 = vfgs - deltaphi1;
    vgfb2 = vbgs - deltaphi2;

    // Back-gate Bias Dependence
    sclf = sqrt(epsratio * TSI * EOT1);
    sclm = sqrt(TSI * (epsratio * EOT1 + 0.375 * TSI));
    T0   = (vgfb1 * (EOT2 * epsratio) + vgfb2 * (EOT1 * epsratio + TSI)) / teff + symmetry_factor;
    T1   = atan(ASCL_i + BSCL_i * T0) / `M_PI + 0.5;
    scl  = sclm + T1 * (sclf - sclm);

    tmp = DVT1_i * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        Theta_SCE = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_SCE = lexp(-tmp);
    end

    tmp = DSUB_i * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        Theta_DIBL = 0.5 / (cosh(tmp) - 1.0);
    end else begin
        Theta_DIBL = lexp(-tmp);
    end

    if (tmp < 40.0) begin
        Theta_DITS = 1.0 / max((1.0 + DVTP2 * (cosh(tmp) - 2.0)), 1.0e-6);
    end else begin
        Theta_DITS = lexp(-tmp) / max((lexp(-tmp) + DVTP2), 1.0e-6);
    end

    tmp = DROUT_i * Leff / scl + 1.0e-6;
    if (tmp < 40.0) begin
        DIBLfactor = 0.5 * PDIBL1_i / (cosh(tmp) - 1.0) +PDIBL2_i;
    end else begin
        DIBLfactor = PDIBL1_i * lexp(-tmp) + PDIBL2_i;
    end

    // Back-gate Bias Effect
    if (WELLTYPE == `ptype) begin
        temp = DBGPW_i * Leff / scl;
        if (temp > 40.0) begin
            T0 = lexp(temp)/2.0;
        end else begin
            T0 = cosh(temp) - 1.0;
        end
        T1       = KBG0PW_i - 0.5 * KBG1PW_i / T0;
        T2       = KBG2PW_i;
        vknee1   = VKNEE1PW_i;
        vknee2   = VKNEE2PW_i;
        bpfactor = BPFACTORPW_i;
    end else begin
        temp = DBGNW_i * Leff / scl;
        if (temp > 40.0) begin
            T0 = lexp(temp) / 2.0;
        end else begin
            T0 = cosh(temp) - 1.0;
        end
        T1       = KBG0NW_i - 0.5 * KBG1NW_i / T0;
        T2       = KBG2NW_i;
        vknee1   = VKNEE1NW_i;
        vknee2   = VKNEE2NW_i;
        bpfactor = BPFACTORNW_i;
    end

    T0   = T1 - T2;
    kvbg = T2 + 0.5 * (T0 + sqrt(T0 * T0 + 0.0001));

    // Back-gate Depletion Effect
    vsubdep0 = `q * NBG * epssi / (2.0 * cox2 * cox2);

    if (NBG != 0.0) begin
        T0 = sqrt(1.0 + hypsmooth(welsign * (devsign * vbgx - vknee1), 1.0e-2) / vsubdep0) - 1.0;
    end else begin
        T0 = 0.0;
    end

    vsubdep  = vsubdep0 * T0 * T0;
    vsubdep  = -hypmax(-vsubdep, -vknee2, 1.0e-2);
    vgfb2eff = -1.2 - symmetry_factor;
    gamma0   = -cox2 * csi / ((cox2 + csi) * cox1);
    dvth_vbg = gamma0 * kvbg * (vgfb2 - (devsign * welsign * bpfactor * vsubdep) - vgfb2eff);

    // SCE, DIBL, RSCE, and SS degradation effects, Ref: BSIM4
    vbgxpos     = hypsmooth(vbgx, 1.0e-3);
    phist       = 0.4 + phib + PHIN_i;
    if (phist <0) begin
        dvth_rsce = 0;
    end else begin
        dvth_rsce   = K1RSCE_i * Theta_RSCE * sqrt(phist);
    end
    dvth_vtroll = -DVT0_i * Theta_SCE * (vbi - phist);
    dvth_dibl   = -(ETA0_t + ETAB_i * vbgx) * Theta_DIBL * (vdsx + ETA1_i * sqrt(vdsx + 0.01)) + (DVTP0_i * Theta_DITS * pow((vdsx + 0.01), DVTP1_i));
    dvth_dsc    = -DSC0_i / (Leff + DSC1_i) * vdsx;
    T1          = csi * cox2 / (csi + cox2);
    T2          = (CDSCD_i + CBGCBGD * vbgxpos) * vdsx;
    T3          = CBGCBG0 * vbgx + CBGCBG0P * vbgx * vbgx + Theta_SCE * (CDSC_i + CBGCBG_i * vbgx + CBGCBGP * vbgx * vbgx + T2);
    nVtm        = Vtm * (cox1 + T1 + CIT_i + T3) / (cox1 + T1);
    

    // Threshold Voltage Shift Due to Body Doping, Ref: Noguchi et al. (EDL 2001)
    dvth_nbody = `q * NBODY_i * TSI / cox1 * (1.0 - 0.5 * TSI / (TSI + epsratio * EOT2));
    T0         = (KT2 + KT2L / Leff) * vbgx;
    dvth_temp  = dvth_temp0 + T0 * (TRatio - 1.0);
    dvth_all   = dvth_vtroll + dvth_dibl + dvth_rsce + dvth_dsc + dvth_nbody + dvth_temp + dvth_vbg;
    vgfb1eff   = vgfb1 - dvth_all + DELVTRAND;

    // Threshold Voltage Operating Point
    A0     = (2.0 * `q * ni * TSI * TSI) / (epssi * Vtm);
    k1     = cox1 / csi;
    k2     = cox2 / csi;
    lnA0 = ln(A0);
    phi1_0 = ln(39.47841)-lnA0;
    k1_2 = k1*k1;
    keq_k2  = k1 / (k2*k1 + k2  + k1);   
    qth    = 1.0;   // Assume Drift = Diffusion
    qsq1   = k1_2 * qth * qth - A0 * lexp(phib * 2.0);
    qsqrt1 = sqrt(qsq1);
    qcoth1 = (1.0 - qsqrt1 / 8.0) / (0.5 - qsqrt1 / 24.0);
    T1     = (1.0 + lln(k1 * k1 * qth * qth + k1 * qth * qcoth1) - lln(A0)) * Vtm;
    Vthop  = -devsign * (PHIG1_i - PhiRef + T1 + dvth_all + DELVTRAND);
    
    // ******************************************************************
    // **  Source Surface Potential and Charge Calculation (New Core)  **
    // ******************************************************************

    xg1 = vgfb1eff / nVtm;
    xg2 = (vgfb2 - dvth_all + DELVTRAND) / nVtm;
    /////////////////////////////BEGIN CORE CALCULATION////////////////////////////////////////////
    /////////////////saturation potential at back gate
    PHISsatback = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;//ln((k2*k2*(xg2-phi1_0)*(xg2-phi1_0)+39.47841))-lnA0;  //aproximation for saturation voltage in gate back
    PHISsat = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;
    PHISsatback2 = (PHISsat + k2 * xg2) / (1.0 + k2);       
    //phi2 guess using only PHISsatback and PHISsatback2
    phi2sub= xg2 + keq_k2* (xg1 - xg2);

    phi2 = min(phi2sub,PHISsatback);
    phi2 = min(phi2,phi1_0);  

    phi1  = (phi2 + k1 * xg1) / (1.0 + k1);
    T0 = phi1 - phi2;
    T3 = lexp(phi2) * (lexp(T0)-1.0)/T0;  
   /////////////////////begin sat potential calculation
    q2= xg2-PHISsatback2;
    qsqrt = k2*k2*q2*q2 -A0 * exp(PHISsatback2);
    if (qsqrt<0.0) begin //qsqrt for negative case
      q2= (xg2-phi2)*k2; 
      q1= 40.0*k1;//assume a given q1 in strong inversion 1.0/nVtm
      qt = q1+q2;
      T3 = q1*q2;
      T4 = 0.06534*qt+1.0;//(1.0/6.0-1.0/pi_2)*qt+1.0;
      T5 = qt*8.57973+T3+39.47841;//qt*(2.0*(1.0+pi_2/3.0))+T3+T2;
      T6 = 78.95683*qt+39.47841*T3;
      qsqrt = (-T5 + sqrt(-4.0*T4*T6 + T5*T5))/(2.0*T4);
    
      T3 = (phi1_0*(1.0 + k1)-phi2)/k1;
      T0 = 40*(xg1-T3+2.0)/5.0;
      qsqrt = qsqrt*(1.0-exp(-(xg1-T3+2.0)/(2.0/0.69)));
      qsqrt = min(qsqrt,50.0);   
    end 
      
    /////////////////saturation potential at front gate
    xg1=max(xg1,phi1_0);
    PHISsat = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;    
    

    T3 = (phi1_0*(1.0 + k1)-phi2)/k1;     
    T4 = ln((k1_2*(T3-phi1_0)*(T3-phi1_0)+39.47841))-lnA0;
    T5 = T4-phi1_0;
    PHISsat = PHISsat-T5;   
    
    q1 = xg1-PHISsat;
    T0 = -A0*exp(PHISsat);
    T1 = k1_2*q1;
    delta = -(T1*q1+T0-qsqrt)/(-2.0*T1+T0);
    PHISsat = PHISsat +delta; 

    q1 = xg1-PHISsat;
    T2 = k1_2 * q1;
    T0  = 1.0/(T2 * q1 -qsqrt);
    g= ln(abs((T2 * q1 -qsqrt)))-lnA0 - PHISsat;
    dg1  = 1.0/(-2.0 * T2 * T0 - 1.0);
    dg2  = -4.0 * T2 * T2 * T0 * T0 + 2.0 * k1_2 * T0;
    T1 = g * dg1;
    delta =  - T1 - 0.5*T1*T1*dg2*dg1;  
    delta = max(delta,-10.0);
    delta = min(delta,10.0);        
    PHISsat = PHISsat +delta; 
    
    q1 = xg1-PHISsat;
    T2 = k1_2 * q1;
    T0  = 1.0/(T2 * q1 -qsqrt);
    g= ln(abs((T2 * q1 -qsqrt)))-lnA0 - PHISsat;
    dg1  = 1.0/(-2.0 * T2 * T0 - 1.0);
    dg2  = -4.0 * T2 * T2 * T0 * T0 + 2.0 * k1_2 * T0;
    T1 = g * dg1;
    delta =  - T1 - 0.5*T1*T1*dg2*dg1;  
    delta = max(delta,-10.0);
    delta = min(delta,10.0);      
    PHISsat = PHISsat +delta; 

    PHISsat=max(PHISsat,phi1_0-4.0);

    xg1 = vgfb1eff / nVtm;
    phi1 =  phi1 -  1.0*ln(1.0 + exp((phi1-1.05*PHISsat)/1.0));
    phi1 = min(phi1,PHISsat);
    /////////////////////end sat potential calculation
    `include "bsimimg_sp_new.include"     

    q1 = xg1-phi1;
    T0 = A0 *exp(phi1);
    qsqrt = k1_2 * q1 * q1 -  T0 ;
    if (qsqrt < 0.0) begin
      q  = sqrt(-qsqrt);
      T2 = 0.5 * q;
      qcoth  = q / tan(T2);
      T6 = sin(T2);
      T1 = -T6 * T6;
    end else begin
      q  = sqrt(qsqrt);
      T2 = 0.5 * q;
      T6 = sinh(T2);
      T1 = T6 * T6;
      qcoth  = q /tanh(T2);
    end
    qicores = (k1 * q1 - qcoth) / (1.0 - qsqrt /(T1*T0));   
    
/////////////////////////////END CORE CALCULATION////////////////////////////////////////////

    qfronts = q1 * cox1 * nVtm;
    qtots   = qicores*csi * nVtm;
    qbacks  = qtots-qfronts;
    phi2 = xg2-qbacks/(cox2 * nVtm);
    phifs   = (phi1 + phi2) * nVtm / 2.0; // for Igc
    // Drain Saturation Voltage, Ref: BSIM4, PSP
    qis   = qtots / cox1;
    qbs   = `q * NBODY_i * TSI / cox1;
    T2    = eta_mu * qfronts / cox1 + qbs;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffs = EeffFactor * T3;

    T2     = eta_mu2 * qbacks / cox2 + qbs;
    T3     = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffs2 = EeffFactor2 * T3;
	
    begin: Calc_Source_Mobility
        real T2, T3;
        qb0   = 1.0e-2 / cox1;
        T2    = pow(0.5 * (1.0 + abs(qis / qb0)), UCS_t);
        T3    = (UA_t + vbgs * UC_t) * pow(abs(Eeffs), EU_i + EUB_i * vbgs) + UD_t / T2;
        Dmobs = 1.0 + T3;
        Dmobs = smoothminx(Dmobs, 1.0, DMOBCLAMP);
        Dmobs = Dmobs / U0MULT;
        ueff1  = U0_t / Dmobs;
    end

    begin: Calc_Source_Mobility_back
        real T2, T3;
        T2    = pow(0.5 * (1.0 + abs(qis / qb0)), UCS2_i);
        T3    = (UA2_i + vbgs * UC2_i) * pow(abs(Eeffs2), EU2_i + EUB2_i * vbgs) + UD2_i  / T2;
        Dmobs = 1.0 + T3;
        Dmobs = smoothminx(Dmobs, 1.0, DMOBCLAMP);
        Dmobs = Dmobs / U0MULT;
        ueff2 = U02_i / Dmobs;
    end

    T0     = vgfb1eff - qfronts / cox1;
    T1     = vgfb2 - dvth_all - qbacks / cox2;
    w1     = exp(T0 / nVtm) / (exp(T0 / nVtm) + exp(T1 / nVtm));
    w2     = exp(T1 / nVtm) / (exp(T0 / nVtm) + exp(T1 / nVtm));
    utotal = w1 * ueff1 + w2 * ueff2;
	
    if (RDSMOD == 1) begin
        Rdss = 0.0;
    end else if (RDSMOD == 0) begin
        T4   = 1.0 + PRWG_i * qis;
        T1   = 1.0 / T4;
        T0   = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NF * rdstemp;
    end else begin
        T4   = 1.0 + PRWG_i * qis;
        T1   = 1.0 / T4;
        T0   = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
        Rdss = (RSourceGeo + RDrainGeo + RDSWMIN_i + RDSW_i * T0) * WeffWRFactor * NF * rdstemp;
    end

    Esat  = 2.0 * VSAT_t / utotal;
    EsatL = Esat * Leff;
    T6    = KSATIV_i * (qis + KSATIVB_i * vbgxpos + 2.0 * Vtm * KSUBIV_i);

    if (Rdss == 0.0) begin
       Vdsat = EsatL * T6 / (EsatL + T6);
    end else begin
       WVCox = Weff * VSAT_t * cox1;
       T0    = WVCox * Rdss;
       Ta    = 2.0 * T0;
       Tb    = T6 + EsatL + 3.0 * T6 * T0;
       Tc    = T6 * (EsatL + 2.0 * T6 * T0);
       Vdsat = (Tb - sqrt(Tb * Tb - 2.0 * Ta * Tc)) / Ta;
    end

    Vdsat  = hypsmooth(Vdsat - 1.0e-3, 1.0e-5) + 1.0e-3;
    T7     = pow(vds / Vdsat, MEXP_t);
    T8     = pow(1.0 + T7, inv_MEXP);
    Vdseff = vds / T8;

    if (Vdseff > vds) begin
        Vdseff = vds;
    end

    // *****************************************************************
    // **  Drain Surface Potential and Charge Calculation (New Core)  **
    // *****************************************************************
    xg1 = (vgfb1eff-Vdseff) / nVtm;
    xg2 = (vgfb2 - dvth_all + DELVTRAND-Vdseff) / nVtm;    
      
    /////////////////////////////BEGIN CORE CALCULATION////////////////////////////////////////////
    /////////////////saturation potential at back gate
    PHISsatback = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;//ln((k2*k2*(xg2-phi1_0)*(xg2-phi1_0)+39.47841))-lnA0;  //aproximation for saturation voltage in gate back
    PHISsat = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;
    T3 = (phi1_0*(1.0 + k1)-phi2)/k1;     
    T4 = ln((k1_2*(T3-phi1_0)*(T3-phi1_0)+39.47841))-lnA0;
    T5 = T4-phi1_0;
    PHISsat = PHISsat-T5;    
    PHISsatback2 = (PHISsat + k2 * xg2) / (1.0 + k2);       
    //phi2 guess using only PHISsatback and PHISsatback2
    phi2sub= xg2 + keq_k2* (xg1 - xg2);

    phi2 = min(phi2sub,PHISsatback);
    phi2 = min(phi2,phi1_0);  

    phi1  = (phi2 + k1 * xg1) / (1.0 + k1);
    T0 = phi1 - phi2;

    T3 = lexp(phi2) * (lexp(T0)-1.0)/T0;   
/////////////////////begin sat potential calculation

    q2= xg2-PHISsatback2;
    qsqrt = k2*k2*q2*q2 -A0 * exp(PHISsatback2);
    if (qsqrt<0.0) begin //qsqrt for negative case
      q2= (xg2-phi2)*k2; 
      q1= 40.0*k1;//assume a given q1 in strong inversion 1.0/nVtm
      qt = q1+q2;
      T3 = q1*q2;
      T4 = 0.06534*qt+1.0;//(1.0/6.0-1.0/pi_2)*qt+1.0;
      T5 = qt*8.57973+T3+39.47841;//qt*(2.0*(1.0+pi_2/3.0))+T3+T2;
      T6 = 78.95683*qt+39.47841*T3;
      qsqrt = (-T5 + sqrt(-4.0*T4*T6 + T5*T5))/(2.0*T4);
    
      T3 = (phi1_0*(1.0 + k1)-phi2)/k1;
      T0 = 40*(xg1-T3+2.0)/5.0;
      qsqrt = qsqrt*(1.0-exp(-(xg1-T3+2.0)/(2.0/0.69)));
      qsqrt = min(qsqrt,50.0);   
    end 

    /////////////////saturation potential at front gate
    xg1=max(xg1,phi1_0);
    PHISsat = ln((k1_2*(xg1-phi1_0)*(xg1-phi1_0)+39.47841))-lnA0;    
    T3 = (phi1_0*(1.0 + k1)-phi2)/k1;     
    T4 = ln((k1_2*(T3-phi1_0)*(T3-phi1_0)+39.47841))-lnA0;
    T5 = T4-phi1_0;
    PHISsat = PHISsat-T5;   

    q1 = xg1-PHISsat;
    T0 = -A0*exp(PHISsat);
    T1 = k1_2*q1;
    delta = -(T1*q1+T0-qsqrt)/(-2.0*T1+T0);
    PHISsat = PHISsat +delta; 
          
    q1 = xg1-PHISsat;
    T2 = k1_2 * q1;
    T0  = 1.0/(T2 * q1 -qsqrt);
    g= ln(abs((T2 * q1 -qsqrt)))-lnA0 - PHISsat;
    dg1  = 1.0/(-2.0 * T2 * T0 - 1.0);
    dg2  = -4.0 * T2 * T2 * T0 * T0 + 2.0 * k1_2 * T0;
    T1 = g * dg1;
    delta =  - T1 - 0.5*T1*T1*dg2*dg1;  
    delta = max(delta,-10.0);
    delta = min(delta,10.0);        
    PHISsat = PHISsat +delta; 
    
    q1 = xg1-PHISsat;
    T2 = k1_2 * q1;
    T0  = 1.0/(T2 * q1 -qsqrt);
    g= ln(abs((T2 * q1 -qsqrt)))-lnA0 - PHISsat;
    dg1  = 1.0/(-2.0 * T2 * T0 - 1.0);
    dg2  = -4.0 * T2 * T2 * T0 * T0 + 2.0 * k1_2 * T0;
    T1 = g * dg1;
    delta =  - T1 - 0.5*T1*T1*dg2*dg1;  
    delta = max(delta,-10.0);
    delta = min(delta,10.0);        
    PHISsat = PHISsat +delta;
    
    PHISsat = max(PHISsat,phi1_0-4.0);

    xg1 = (vgfb1eff-Vdseff) / nVtm;
    phi1 =  phi1 -  1.0*ln(1.0 + exp((phi1-1.05*PHISsat)/1.0));
    phi1 = min(phi1,PHISsat);

    /////////////////////end sat potential calculation
    `include "bsimimg_sp_new.include"    
    
   // if (qtotaldfirst<20.0) begin 
    q1 = xg1-phi1;
    T0 = A0 *exp(phi1);
    qsqrt = k1_2 * q1 * q1 -  T0 ;
    if (qsqrt < 0.0) begin
      q  = sqrt(-qsqrt);
      T2 = 0.5 * q;
      qcoth  = q / tan(T2);
      T6 = sin(T2);
      T1 = -T6 * T6;
    end else begin
      q  = sqrt(qsqrt);
      T2 = 0.5 * q;
      T6 = sinh(T2);
      T1 = T6 * T6;
      qcoth  = q /tanh(T2);
    end
    qicored = (k1 * q1 - qcoth) / (1.0 - qsqrt /(T1*T0)); 

    qfrontd = q1 * cox1 * nVtm;
    qtotd   = qicored*csi * nVtm;
    qbackd  = qtotd-qfrontd;
    phi2 = xg2-qbackd/(cox2 * nVtm);    
/////////////////////////////END CORE CALCULATION////////////////////////////////////////////
    // Average Potential and Charge
    qid = qtotd / cox1;
    qia = 0.5 * (qis + qid);
    dqi = qis - qid;
    qba = `q * NBODY_i * TSI / cox1;

    T0 = pow(Vdseff, 2.0) / 6.25e-4;
    if (CHARGEWF != 0.0) begin
        qia2 = (qfronts + qfrontd) / (2.0 * cox1) + CHARGEWF * (1.0 - lexp(-T0)) * 0.5 * (qfronts - qfrontd) / cox1;
    end else begin
        qia2 = (qfronts + qfrontd) / (2.0 * cox1);
    end

    if (CHARGEWF2 != 0.0) begin
        qib2 = (qbacks + qbackd) / (2.0 * cox2) + CHARGEWF2 * (1.0 - lexp(-T0)) * 0.5 * (qbacks - qbackd) / cox2;
    end else begin
        qib2 = (qbacks + qbackd) / (2.0 * cox2);
    end
	
    // Mobility Degradation, Ref: BSIM4, PSP
    T2    = eta_mu * qia2 + qba;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffm = EeffFactor * T3;

    T2    = eta_mu2 * qib2 + qba;
    T3    = 0.5 * (T2 + sqrt(T2 * T2 + 0.001));
    Eeffm2 = EeffFactor2 * T3;
	
    begin: Calc_Average_Mobility
        real T2, T3;
        T2   = pow(0.5 * (1.0 + abs(qia / qb0)), UCS_t);
        T3   = (UA_t + vbgx * UC_t) * pow(abs(Eeffm), EU_i + EUB_i * vbgx) + (UD_t + vbgx * UDB_i) / T2;
        Dmob = 1.0 + T3;
        Dmob = smoothminx(Dmob, 1.0, DMOBCLAMP);
        Dmob = Dmob / U0MULT;
        ueff1 = U0_t / Dmob;
    end

    begin: Calc_Average_Mobility_back
        real T2, T3;
        T2   = pow(0.5 * (1.0 + abs(qia / qb0)), UCS2_i);
        T3   = (UA2_i + vbgx * UC2_i) * pow(abs(Eeffm2), EU2_i + EUB2_i * vbgx) + (UD2_i + vbgx * UDB2_i) / T2;
        Dmob = 1.0 + T3;
        Dmob = smoothminx(Dmob, 1.0, DMOBCLAMP);
        Dmob = Dmob / U0MULT;
        ueff2 = U02_i / Dmob;
    end

    T0     = vgfb1eff - (qfronts + qfrontd) / (2.0 * cox1);
    T1     = vgfb2 - dvth_all - (qbacks + qbackd) / (2.0 * cox2);
    w1     = exp(T0 / nVtm) / (exp(T0 / nVtm) + exp(T1 / nVtm));
    w2     = exp(T1 / nVtm) / (exp(T0 / nVtm) + exp(T1 / nVtm));
    utotal = w1 * ueff1 + w2 * ueff2;
	
    // Multiplication factor for I-V
    beta = utotal * cox1 * Weff / Leff;
	
    // Mobility Degradation for C-V
    Eeffm_cv = EeffFactor * (qba + eta_mu_cv * qia);
    T3       = UA_t * pow(abs(Eeffm_cv), EU_i);
    Dmob_cv  = 1.0 + T3;
    Dmob_cv  = smoothminx(Dmob_cv, 1.0, DMOBCLAMP);
    Dmob_cv  = Dmob_cv / U0MULT;
	
    // Velocity Saturation
    Esat1  = 2.0 * VSAT1_t / utotal;
    Esat1L = Esat1 * Leff;

    T0     = 0.8 + VSATB_t * vbgx;
    Xsat   = 0.2 + 0.5 * (T0 + sqrt(T0 * T0 + 0.01));
    T0     = dqi / Esat1L * Xsat;
    Dvsat  = (1.0 + sqrt(DELTAVSAT + T0 * T0)) / (1.0 + sqrt(DELTAVSAT));
    Dvsat  = Dvsat + 0.5 * (PTWG_t - PTWGB_i * vbgxpos - PTWGB2_i * vbgx) * qia * dqi * dqi;
    Dvsat  = smoothminx(Dvsat, 1.0, DVSATCLAMP);

    EsatCV  = 2.0 * VSATCV_t * Dmob_cv / U0_t;
    EsatCVL = EsatCV * LeffCV;

    // Output Conductance
    if (PVAG_i > 0.0) begin
        PVAGfactor = 1.0 + PVAG_i * qia / EsatL;
    end else begin
        PVAGfactor = 1.0 / (1.0 - PVAG_i * qia / EsatL);
    end

    diffVds  = vds - Vdseff;
    Vgst2Vtm = qia + 2.0 * Vtm;

    if (DIBLfactor > 0.0) begin
        T1     = Vgst2Vtm;
        T3     = T1 / (Vdsat + T1);
        VaDIBL = T1 / DIBLfactor * T3 * PVAGfactor;
        Moc    = 1.0 + diffVds / VaDIBL;
    end else begin
        Moc = 1.0;
    end

    if (PCLM_i > 0.0) begin
        if (PCLMG < 0.0) begin
            T1 = 1.0 / (1.0 / PCLM_i - PCLMG * qia);
        end else begin
            T1 = PCLM_i * (1.0 + PCLMG * qia);
        end
        Mclm = 1.0 + T1 * lln(1.0 + diffVds / T1 / (Vdsat + EsatL));
    end else begin
        Mclm = 1.0;
    end
    Moc = Moc * Mclm;

    // Channel Length Modulation for C-V
    if (PCLMCV_i > 0.0) begin
        MclmCV = 1.0 + PCLMCV_i * lln(1.0 + (vds - Vdseff) / PCLMCV_i / (Vdsat + EsatCVL));
    end else begin
        MclmCV = 1.0;
    end

    // Lateral Non-uniform Doping Effect (IV-CV Vth shift)
    if (K0_t != 0.0) begin
        T1   = K0_t / (max(0.0, K0SI_t + K0SISAT_t * dqi * dqi) * qia + 2.0 * nVtm);
        Mnud = lexp(-T1);
    end else begin
        Mnud = 1.0;
    end

    // I-V Equation
    T0          = qicores - qicored;
    T1          = qicores * qicores - qicored * qicored;
    ids0        = csi * nVtm * 2.0 * Vtm * T0 + csi * nVtm * csi * nVtm * 0.5 * T1 / cox1;
    ids0_ov_dqi = 0.5 * (qis + qid) + Vtm;

    // Source/Drain Resistances
    begin: Rds_Block
        real T1, T4;
        real vgs_eff, vgd_eff, T2, T3;
        if (RDSMOD == 1) begin
            Rdsi    = 0.0;
            Dr      = 1.0;
            T2      = vgs_noswap - vfbsd;
            T3      = sqrt(T2 * T2 + 1.0e-4);
            vgs_eff = 0.5 * (T2 + T3);
            T4      = 1.0 + PRWG_i * vgs_eff;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * vbgs_noswap * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rsource = rdstemp * (RSourceGeo + (RSWMIN_i + RSW_i * T0) * WeffWRFactor);
            T2      = vgd_noswap - vfbsd;
            T3      = sqrt(T2 * T2 + 1.0e-4);
            vgd_eff = 0.5 * (T2 + T3);
            T4      = 1.0 + PRWG_i * vgd_eff;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * vbgd_noswap * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdrain  = rdstemp * (RDrainGeo + (RDWMIN_i + RDW_i * T0) * WeffWRFactor);
        end else begin
            T4      = 1.0 + PRWG_i * qia;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * (vbgd + vbgs) * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdsi    = rdstemp * ((RDSWMIN_i + RDSW_i * T0) * WeffWRFactor);
            Dr      = 1.0 + NF * beta * ids0_ov_dqi / (Dvsat) * Rdsi;
            Rdrain  = RDrainGeo;
            Rsource = RSourceGeo;
        if (RDSMOD == 2) begin
            T4      = 1.0 + PRWG_i * qia;
            T1      = 1.0 / T4;
            T1      = T1 - 0.5 * (vbgd + vbgs) * PRWB_i;
            T0      = 0.5 * (T1 + sqrt(T1 * T1 + 0.01));
            Rdsi    = rdstemp * (RSourceGeo + RDrainGeo + RDSWMIN_i + RDSW_i * T0) * WeffWRFactor;
            Dr      = 1.0 + NF * beta * ids0_ov_dqi / (Dvsat) * Rdsi;
            Rdrain  = 0.0;
            Rsource = 0.0;
        end
        end
    end

    ids = (beta / cox1) * ids0 * Moc * Mnud / (Dvsat * Dr);
    ids = NF * ids;

    // C-V Equation
    qfg = (qfrontd + qfronts) / 2.0;
    qd  = (1.0 / 6.0) * (qtots + 2.0 * qtotd);
    qs  = (1.0 / 6.0) * (2.0 * qtots + qtotd);
    qbg = (qbackd + qbacks) / 2.0;

    // Quantum Mechanical Effects
    if (QMTCENCV_i > 0.0) begin
        T4     = (qia + ETAQM_i * qba) / QM0_i;
        T5     = 1.0 + pow(T4, PQM_i);
        Tcen0  = TSI;
        Tcen   = Tcen0 / T5;
        coxeff = 3.9 * `EPS0 / (IMGTOXP * 3.9 / EPSROX1 + Tcen * QMTCENCV_i / epsratio);
    end else begin
        coxeff = cox1P;
    end

    T0  = WeffCV * LeffCV / MclmCV;
    qfg = qfg * T0;
    qd  = -qd * T0;
    qbg = qbg * T0;
    qs  = -qs * T0;

    // Parasitic Capacitances
    // Note: the back gate capacitance is assumed to be negligible due to the thick oxide.
    qfgs_ov = WeffCV * LOVS_i * cox1 * V(ge, si);
    qfgd_ov = WeffCV * LOVD_i * cox1 * V(ge, di);

    // Bias-Dependent Overlap Capacitances
    vfbsd_bg = devsign * (PHIG2_i - PhiSD);

    T0      = vgs_ov_noswap - vfbsd + `DELTA_1 + (EOT1 / EOT2) * (vbgs_noswap - vfbsd_bg - PCOVBS0) * PCOVBS1;
    vfgs_ov = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    T1      = vgs_ov_noswap - vfbsd - vfgs_ov;
    qfgs_ov = qfgs_ov + devsign * WeffCV * CGSL * (T1 - 0.5 * CKAPPAS * (sqrt(1.0 - 4.0 * vfgs_ov / CKAPPAS)- 1.0));

    T0      = vgd_ov_noswap - vfbsd + `DELTA_1 + (EOT1 / EOT2) * (vbgd_noswap - vfbsd_bg - PCOVBD0) * PCOVBD1;
    vfgd_ov = 0.5 * (T0 - sqrt(T0 * T0 + 4.0 * `DELTA_1));
    T1      = vgd_ov_noswap - vfbsd - vfgd_ov;
    qfgd_ov = qfgd_ov + devsign * WeffCV * CGDL * (T1 - 0.5 * CKAPPAD * (sqrt(1.0 - 4.0 * vfgd_ov / CKAPPAD)- 1.0));

    // Outer Fringe Capacitances
    qfgs_of = WeffCV * CFS_i * V(ge, si);
    qfgd_of = WeffCV * CFD_i * V(ge, di);

    qfgs_parasitic = qfgs_ov + qfgs_of;
    qfgd_parasitic = qfgd_ov + qfgd_of;

    Qsbg = devsign * csbox * V(si, bg);
    Qdbg = devsign * cdbox * V(di, bg);

    // Impact Ionization Current
    T0 = (ALPHA0_i + ALPHA1_i * Leff) / Leff;

    if ((T0 <= 0.0) || (BETA0_t <= 0.0)) begin
        Iii = 0.0;
    end else if (diffVds > BETA0_t / `EXPL_THRESHOLD) begin
        T1  = - BETA0_t / diffVds;
        Iii = T0 * diffVds * ids * lexp(T1);
    end else begin
        Iii = T0 * diffVds * ids * `MIN_EXPL;
    end

    // Gate Current, Ref: BSIM4, BSIM-CMG
    igbinv = 0.0;
    igbacc = 0.0;
    igcs   = 0.0;
    igcd   = 0.0;
    igs    = 0.0;
    igd    = 0.0;

    // Igb
    if (IGBMOD != 0) begin
        // Igbinv
        T1          = (qia - EIGBINV_i) / NIGBINV_i / Vtm;
        Vaux_Igbinv = NIGBINV_i * Vtm * lln(1.0 + lexp(T1));

        T2     = AIGBINV_i - BIGBINV_i * qia;
        T3     = 1.0 + CIGBINV_i * qia;
        T4     = -9.82222e11 * TOXP * T2 * T3;
        T5     = lexp(T4);
        T6     = 3.75956e-7;
        igbinv = Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbinv * T5;
        igbinv = igbinv * igtemp;

        // Igbacc
        vfbzb = deltaphi1 - phib;
        T0    = vfbzb - vgbg;
        T1    = T0 / NIGBACC_i / Vtm;

        Vaux_Igbacc = NIGBACC_i * Vtm * lln(1.0 + lexp(T1));

        if (vfbzb <= 0.0) begin
            Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) - 0.08 * vfbzb));
        end else begin
            Voxacc = 0.5 * (T0 - 0.02 + sqrt((T0 - 0.02) * (T0 - 0.02) + 0.08 * vfbzb));
        end

        T2 = AIGBACC_i - BIGBACC_i * Voxacc;
        T3 = 1.0 + CIGBACC_i * Voxacc;
        T4 = -7.45669e11 * TOXP * T2 * T3;
        T5 = lexp(T4);
        T6 = 4.97232e-7;
        igbacc = Weff * Leff * T6 * Toxratio * vgbg * Vaux_Igbacc * T5;
        igbacc = igbacc * igtemp;
    end

    // Gate to Body Tunneling Current Partition
    T0   = tanh(0.6 * vds_noswap / Vtm);
    wf   = 0.5 + 0.5 * T0;
    wr   = 1.0 - wf;
    igbs = wf * (igbinv + igbacc);
    igbd = wr * (igbinv + igbacc);


    if (IGCMOD != 0) begin
        // Igcinv
        T1       = AIGC_i - BIGC_i * (vgfb1 - DIGC_i * phifs);
        T2       = 1.0 + CIGC_i * (vgfb1 - DIGC_i * phifs);
        T3       = -Bechvb * TOXP * T1 * T2;
        T4       = qia * lexp(T3);
        T5       = vgbg + 0.5 * vdsx + 0.5 * (vbgs_noswap + vbgd_noswap);
        igc0     = Weff * Leff * Aechvb * Toxratio * T4 * T5 * igtemp;

        // Gate-Current Partition
        Vdseffx  = sqrt(Vdseff * Vdseff + 0.01) - 0.1;
        T1       = PIGCD_i * Vdseffx;
        T1_exp   = lexp(-T1);
        T3       = T1 + T1_exp - 1.0 + 1.0e-4;
        T4       = 1.0 - (T1 + 1.0) * T1_exp + 1.0e-4;
        T5       = T1 * T1 + 2.0e-4;
        igcd     = igc0 * T4 / T5;
        igcs     = igc0 * T3 / T5;

        // Igs
        T0       = vgs_noswap - vfbsd + DIGS_i * gamma0 * (vbgs - vfbsd_bg);
        vfgs_eff = sqrt(T0 * T0 + 1.0e-4);
        T1       = AIGS_i - BIGS_i * vfgs_eff;
        T2       = 1.0 + CIGS_i * vfgs_eff;
        T3       = -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4       = lexp(T3);

        if (sigvds > 0.0) begin
           igs = igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end else begin
           igd = igsd_mult * DLCIGS * vgs_noswap * vfgs_eff * T4;
        end

        // Igd
        T0       = vgd_noswap - vfbsd + DIGD_i * gamma0 * (vbgs - vfbsd_bg);
        vfgd_eff = sqrt(T0 * T0 + 1.0e-4);
        T1       = AIGD_i - BIGD_i * vfgd_eff;
        T2       = 1.0 + CIGD_i * vfgd_eff;
        T3       = -Bechvb * TOXP * POXEDGE_i * T1 * T2;
        T4       = lexp(T3);

        if (sigvds > 0.0) begin
           igd = igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end else begin
           igs = igsd_mult * DLCIGD * vgd_noswap * vfgd_eff * T4;
        end
    end


    // GIDL and GISL Currents
    igisl = 0.0;
    igidl = 0.0;

    if (GIDLMOD != 0) begin
        T0 = epsratio * EOT1;

        // GIDL
        if ((AGIDL_i <= 0.0) || (BGIDL_t <= 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgd_noswap - EGIDL_i + vfbsd  + VBGIDL_i * gamma0 * (vbgs - vfbsd_bg - VBEGIDL_i)) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGIDL_t / (T1 + 1.0e-3);
            T3 = lexp(PGIDL_i * lln(T1));
            T6 = AGIDL_i * Weff * T3 * lexp(-T2) * vds_noswap;
        end

        if (sigvds > 0.0) begin
            igidl = T6;
        end else begin
            igisl = T6;
        end

        // GISL
        if ((AGISL_i <= 0.0) || (BGISL_t <= 0.0)) begin
            T6 = 0.0;
        end else begin
            T1 = (-vgs_noswap - EGISL_i + vfbsd + VBGISL_i * gamma0 * (vbgs - vfbsd_bg - VBEGISL_i)) / T0;
            T1 = hypsmooth(T1, 1.0e-2);
            T2 = BGISL_t / (T1 + 1.0e-3);
            T3 = lexp(PGISL_i * lln(T1));
            T6 = -vds_noswap * AGISL_i * Weff * T3 * lexp(-T2);
        end
        if (sigvds > 0.0) begin
            igisl = T6;
        end else begin
            igidl = T6;
        end
    end

    // ********************
    // **  Noise Models  **
    // ********************

    Esatnoi = 2.0 * VSAT_t / utotal;

    // Flicker Noise, Ref: BSIM4, K. K. Hung et al., TED 1990 and P. Kushwaha et. al. EDL 2019
    if (NOIA > 0.0 || NOIB > 0.0 || NOIC > 0.0) begin
        Leffnoi   = Leff - 2.0 * LINTNOI_i;
        Leffnoisq = Leffnoi * Leffnoi;

        if (EM <= 0.0) begin
            DelClm = 0.0;
        end else begin
            T0     = (diffVds / litl + EM) / Esatnoi;
            DelClm = litl * lln(T0);
            if (DelClm < 0.0) begin
                DelClm = 0.0;
            end
        end

    if (FNMOD == 1) begin 
        T1 = qia2/QSREF_i;
        T2 = 1 + pow(T1, MPOWER_i);
        T3 = NOIA2_i/T2;
        T4 = T3 / NOIA;
        T5 = 0.5 * (T4 + 1 + sqrt((T4 - 1) * (T4 - 1) + 0.25 * SMOOTH * SMOOTH));
        NOIAeff = NOIA * T5;
    end else begin 
        NOIAeff = NOIA;
    end 
      
        T1  = `q * `q * `q * Vtm * abs(ids) * utotal;
        T2  = 1.0e10 * coxeff * Leffnoisq;
        N0  = coxeff * qis / `q;
        Nl  = coxeff * qid / `q;

        Nstar = Vtm / `q * (coxeff + CIT_i);
        T3    = NOIAeff * lln((N0 + Nstar) / (Nl + Nstar));
        T4    = NOIB * (N0 - Nl);
        T5    = 0.5 * NOIC * (N0 * N0 - Nl * Nl);
        T6    = `q * Vtm * ids * ids;

        T7  = 1.0e10 * Leffnoisq * Weff * NF;
        T8  = NOIAeff + NOIB * Nl + NOIC * Nl * Nl;
        T9  = (Nl + Nstar) * (Nl + Nstar);
        Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;

        T10 = NOIAeff * `q * Vtm;
        T11 = Weff * NF * Leffnoi * 1.0e10 * Nstar * Nstar;
        Swi = T10 / T11 * ids * ids;

        T1  = Swi + Ssi;

        if (T1 > 0.0) begin
            FNPowerAt1Hz = (Ssi * Swi) / T1;
        end else begin
            FNPowerAt1Hz = 0.0;
        end

    end else begin
        FNPowerAt1Hz = 0.0;
    end

    // Intrinsic Charges
    qfgi = devsign * NF * qfg;
    qbgi = NF * qbg;

    if (sigvds > 0.0) begin
        qsi = NF * qs;
        qdi = NF * qd;
        qs  = NF * (qs - qfgs_parasitic) + Qsbg;
        qd  = NF * (qd - qfgd_parasitic) + Qdbg;
    end else begin
        qsi = NF * qd;
        qdi = NF * qs;
        T0  = NF * (qd - qfgs_parasitic) + Qsbg;
        qd  = NF * (qs - qfgd_parasitic) + Qdbg;
        qs  = T0;
    end

    qfg = qfgi + NF * (qfgs_parasitic + qfgd_parasitic);
    qbg = NF * qbg - Qsbg - Qdbg;

    qfgs_parasitic = NF * qfgs_parasitic;
    qfgd_parasitic = NF * qfgd_parasitic;

    // Charge-Based Thermal Noise, Ref: BSIM4 TNOIMOD = 0
    qinv  = -(qsi + qdi);
    T0    = utotal * qinv;
    T1    = T0 * Rdsi + Leff * Leff;
    Gtnoi = (T0 / T1) * NTNOI;
    Nt    = 4.0 * Vtm * `q;
    sid   = Nt * Gtnoi;

    // NQS gate resistance Ref: BSIM4
    if (NQSMOD == 1 && XRCRG1_i != 0.0) begin
        T0       = utotal * cox1 * Weff / Leff;
        IdsovVds = T0 * qia;
        gcrg     = NF * XRCRG1_i * (IdsovVds + XRCRG2_i * Vtm * T0);
    end else begin
        gcrg     = 0.0;
    end

    // Loading Variables
    igidl = NF * igidl;
    igisl = NF * igisl;
    igcd  = NF * igcd;
    igcs  = NF * igcs;
    igs   = NF * igs;
    igd   = NF * igd;

    if (sigvds > 0.0) begin
        I(di, si) <+ devsign * ids + ($simparam("gmin",1e-12) * V(di, si));
        I(di, si) <+ devsign * (igidl + Iii);
        I(si, di) <+ devsign * igisl;
        I(gi, si) <+ devsign * (igcs + igs);
        I(gi, di) <+ devsign * (igcd + igd);
    end else begin
        I(si, di) <+ devsign * ids + ($simparam("gmin",1e-12) * V(si, di));
        I(si, di) <+ devsign * (igidl + Iii);
        I(di, si) <+ devsign * igisl;
        I(gi, di) <+ devsign * (igcs + igs);
        I(gi, si) <+ devsign * (igcd + igd);
    end

    I(gi, si)  <+ devsign * igbs;
    I(gi, di)  <+ devsign * igbd;
    I(di, si)  <+ devsign * ddt(qdi);
    I(gi, si)  <+ ddt(qfgi);
    I(bg, si)  <+ devsign * ddt(qbgi);
    I(ge, si)  <+ ddt(qfgs_parasitic);
    I(ge, di)  <+ ddt(qfgd_parasitic);

    I(si, bg)  <+ devsign * ddt(Qsbg);
    I(di, bg)  <+ devsign * ddt(Qdbg);

    if (RDSMOD == 2) begin
        V(d, di) <+ 0.0;
        V(s, si) <+ 0.0;
    end else begin
        gdpr = 1.0 / Rdrain;
        gspr = 1.0 / Rsource;
        I(d, di) <+ V(d, di) * gdpr;
        I(s, si) <+ V(s, si) * gspr;
        I(d, di) <+ white_noise(Nt * gdpr, "Rd");
        I(s, si) <+ white_noise(Nt * gspr, "Rs");
    end

// NQSMOD1 Gate Resistance Model
    if (NQSMOD == 1 && XRCRG1_i != 0.0)
        I(ge, gi) <+ V(ge, gi) * gcrg;
    else
        V(ge, gi) <+ 0.0;


    if (RGATEMOD == 0) begin
        V(fg, ge) <+ 0.0;
    end else begin: Rgate
        real Ggate, Gnoise;
        Ggate  = Grgeltd;
        Gnoise = Grgeltd;
        I(fg, ge) <+ V(fg, ge) * Ggate;
        I(fg, ge) <+ white_noise(Nt * Gnoise, "Rg");
    end

    // Flicker Noise
    I(di,si) <+ flicker_noise(FNPowerAt1Hz, EF, "1overf");

    // Channel thermal noise and induced gate noise stamping
    // Implementation of correlated noise follows C. C. McAndrew, WCM 2005
    I(di, si) <+ white_noise(sid, "Id");

    // Gate Current Shot Noise
    if (IGCMOD != 0) begin
        if (sigvds > 0.0) begin
            I(gi, si) <+ white_noise(2.0 * `q * abs(igcs + igs), "Igs");
            I(gi, di) <+ white_noise(2.0 * `q * abs(igcd + igd), "Igd");
        end else begin
            I(gi, di) <+ white_noise(2.0 * `q * abs(igcs + igs), "Igd");
            I(gi, si) <+ white_noise(2.0 * `q * abs(igcd + igd), "Igs");
        end
    end

    if (IGBMOD != 0) begin
        I(gi, si) <+ white_noise(2.0 * `q * abs(igbs), "Igb");
        I(gi, di) <+ white_noise(2.0 * `q * abs(igbd), "Igb");
    end

    // Self-heating
    if (SHMOD != 0 && RTH0 > 0.0) begin
        if (RDSMOD != 2) begin
            Pwr(ith_branch) <+ -(devsign * sigvds * V(di, si) * ids + V(d, di) * V(d, di) / Rdrain + V(s, si) * V(s, si) / Rsource);
        end else begin
            Pwr(ith_branch) <+ -(devsign * sigvds * V(di, si) * ids);
        end
        Pwr(rth_branch) <+ Temp(rth_branch) * gth;
        Pwr(rth_branch) <+ ddt(Temp(rth_branch) * cth);
    end else begin
        Temp(t) <+ 0.0;
    end

    // Operation Point Info
    VDSSAT = Vdsat;
    VTH    = Vthop;

    // Conductances
    IDS  = devsign * sigvds * ids;
    GM   = ddx(IDS, V(gi));
    GMBS = ddx(IDS, V(bg));

    if (sigvds > 0.0) begin
        VFGS = V(fg, s);
        VFGD = V(fg, d);
        VDS  = V(d, s);
        VSBG = V(s, bg);
        VDBG = V(d, bg);
        GDS  = ddx(IDS, V(di));
        ROUT = 1.0/GDS;
    end else begin
        VFGS = V(fg, d);
        VFGD = V(fg, s);
        VDS  = V(s, d);
        VSBG = V(d, bg);
        VDBG = V(s, bg);
        GDS  = ddx(-IDS, V(si));
        ROUT = 1.0/GDS;
    end

    // Total Source/Drain Currents
    if (sigvds > 0.0) begin
        ID = IDS - devsign * (igd + igcd + igbd) + devsign * (Iii + igidl - igisl);
        IS = -IDS - devsign * (igs + igcs + igbs) + devsign * (igisl - igidl);
    end else begin
        ID = -IDS - devsign * (igs + igcs + igbd) + devsign * (igisl - igidl);
        IS = IDS - devsign * (igd + igcd + igbs) + devsign * (Iii + igidl - igisl);
    end

    // Total Gate Current
    IFG = devsign * (igs + igd + igcs + igcd + igbs + igbd);

    // Impact Ionization Current
    III = devsign * Iii;

    // GIDL and GISL Currents
    if (sigvds > 0.0) begin
        IGIDL = devsign * igidl;
        IGISL = devsign * igisl;
    end else begin
        IGIDL = devsign * igisl;
        IGISL = devsign * igidl;
    end

    // Intrinsic Charges
    QFGI = qfgi;
    QBGI = devsign * qbgi;
    QDI  = devsign * qdi;
    QSI  = devsign * qsi;

    // Total Charges
    QFG  = qfg;
    QBG  = devsign * qbg;
    QD   = devsign * qd;
    QS   = devsign * qs;

    // Intrinsic Capacitances
    CFGDI  = -ddx(QFGI, V(di));
    CFGFGI = ddx(QFGI, V(gi));
    CFGSI  = -ddx(QFGI, V(si));
    CSFGI  = -ddx(QSI, V(gi));
    CFGBGI = -ddx(QFGI, V(bg));
    CBGDI  = -ddx(QBGI, V(di));
    CBGFGI = -ddx(QBGI, V(gi));
    CBGSI  = -ddx(QBGI, V(si));
    CSBGI  = -ddx(QSI,V(bg));
    CBGBGI = ddx(QBGI, V(bg));
    CDDI   = ddx(QDI, V(di));
    CDFGI  = -ddx(QDI, V(gi));
    CDSI   = -ddx(QDI, V(si));
    CDBGI  = -ddx(QDI, V(bg));

    // Total Capacitances
    CFGD   = -ddx(QFG, V(di));
    CFGFG  = CFGFGI + ddx(devsign * (qfgs_parasitic + qfgd_parasitic), V(ge));
    CFGS   = -ddx(QFG, V(si));
    CSFG   = CSFGI + ddx(devsign * qfgs_parasitic, V(ge));
    CFGBG  = -ddx(QFG, V(bg));
    CBGD   = -ddx(QBG, V(di));
    CBGFG  = -ddx(QBG, V(gi));
    CBGS   = -ddx(QBG, V(si));
    CSBG   = -ddx(QS,V(bg));
    CBGBG  = ddx(QBG, V(bg));
    CDD    = ddx(QD, V(di));
    CDFG   = CDFGI + ddx(devsign * qfgd_parasitic, V(ge));
    CDS    = -ddx(QD, V(si));
    CDBG   = -ddx(QD, V(bg));

    // Output for self-heating temperature
    T_TOTAL_K  = DevTemp;
    T_TOTAL_C  = DevTemp - `P_CELSIUS0;
    T_DELTA_SH = Temp(t);

end
