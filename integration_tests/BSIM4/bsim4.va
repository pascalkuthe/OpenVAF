/*
Verilog-A definition of BSIM4 based on version 4.8
Enhancements List:
trap-assisted junction model
Mobmod=0~6
Substrate R network
Wpemod: Wpe stress effects
Vth DITS extra parameters: dvtp2,3,4,5
mtrlMod with mtrlCompatMod
Igate model: igcmod=2 [abc]igs, [abc]igd, dlcigd, other default val changes
rbodymod =2
gidlMod GISL:agisl, bgisl, cgisl, egisl, rgisl, kgisl, and fgisl

Limitations:
PNlim, Fetlim, such junction/fet current limitation function not implemented
noise:lintnoi, tnoic, rnoic not required to support
.option scale, scalem not applied to this VA model 

Extra model parameters:
_ckt_gmin: model param to pass netlsit level gmin to va for diode current
min:       model param changed to _min to avoid to coflict with va builtin function min()
verbose:   model param to print debug information (default: 0)
type:      polarity 1: nmos(default), -1:pmos

Golden Simulator: 
HSPICE -- J-2014.09-SP2-1 for testing

Note:
BSIM4.8 was originally released as C code, but this verilogA code is downloaded from https://github.com/cogenda/VA-BSIM48
*/ 

/**********
 * Copyright 2001 Regents of the University of California. All rights reserved.
 * Author:  Weidong Liu
 * Authors: Xuemei Xi, Kanyu M. Cao, Hui Wan, Mansun Chan, Chenming Hu.
 * Project Director: Prof. Chenming Hu.
 **********/
//Indicate Xyce is the simulator used here, comment it out if runs with other simulator
`define __XYCE_VAMS__        
`include "disciplines.vams" 
`include "constants.vams"

`define NOT_GIVEN -12345789
`define INT_NOT_GIVEN -9999999
`define DEFAULT_TNOM 25
`define N_MINLOG 1.0e-38

`define EPS0 8.85418e-12
`define EPSOX 3.453133e-11
`define EPSSI 1.03594e-10
`define DELTA 1.0e-9
`define DELTA_1 0.02
`define DELTA_2 0.02
`define DELTA_3 0.02
`define DELTA_4 0.02
`define MM 3
`define EXP_THRESHOLD 34.0
`define MIN_EXP 1.713908431e-15
`define MAX_EXP 5.834617425e14
`define MAX_EXPL 2.688117142e+43
`define MIN_EXPL 3.720075976e-44
`define EXPL_THRESHOLD 100.0

// For now, set NOISE to 0 to disable noise.
`define NOISE 0 
//`define NOISE_DERIVATIVES 1
`define KboQ `P_K / `P_Q
`define NMOS 1
`define PMOS -1
`define DEXP(A,B)                                                        \
        if (A > `EXP_THRESHOLD)                                          \
            B = `MAX_EXP*(1.0+(A)-`EXP_THRESHOLD);                       \
        else if (A < -`EXP_THRESHOLD)                                    \
            B = `MIN_EXP;                                                \
        else                                                             \
            B = exp(A);                                                 

`define DEXP2(A,B,C)                                                     \
        if (A > `EXP_THRESHOLD) begin                                    \
            B = `MAX_EXP*(1.0+(A)-`EXP_THRESHOLD);                       \
            C = `MAX_EXP;                                                \
        end                                                              \
        else if (A < -`EXP_THRESHOLD) begin                              \
            B = `MIN_EXP;                                                \
            C = 0;                                                       \
        end else begin                                                   \
            B = exp(A);                                                  \
            C = B;                                                       \
        end                                       
        

/*
 * The macros to calculate the subroutines to process the geometry dependent
 * parasitics for BSIM4, which calculates Ps, Pd, As, Ad, and Rs and  Rd
 * for multi-fingers and varous GEO and RGEO options.
 */
`define BSIM4NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS)\
    if ((nf%2) != 0) begin \
        nuEndD = 1.0; \
        nuEndS = 1.0; \
        nuIntD = 2.0 * max((nf - 1.0) / 2.0, 0.0); \
        nuIntS = nuIntD; \
    end \
    else begin \
        if (minSD == 1) begin \
            nuEndD = 2.0; \
            nuIntD = 2.0 * max((nf / 2.0 - 1.0), 0.0);\
            nuEndS = 0.0;\
            nuIntS = nf;\
        end\
        else begin\
            nuEndD = 0.0;\
            nuIntD = nf;\
            nuEndS = 2.0;\
            nuIntS = 2.0 * max((nf / 2.0 - 1.0), 0.0);\
        end \
    end

`define BSIM4PAeffGeo(nf, geo, minSD, Weffcj, DMCG, DMCI, DMDG, Ps, Pd, As, Ad)\
    if (geo < 9) \
        `BSIM4NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS) \
    T0 = DMCG + DMCI;\
    T1 = DMCG + DMCG;\
    T2 = DMDG + DMDG;\
    PSiso = T0 + T0 + Weffcj;\
    PDiso = PSiso;\
    PSsha = T1;\
    PDsha = T1;\
    PSmer = T2;\
    PDmer = T2;\
    ASiso = T0 * Weffcj;\
    ADiso = ASiso;\
    ASsha = DMCG * Weffcj;\
    ADsha = ASsha;\
    ASmer = DMDG * Weffcj;\
    ADmer = ASmer;\
    case(geo)\
    0: begin\
        Ps = nuEndS * PSiso + nuIntS * PSsha;\
        Pd = nuEndD * PDiso + nuIntD * PDsha;\
        As = nuEndS * ASiso + nuIntS * ASsha;\
        Ad = nuEndD * ADiso + nuIntD * ADsha;\
    end \
    1: begin \
        Ps = nuEndS * PSiso + nuIntS * PSsha;\
        Pd = (nuEndD + nuIntD) * PDsha;\
        As = nuEndS * ASiso + nuIntS * ASsha;\
        Ad = (nuEndD + nuIntD) * ADsha;\
    end \
    2: begin \
        Ps = (nuEndS + nuIntS) * PSsha;\
        Pd = nuEndD * PDiso + nuIntD * PDsha;\
        As = (nuEndS + nuIntS) * ASsha;\
        Ad = nuEndD * ADiso + nuIntD * ADsha;\
    end \
    3: begin \
        Ps = (nuEndS + nuIntS) * PSsha;\
        Pd = (nuEndD + nuIntD) * PDsha;\
        As = (nuEndS + nuIntS) * ASsha;\
        Ad = (nuEndD + nuIntD) * ADsha;\
    end \
    4: begin \
        Ps = nuEndS * PSiso + nuIntS * PSsha;\
        Pd = nuEndD * PDmer + nuIntD * PDsha;\
        As = nuEndS * ASiso + nuIntS * ASsha;\
        Ad = nuEndD * ADmer + nuIntD * ADsha;\
    end \
    5: begin \
        Ps = (nuEndS + nuIntS) * PSsha;\
        Pd = nuEndD * PDmer + nuIntD * PDsha;\
        As = (nuEndS + nuIntS) * ASsha;\
        Ad = nuEndD * ADmer + nuIntD * ADsha;\
    end\
    6: begin \
        Ps = nuEndS * PSmer + nuIntS * PSsha;\
        Pd = nuEndD * PDiso + nuIntD * PDsha;\
        As = nuEndS * ASmer + nuIntS * ASsha;\
        Ad = nuEndD * ADiso + nuIntD * ADsha;\
    end \
    7: begin \
        Ps = nuEndS * PSmer + nuIntS * PSsha;\
        Pd = (nuEndD + nuIntD) * PDsha;\
        As = nuEndS * ASmer + nuIntS * ASsha;\
        Ad = (nuEndD + nuIntD) * ADsha;\
    end \
    8: begin \
        Ps = nuEndS * PSmer + nuIntS * PSsha;\
        Pd = nuEndD * PDmer + nuIntD * PDsha;\
        As = nuEndS * ASmer + nuIntS * ASsha;\
        Ad = nuEndD * ADmer + nuIntD * ADsha;\
    end \
    9: begin \
        Ps = PSiso + (nf - 1.0) * PSsha;\
        Pd = nf * PDsha;\
        As = ASiso + (nf - 1.0) * ASsha;\
        Ad = nf * ADsha;\
    end \
    10: begin\
        Ps = nf * PSsha;\
        Pd = PDiso + (nf - 1.0) * PDsha;\
        As = nf * ASsha;\
        Ad = ADiso + (nf - 1.0) * ADsha;\
    end \
    default: \
         $strobe("Warning: (instance X*) Specified GEO=%d not matched (BSIM4PAeffGeo)", geo); \
    endcase 


/* function to compute poly depletion effect */
`define BSIM4polyDepletion(phi, ngate, epsgate,coxe, Vgs, Vgs_eff, dVgs_eff_dVg)   \
    if ((ngate > 1.0e18) && (ngate < 1.0e25) && (Vgs > phi) && (epsgate!=0)) begin \
        T9 = 1.0e6 * `P_Q * epsgate * ngate / (coxe * coxe); \
        T8 = Vgs - phi;   \
        T4 = sqrt(1.0 + 2.0 * T8 / T9);  \
        T2 = 2.0 * T8 / (T4 + 1.0);  \
        T3 = 0.5 * T2 * T2 / T9; \
        T7 = 1.12 - T3 - 0.05; \
        T6 = sqrt(T7 * T7 + 0.224);\
        T5 = 1.12 - 0.5 * (T7 + T6); \
        Vgs_eff = Vgs - T5; \
        dVgs_eff_dVg = 1.0 - (0.5 - 0.5 / T4) * (1.0 + T7 / T6);  \
    end  \
    else begin \
        Vgs_eff = Vgs; \
        dVgs_eff_dVg = 1.0; \
    end 


`define BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, Type, Rend)\
    if (Type == 1) begin\
        case(rgeo)\
        1, 2, 5: begin \
            if (nuEnd == 0.0)\
                Rend = 0.0;\
            else\
                Rend = Rsh * DMCG / (Weffcj * nuEnd);\
        end \
        3, 4, 6: begin\
            if ((DMCG + DMCI) == 0.0) begin\
                $strobe("(DMCG + DMCI) can not be equal to zero\n");\
                if (DMCG == 0.0) \
                    DMCG = 0.2e-6;\
                if (DMCI == 0.0) \
                    DMCI = 0.2e-6; \
            end \
            if ( (nuEnd == 0.0) || ((DMCG+DMCI)==0.0))\
                Rend = 0.0;\
            else\
                Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI));\
        end\
        default:  \
            $strobe("Warning: (instance X*) Specified RGEO = %d not matched (BSIM4RdsEndIso)\n", \
                     rgeo);\
        endcase \
    end \
    else begin \
        case(rgeo)\
        1, 3, 7: begin\
            if (nuEnd == 0.0)\
                Rend = 0.0;\
            else\
                Rend = Rsh * DMCG / (Weffcj * nuEnd);\
        end \
        2, 4, 8: begin\
            if ((DMCG + DMCI) == 0.0) begin\
                $strobe("(DMCG + DMCI) can not be equal to zero\n");\
                if (DMCG == 0.0) \
                    DMCG = 0.2e-6;\
                if (DMCI == 0.0) \
                    DMCI = 0.2e-6; \
            end \
            if ( (nuEnd == 0.0) || ((DMCG+DMCI)==0.0))\
                Rend = 0.0;\
            else\
                Rend = Rsh * Weffcj / (3.0 * nuEnd * (DMCG + DMCI));\
        end\
        default: \
            $strobe("Warning: (instance X*) Specified RGEO=%d not matched (BSIM4RdsEndIso type !=1)\n", rgeo);\
        endcase \
    end 


`define BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEnd, rgeo, Type, Rend)\
    begin \
        if (Type == 1) begin\
            case(rgeo)\
            1, 2, 5: begin \
                if (nuEnd == 0.0)\
                    Rend = 0.0;\
                else\
                    Rend = Rsh * DMCG / (Weffcj * nuEnd);\
            end\
            3, 4, 6: begin \
                if (DMCG == 0.0) begin\
                    $strobe("DMCG can not be equal to zero\n");\
                    DMCG = 0.2e-6; \
                end \
                if (nuEnd == 0.0)\
                    Rend = 0.0;\
                else\
                    Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG);\
            end\
            default:\
                $strobe("Warning: (instance X*) Specified RGEO=%d not matched (BSIM4RdsEndSha)\n", rgeo);\
            endcase \
        end \
        else begin\
            case(rgeo)\
            1, 3, 7: begin\
                if (nuEnd == 0.0)\
                    Rend = 0.0;\
                else\
                    Rend = Rsh * DMCG / (Weffcj * nuEnd);\
            end\
            2, 4, 8: begin\
                if (DMCG == 0.0) begin\
                    $strobe("DMCG can not be equal to zero\n");\
                    DMCG = 0.2e-6; \
                end \
                if (nuEnd == 0.0)\
                    Rend = 0.0;\
                else\
                    Rend = Rsh * Weffcj / (6.0 * nuEnd * DMCG);\
            end\
            default:\
                $strobe("Warning: (instance X*) Specified RGEO=%d not matched (BSIM4RdsEndSha type !=1)\n", rgeo);\
            endcase \
        end \
    end 


`define BSIM4RdseffGeo(nf, geo, rgeo, minSD, Weffcj, Rsh, DMCG, DMCI, DMDG, Type, Rtot)\
    begin \
        if (geo < 9) begin\
            `BSIM4NumFingerDiff(nf, minSD, nuIntD, nuEndD, nuIntS, nuEndS)\
            if (Type == 1) begin\
                if (nuIntS == 0.0)\
                    Rint = 0.0;\
                else\
                    Rint = Rsh * DMCG / ( Weffcj * nuIntS); \
                end \
            else begin\
                if (nuIntD == 0.0)\
                    Rint = 0.0;\
                else        \
                    Rint = Rsh * DMCG / ( Weffcj * nuIntD);\
            end \
        end \
        case(geo)\
        0: begin \
            if (Type == 1) \
                `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                   rgeo, 1, Rend)\
            else \
                `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend)\
            end \
        1: begin \
            if (Type == 1) \
                `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                   rgeo, 1, Rend)\
            else\
                `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend)\
            end \
        2: begin \
            if (Type == 1) \
                `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                   rgeo, 1, Rend)\
            else   \
                `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend)\
            end \
        3: begin \
            if (Type == 1) \
                `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                   rgeo, 1, Rend)\
            else  \
                `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend)\
            end \
        4: begin \
            if (Type == 1) \
               `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                  rgeo, 1, Rend)\
            else \
                Rend = Rsh * DMDG / Weffcj;\
            end \
        5: begin \
            if (Type == 1) \
               `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndS, \
                  rgeo, 1, Rend)\
            else  \
                Rend = Rsh * DMDG / (Weffcj * nuEndD);\
        end \
        6: begin \
            if (Type == 1) \
                Rend = Rsh * DMDG / Weffcj;\
            else   \
                `BSIM4RdsEndIso(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend)\
            end\
        7: begin \
            if (Type == 1)\
                Rend = Rsh * DMDG / (Weffcj * nuEndS);\
            else  \
                `BSIM4RdsEndSha(Weffcj, Rsh, DMCG, DMCI, DMDG, nuEndD, \
                   rgeo, 0, Rend)\
        end \
        8: begin \
            Rend = Rsh * DMDG / Weffcj; \
        end \
        9: begin  /* all wide contacts assumed for geo = 9 and 10 */\
            if (Type == 1) begin\
                Rend = 0.5 * Rsh * DMCG / Weffcj;\
                if (nf == 2.0)\
                    Rint = 0.0;\
                else\
                    Rint = Rsh * DMCG / (Weffcj * (nf - 2.0));\
            end \
            else begin\
                Rend = 0.0;\
                Rint = Rsh * DMCG / (Weffcj * nf);\
            end \
        end\
        10: begin \
            if (Type == 1) begin\
                Rend = 0.0;\
                Rint = Rsh * DMCG / (Weffcj * nf);\
            end \
            else begin\
                Rend = 0.5 * Rsh * DMCG / Weffcj;\
                if (nf == 2.0)\
                    Rint = 0.0;\
                else\
                    Rint = Rsh * DMCG / (Weffcj * (nf - 2.0));\
            end \
        end \
        default: \
            $strobe("Warning: (instance X*) Specified GEO=%d not matched (BSIM4RdseffGeo)",\
                     geo);\
        endcase \
        if (Rint <= 0.0)\
            Rtot = Rend;\
        else if (Rend <= 0.0)\
            Rtot = Rint;\
        else\
            Rtot = Rint * Rend / (Rint + Rend);\
        if (Rtot==0.0)\
            $strobe("Warning: (instance X*) Zero resistance returned from RdseffGeo\n");\
    end



module bsim4va(d, g, s, b);

    analog function real BSIM4DioIjthVjmEval;

        input Nvtm, Ijth, Isb, XExpBV;
        real  Nvtm, Ijth, Isb, XExpBV;
        real  Tb, Tc, EVjmovNv;
       
        begin
           Tc = XExpBV;
           Tb = 1.0 + Ijth / Isb - Tc;
           EVjmovNv = 0.5 * (Tb + sqrt(Tb * Tb + 4.0 * Tc));
           BSIM4DioIjthVjmEval = Nvtm * ln(EVjmovNv);
        end 
    endfunction 
   

    //
    //   Node definitions
    //
    inout      d, g, s, b;
    electrical d, g, s, b,di, si,gi, gm,bi,sbulk,dbulk;

    // The parameter "type" should be set for N/P-MOSFET 
    // based on modelcard type (but can be overridden by netlist).
    parameter integer verbose = `INT_NOT_GIVEN;  // debug flag to print DBG msg 
    parameter integer type = `INT_NOT_GIVEN;     // NMOS=1 PMOS=-1
    parameter real l = `NOT_GIVEN;               // Length
    parameter real w = `NOT_GIVEN;               // Width
    parameter integer nf = `INT_NOT_GIVEN;       // Number of fingers
    parameter integer _min = `INT_NOT_GIVEN;     // Minimize either D or S
    parameter real ad = `NOT_GIVEN;              // Drain area
    parameter real as = `NOT_GIVEN;              // Source area
    parameter real pd = `NOT_GIVEN;              // Drain perimeter
    parameter real ps = `NOT_GIVEN;              // Source perimeter
    parameter real nrd = `NOT_GIVEN;             // Number of squares in drain
    parameter real nrs = `NOT_GIVEN;             // Number of squares in source
    parameter integer off = `INT_NOT_GIVEN;      // Device is initially off
    parameter integer trnqsmod = `INT_NOT_GIVEN; // Transient NQS model selector
    parameter integer acnqsmod = `INT_NOT_GIVEN; // AC NQS model selector
    parameter integer rbodymod = `INT_NOT_GIVEN; // Distributed body R model
    parameter integer rgatemod = `INT_NOT_GIVEN; // Gate resistance model selector
    parameter integer geomod = `INT_NOT_GIVEN;   // Geo dependent parasitics model
    parameter integer rgeomod = `INT_NOT_GIVEN;  // S/D res and contact model
    parameter integer capmod = `INT_NOT_GIVEN;   // Capacitance model selector
    parameter integer diomod = `INT_NOT_GIVEN;   // Diode IV model selector
    parameter integer rdsmod = `INT_NOT_GIVEN;   // Bias-dep S/D resistance model
    parameter integer level = `INT_NOT_GIVEN;    // Ignored, for Spice compatibility
    parameter integer mobmod = `INT_NOT_GIVEN;   // Mobility model selector
    parameter integer tempmod = `INT_NOT_GIVEN;  // Temperature model
    parameter integer permod = `INT_NOT_GIVEN;   // Pd and Ps model selector
    parameter integer fnoimod = `INT_NOT_GIVEN;  // Flicker noise model selector
    parameter integer tnoimod = `INT_NOT_GIVEN;  // Thermal noise model selector
    parameter integer igcmod = `INT_NOT_GIVEN;   // Gate-to-channel Ig model select
    parameter integer igbmod = `INT_NOT_GIVEN;   // Gate-to-body Ig model selector
    parameter integer paramchk = `INT_NOT_GIVEN; // Model parameter checking
    parameter integer binunit = `INT_NOT_GIVEN;  // Bin unit selector
    parameter real version = `NOT_GIVEN;         // parameter for model version
    parameter real toxe = `NOT_GIVEN;            // Electrical gate oxide [m]
    parameter real toxp = `NOT_GIVEN;            // Physical gate oxide thickness [m]
    parameter real toxm = `NOT_GIVEN;            // tox at which parameters are extracted [m]
    parameter real toxref = `NOT_GIVEN;          // Target tox value [m]
    parameter real dtox = `NOT_GIVEN;            // Defined as (toxe - toxp) [m]
    parameter real epsrox = `NOT_GIVEN;          // Rel dielectric constant gate oxide
    parameter real cdsc = `NOT_GIVEN;            // Drain/Source and channel coupling cap [F]
    parameter real cdscb = `NOT_GIVEN;           // Body-bias dependence of cdsc [F]
    parameter real cdscd = `NOT_GIVEN;           // Drain-bias dependence of cdsc [F]
    parameter real cit = `NOT_GIVEN;             // Interface state capacitance [F]
    parameter real nfactor = `NOT_GIVEN;         // Subthreshold swing Coefficient
    parameter real xj = `NOT_GIVEN;              // Junction depth [m]
    parameter real vsat = `NOT_GIVEN;            // Saturation velocity at tnom
    parameter real at = `NOT_GIVEN;              // Temperature coefficient of vsat
    parameter real a0 = `NOT_GIVEN;              // Non-uniform depletion width effect coeff
    parameter real ags = `NOT_GIVEN;             // Gate bias coeff of Abulk.
    parameter real a1 = `NOT_GIVEN;              // Non-saturation effect coeff
    parameter real a2 = `NOT_GIVEN;              // Non-saturation effect coeff
    parameter real keta = `NOT_GIVEN;            // Body-bias coeff of non-u deplet width
    parameter real nsub = `NOT_GIVEN;            // Substrate doping concentration
    parameter real ndep = `NOT_GIVEN;            // Channel doping conc at the depl edge
    parameter real nsd = `NOT_GIVEN;             // S/D doping concentration
    parameter real phin = `NOT_GIVEN;            // Adjusting parameter for surface potential [V]
    parameter real ngate = `NOT_GIVEN;           // Poly-gate doping concentration
    parameter real gamma1 = `NOT_GIVEN;          // Vth body coeff
    parameter real gamma2 = `NOT_GIVEN;          // Vth body coeff
    parameter real vbx = `NOT_GIVEN;             // Vth transition body Voltage[V]
    parameter real vbm = `NOT_GIVEN;             // Maximum body voltage [V]
    parameter real xt = `NOT_GIVEN;              // Doping depth [m]
    parameter real k1 = `NOT_GIVEN;              // Bulk effect coeff 1
    parameter real kt1 = `NOT_GIVEN;             // Temperature coeff of Vth
    parameter real kt1l = `NOT_GIVEN;            // Temperature coeff of Vth
    parameter real kt2 = `NOT_GIVEN;             // Body-coeff of kt1
    parameter real k2 = `NOT_GIVEN;              // Bulk effect coeff 2
    parameter real k3 = `NOT_GIVEN;              // Narrow width effect coeff
    parameter real k3b = `NOT_GIVEN;             // Body effect coeff of k3
    parameter real w0 = `NOT_GIVEN;              // Narrow width effect parameter [m]
    parameter real dvtp0 = `NOT_GIVEN;           // 1st parm for Vth shift due to pocket [m]
    parameter real dvtp1 = `NOT_GIVEN;           // 2nd parm for Vth shift due to pocket
    parameter real lpe0 = `NOT_GIVEN;            // Eq. length of pocket region at zero bias [m]
    parameter real lpeb = `NOT_GIVEN;            // Eq. length accounting for body [m]
    parameter real dvt0 = `NOT_GIVEN;            // Short channel effect coeff. 0
    parameter real dvt1 = `NOT_GIVEN;            // Short channel effect coeff. 1
    parameter real dvt2 = `NOT_GIVEN;            // Short channel effect coeff. 2
    parameter real dvt0w = `NOT_GIVEN;           // Narrow Width coeff. 0
    parameter real dvt1w = `NOT_GIVEN;           // Narrow Width effect coeff. 1
    parameter real dvt2w = `NOT_GIVEN;           // Narrow Width effect coeff. 2
    parameter real drout = `NOT_GIVEN;           // DIBL coeff of output resistance
    parameter real dsub = `NOT_GIVEN;            // DIBL coeff in the subthreshold region
    parameter real vth0 = `NOT_GIVEN;            // Threshold voltage [m]
    parameter real ua = `NOT_GIVEN;              // Linear gate dependence of mobility
    parameter real ua1 = `NOT_GIVEN;             // Temperature coeff of ua
    parameter real ub = `NOT_GIVEN;              // Quadratic gate dependence of mobility
    parameter real ub1 = `NOT_GIVEN;             // Temperature coeff of ub
    parameter real uc = `NOT_GIVEN;              // Body-bias dependence of mobility
    parameter real uc1 = `NOT_GIVEN;             // Temperature coeff of uc
    parameter real u0 = `NOT_GIVEN;              // Low-field mobility at Tnom
    parameter real eu = `NOT_GIVEN;              // Mobility exponent
    parameter real ute = `NOT_GIVEN;             // Temperature coeff of mobility
    parameter real voff = `NOT_GIVEN;            // Threshold voltage offset [V]
    parameter real minv = `NOT_GIVEN;            // Fitting parm for moderate inv in Vgsteff
    parameter real voffl = `NOT_GIVEN;           // Length dependence parm for Vth offset
    parameter real tnom = `NOT_GIVEN;            // Parameter measurement temperature [C]
    parameter real cgso = `NOT_GIVEN;            // Gate-source overlap capacitance per width [F]
    parameter real cgdo = `NOT_GIVEN;            // Gate-drain overlap capacitance per width [F]
    parameter real cgbo = `NOT_GIVEN;            // Gate-bulk overlap capacitance per length [F]
    parameter real xpart = `NOT_GIVEN;           // Channel charge partitioning
    parameter real delta = `NOT_GIVEN;           // Effective Vds parameter [V]
    parameter real rsh = `NOT_GIVEN;             // Source-drain sheet resistance [Ohm]
    parameter real rdsw = `NOT_GIVEN;            // Source-drain resistance per width [Ohm]
    parameter real rdswmin = `NOT_GIVEN;         // Source-drain res per width at high Vg [Ohm]
    parameter real rsw =`NOT_GIVEN;              // Source resistance per width [Ohm]
    parameter real rdw = `NOT_GIVEN;             // Drain resistance per width [Ohm]
    parameter real rdwmin = `NOT_GIVEN;          // Drain res per width at high Vg [Ohm]
    parameter real rswmin = `NOT_GIVEN;          // Source res per width at high Vg [Ohm]
    parameter real prwg = `NOT_GIVEN;            // Gate-bias effect on parasitic resistance
    parameter real prwb = `NOT_GIVEN;            // Body-effect on parasitic resistance
    parameter real prt = `NOT_GIVEN;             // Temperature coeff of parasitic resistance
    parameter real eta0 = `NOT_GIVEN;            // Subthreshold region DIBL coeff
    parameter real etab = `NOT_GIVEN;            // Subthreshold region DIBL coeff
    parameter real pclm = `NOT_GIVEN;            // Channel length modulation Coefficient
    parameter real pdiblc1 = `NOT_GIVEN;         // Drain-induced barrier lowering coeff
    parameter real pdiblc2 = `NOT_GIVEN;         // Drain-induced barrier lowering coeff
    parameter real pdiblcb = `NOT_GIVEN;         // Body-eff on drain-ind barrier lowering
    parameter real fprout = `NOT_GIVEN;          // Rout degradation coeff for pocket dev
    parameter real pdits = `NOT_GIVEN;           // Coefficient for drain-induced Vth shifts
    parameter real pditsl = `NOT_GIVEN;          // L dep of drain-induced Vth shifts
    parameter real pditsd = `NOT_GIVEN;          // Vds dep of drain-induced Vth shifts
    parameter real pscbe1 = `NOT_GIVEN;          // Substrate current body-effect coeff
    parameter real pscbe2 = `NOT_GIVEN;          // Substrate current body-effect coeff
    parameter real pvag = `NOT_GIVEN;            // Gate dep of output resistance parameter
    parameter real jss = `NOT_GIVEN;             // Bottom S jun rev sat current density
    parameter real jsws = `NOT_GIVEN;            // Iso edge sidewall S junc rev sat current
    parameter real jswgs = `NOT_GIVEN;           // Gate edge S jun rev sat current density
    parameter real pbs = `NOT_GIVEN;             // Source junction built-in potential [V]
    parameter real njs = `NOT_GIVEN;             // Source junction emission coeff
    parameter real xtis = `NOT_GIVEN;            // Source junction current temperature exp
    parameter real mjs = `NOT_GIVEN;             // Source bottom junction cap grading coeff
    parameter real pbsws = `NOT_GIVEN;           // Source sidewall jun cap built in pot [V]
    parameter real mjsws = `NOT_GIVEN;           // Source sidewall jun cap grading coeff
    parameter real pbswgs = `NOT_GIVEN;          // S (g side) swall jun cap built in
    parameter real mjswgs = `NOT_GIVEN;          // S (g side) swall jun cap grading coeff
    parameter real cjs = `NOT_GIVEN;             // S bottom jun capacitance per unit area [F]
    parameter real cjsws = `NOT_GIVEN;           // S sidewall jun cap per unit periphery [F]
    parameter real cjswgs = `NOT_GIVEN;          // S (g side) swall jun cap per unit [F]
    parameter real jsd = `NOT_GIVEN;             // Bottom D jun rev sat current density
    parameter real jswd = `NOT_GIVEN;            // Iso edge swall drain jun rev sat current
    parameter real jswgd = `NOT_GIVEN;           // Gate edge d jun rev sat current density
    parameter real pbd = `NOT_GIVEN;             // Drain junction built-in potential [V]
    parameter real njd = `NOT_GIVEN;             // Drain junction emission coeff
    parameter real xtid = `NOT_GIVEN;            // D junction current temperature exponent
    parameter real mjd = `NOT_GIVEN;             // Drain bottom junc cap grading coeff
    parameter real pbswd = `NOT_GIVEN;           // Drain swall jun cap built in potential [V]
    parameter real mjswd = `NOT_GIVEN;           // Drain swall jun cap grading coeff
    parameter real pbswgd = `NOT_GIVEN;          // Drain (g side) swall jun cap built in [V]
    parameter real mjswgd = `NOT_GIVEN;          // D (g side) swall jun cap grading coeff
    parameter real cjd = `NOT_GIVEN;             // D bottom jun capacitance per unit area
    parameter real cjswd = `NOT_GIVEN;           // Drain swall jun cap per unit periphery
    parameter real cjswgd = `NOT_GIVEN;          // Drain (g side) swall jun cap per unit
    parameter real vfbcv = `NOT_GIVEN;           // Flat Band Voltage parm for capmod=0 [V]
    parameter real vfb = `NOT_GIVEN;             // Flat Band Voltage [V]
    parameter real tpb = `NOT_GIVEN;             // Temperature coeff of pb
    parameter real tcj = `NOT_GIVEN;             // Temperature coeff of cj
    parameter real tpbsw = `NOT_GIVEN;           // Temperature coeff of pbsw
    parameter real tcjsw = `NOT_GIVEN;           // Temperature coeff of cjsw
    parameter real tpbswg = `NOT_GIVEN;          // Temperature coeff of pbswg
    parameter real tcjswg = `NOT_GIVEN;          // Temperature coeff of cjswg
    parameter real acde = `NOT_GIVEN;            // Exp coeff for finite charge thickness
    parameter real moin = `NOT_GIVEN;            // Coeff for gate-bias dep surf potential
    parameter real noff = `NOT_GIVEN;            // C-V turn-on/off parameter
    parameter real voffcv = `NOT_GIVEN;          // C-V lateral-shift parameter [V]
    parameter real dmcg = `NOT_GIVEN;            // Distance of Mid-Contact to Gate edge [m]
    parameter real dmci = `NOT_GIVEN;            // Distance of Mid-Contact to Isolation [m]
    parameter real dmdg = `NOT_GIVEN;            // Distance of Mid-Diffusion to Gate edge [m]
    parameter real dmcgt = `NOT_GIVEN;           // Dist of Mid-Contact to Gate edge in Test [m]
    parameter real xgw = `NOT_GIVEN;             // Dist from gate contact center to dev edge [m]
    parameter real xgl = `NOT_GIVEN;             // Variation in Ldrawn [m]
    parameter real rshg = `NOT_GIVEN;            // Gate sheet resistance [Ohm]
    parameter real ngcon = `NOT_GIVEN;           // Number of gate contacts
    parameter real xrcrg1 = `NOT_GIVEN;          // 1st fitting parm the bias-dependent Rg
    parameter real xrcrg2 = `NOT_GIVEN;          // 2nd fitting parm the bias-dependent Rg
    parameter real lint = `NOT_GIVEN;            // Length reduction parameter [m]
    parameter real ll = `NOT_GIVEN;              // Length reduction parameter [m]
    parameter real llc = `NOT_GIVEN;             // Length reduction parameter for CV [m]
    parameter real lln = `NOT_GIVEN;             // Length reduction parameter [m]
    parameter real lw = `NOT_GIVEN;              // Length reduction parameter [m]
    parameter real lwc = `NOT_GIVEN;             // Length reduction parameter for CV [m]
    parameter real lwn = `NOT_GIVEN;             // Length reduction parameter [m]
    parameter real lwl = `NOT_GIVEN;             // Length reduction parameter [m]
    parameter real lwlc = `NOT_GIVEN;            // Length reduction parameter for CV [m]
    parameter real lmin = `NOT_GIVEN;            // Minimum length for the model [m]
    parameter real lmax = `NOT_GIVEN;            // Maximum length for the model [m]
    parameter real wr = `NOT_GIVEN;              // Width dependence of rds
    parameter real wint = `NOT_GIVEN;            // Width reduction parameter [m]
    parameter real dwg = `NOT_GIVEN;             // Width reduction parameter
    parameter real dwb = `NOT_GIVEN;             // Width reduction parameter
    parameter real wl = `NOT_GIVEN;              // Width reduction parameter [m]
    parameter real wlc = `NOT_GIVEN;             // Width reduction parameter for CV [m]
    parameter real wln = `NOT_GIVEN;             // Width reduction parameter [m]
    parameter real ww = `NOT_GIVEN;              // Width reduction parameter [m]
    parameter real wwc = `NOT_GIVEN;             // Width reduction parameter for CV [m]
    parameter real wwn = `NOT_GIVEN;             // Width reduction parameter [m]
    parameter real wwl = `NOT_GIVEN;             // Width reduction parameter [m]
    parameter real wwlc = `NOT_GIVEN;            // Width reduction parameter for CV [m]
    parameter real wmin = `NOT_GIVEN;            // Minimum width for the model [m]
    parameter real wmax = `NOT_GIVEN;            // Maximum width for the model [m]
    parameter real b0 = `NOT_GIVEN;              // Abulk narrow width parameter [m]
    parameter real b1 = `NOT_GIVEN;              // Abulk narrow width parameter [m]
    parameter real cgsl = `NOT_GIVEN;            // New C-V model parameter [F]
    parameter real cgdl = `NOT_GIVEN;            // New C-V model parameter [F]
    parameter real ckappas = `NOT_GIVEN;         // S/G overlap C-V parameter [V]
    parameter real ckappad = `NOT_GIVEN;         // D/G overlap C-V parameter [V]
    parameter real cf = `NOT_GIVEN;              // Fringe capacitance parameter [F]
    parameter real clc = `NOT_GIVEN;             // Vdsat parameter for C-V model [F]
    parameter real cle = `NOT_GIVEN;             // Vdsat parameter for C-V model [F]
    parameter real dwc = `NOT_GIVEN;             // Delta W for C-V model [m]
    parameter real dlc = `NOT_GIVEN;             // Delta L for C-V model [m]
    parameter real xw = `NOT_GIVEN;              // W offset for chan width due to mask/etch [m]
    parameter real xl = `NOT_GIVEN;              // L offset for chan length due to mask/etch [m]
    parameter real dlcig = `NOT_GIVEN;           // Delta L for Igs model [m]
    parameter real dlcigd = `NOT_GIVEN;          // Delta L for Igd model [m]
    parameter real dwj = `NOT_GIVEN;             // Delta W for S/D junctions [m]
    parameter real alpha0 = `NOT_GIVEN;          // substrate current model parameter
    parameter real alpha1 = `NOT_GIVEN;          // substrate current model parameter
    parameter real beta0 = `NOT_GIVEN;           // substrate current model parameter
    parameter real agidl = `NOT_GIVEN;           // Pre-exponential constant for GIDL
    parameter real bgidl = `NOT_GIVEN;           // Exponential constant for GIDL
    parameter real cgidl = `NOT_GIVEN;           // Parm for body-bias dependence of GIDL
    parameter real egidl = `NOT_GIVEN;           // Fitting parameter for Bandbending
    parameter real aigc = `NOT_GIVEN;            // Parameter for Igc
    parameter real bigc = `NOT_GIVEN;            // Parameter for Igc
    parameter real cigc = `NOT_GIVEN;            // Parameter for Igc
    parameter real aigsd = `NOT_GIVEN;           // Parameter for Igs d
    parameter real bigsd = `NOT_GIVEN;           // Parameter for Igs d
    parameter real cigsd = `NOT_GIVEN;           // Parameter for Igs d
    parameter real aigbacc = `NOT_GIVEN;         // Parameter for Igb
    parameter real bigbacc = `NOT_GIVEN;         // Parameter for Igb
    parameter real cigbacc = `NOT_GIVEN;         // Parameter for Igb
    parameter real aigbinv = `NOT_GIVEN;         // Parameter for Igb
    parameter real bigbinv = `NOT_GIVEN;         // Parameter for Igb
    parameter real cigbinv = `NOT_GIVEN;         // Parameter for Igb
    parameter real nigc = `NOT_GIVEN;            // Parameter for Igc slope
    parameter real nigbinv = `NOT_GIVEN;         // Parameter for Igbinv slope
    parameter real nigbacc = `NOT_GIVEN;         // Parameter for Igbacc slope
    parameter real ntox = `NOT_GIVEN;            // Exponent for Tox ratio
    parameter real eigbinv = `NOT_GIVEN;         // Parm for the Si bandgap for Igbinv [V]
    parameter real pigcd = `NOT_GIVEN;           // Parameter for Igc partition
    parameter real poxedge = `NOT_GIVEN;         // Factor for the gate edge Tox
    parameter real ijthsfwd = `NOT_GIVEN;        // Forw S diode forw limiting current [A]
    parameter real ijthdfwd = `NOT_GIVEN;        // Forw D diode forward limiting current [A]
    parameter real ijthsrev = `NOT_GIVEN;        // Rev S diode forward limiting current [A]
    parameter real ijthdrev = `NOT_GIVEN;        // Rev D diode forward limiting current [A]
    parameter real xjbvs = `NOT_GIVEN;           // Fitting parm for S diode brkdown current
    parameter real xjbvd = `NOT_GIVEN;           // Fitting parm for D diode brkdwn current
    parameter real bvs = `NOT_GIVEN;             // Source diode breakdown voltage [V]
    parameter real bvd = `NOT_GIVEN;             // Drain diode breakdown voltage [V]
    parameter real gbmin = `NOT_GIVEN;           // Minimum body conductance
    parameter real rbdb = `NOT_GIVEN;            // Resistance between bNode and dbNode [Ohm]
    parameter real rbpb = `NOT_GIVEN;            // Resistance between bNodePrime and bNode [Ohm]
    parameter real rbsb = `NOT_GIVEN;            // Resistance between bNode and sbNode [Ohm]
    parameter real rbps = `NOT_GIVEN;            // Resistance between bNodePrime and sbNode [Ohm]
    parameter real rbpd = `NOT_GIVEN;            // Resistance between bNodePrime and bNode [Ohm]
    parameter real lcdsc = `NOT_GIVEN;           // Length dependence of cdsc
    parameter real lcdscb = `NOT_GIVEN;          // Length dependence of cdscb
    parameter real lcdscd = `NOT_GIVEN;          // Length dependence of cdscd
    parameter real lcit = `NOT_GIVEN;            // Length dependence of cit
    parameter real lnfactor = `NOT_GIVEN;        // Length dependence of nfactor
    parameter real lxj = `NOT_GIVEN;             // Length dependence of xj
    parameter real lvsat = `NOT_GIVEN;           // Length dependence of vsat
    parameter real lat = `NOT_GIVEN;             // Length dependence of at
    parameter real la0 = `NOT_GIVEN;             // Length dependence of a0
    parameter real lags = `NOT_GIVEN;            // Length dependence of ags
    parameter real la1 = `NOT_GIVEN;             // Length dependence of a1
    parameter real la2 = `NOT_GIVEN;             // Length dependence of a2
    parameter real lketa = `NOT_GIVEN;           // Length dependence of keta
    parameter real lnsub = `NOT_GIVEN;           // Length dependence of nsub
    parameter real lndep = `NOT_GIVEN;           // Length dependence of ndep
    parameter real lnsd = `NOT_GIVEN;            // Length dependence of nsd
    parameter real lphin = `NOT_GIVEN;           // Length dependence of phin
    parameter real lngate = `NOT_GIVEN;          // Length dependence of ngate
    parameter real lgamma1 = `NOT_GIVEN;         // Length dependence of gamma1
    parameter real lgamma2 = `NOT_GIVEN;         // Length dependence of gamma2
    parameter real lvbx = `NOT_GIVEN;            // Length dependence of vbx
    parameter real lvbm = `NOT_GIVEN;            // Length dependence of vbm
    parameter real lxt = `NOT_GIVEN;             // Length dependence of xt
    parameter real lk1 = `NOT_GIVEN;             // Length dependence of k1
    parameter real lkt1 = `NOT_GIVEN;            // Length dependence of kt1
    parameter real lkt1l = `NOT_GIVEN;           // Length dependence of kt1l
    parameter real lkt2 = `NOT_GIVEN;            // Length dependence of kt2
    parameter real lk2 = `NOT_GIVEN;             // Length dependence of k2
    parameter real lk3 = `NOT_GIVEN;             // Length dependence of k3
    parameter real lk3b = `NOT_GIVEN;            // Length dependence of k3b
    parameter real lw0 = `NOT_GIVEN;             // Length dependence of w0
    parameter real ldvtp0 = `NOT_GIVEN;          // Length dependence of dvtp0
    parameter real ldvtp1 = `NOT_GIVEN;          // Length dependence of dvtp1
    parameter real llpe0 = `NOT_GIVEN;           // Length dependence of lpe0
    parameter real llpeb = `NOT_GIVEN;           // Length dependence of lpeb
    parameter real ldvt0 = `NOT_GIVEN;           // Length dependence of dvt0
    parameter real ldvt1 = `NOT_GIVEN;           // Length dependence of dvt1
    parameter real ldvt2 = `NOT_GIVEN;           // Length dependence of dvt2
    parameter real ldvt0w = `NOT_GIVEN;          // Length dependence of dvt0w
    parameter real ldvt1w = `NOT_GIVEN;          // Length dependence of dvt1w
    parameter real ldvt2w = `NOT_GIVEN;          // Length dependence of dvt2w
    parameter real ldrout = `NOT_GIVEN;          // Length dependence of drout
    parameter real ldsub = `NOT_GIVEN;           // Length dependence of dsub
    parameter real lvth0 = `NOT_GIVEN;           // Length dependence of vto
    parameter real lua = `NOT_GIVEN;             // Length dependence of ua
    parameter real lua1 = `NOT_GIVEN;            // Length dependence of ua1
    parameter real lub = `NOT_GIVEN;             // Length dependence of ub
    parameter real lub1 = `NOT_GIVEN;            // Length dependence of ub1
    parameter real luc = `NOT_GIVEN;             // Length dependence of uc
    parameter real luc1 = `NOT_GIVEN;            // Length dependence of uc1
    parameter real lu0 = `NOT_GIVEN;             // Length dependence of u0
    parameter real lute = `NOT_GIVEN;            // Length dependence of ute
    parameter real lvoff = `NOT_GIVEN;           // Length dependence of voff
    parameter real lminv = `NOT_GIVEN;           // Length dependence of minv
    parameter real ldelta = `NOT_GIVEN;          // Length dependence of delta
    parameter real lrdsw = `NOT_GIVEN;           // Length dependence of rdsw
    parameter real lrsw = `NOT_GIVEN;            // Length dependence of rsw
    parameter real lrdw = `NOT_GIVEN;            // Length dependence of rdw
    parameter real lprwg = `NOT_GIVEN;           // Length dependence of prwg
    parameter real lprwb = `NOT_GIVEN;           // Length dependence of prwb
    parameter real lprt = `NOT_GIVEN;            // Length dependence of prt
    parameter real leta0 = `NOT_GIVEN;           // Length dependence of eta0
    parameter real letab = `NOT_GIVEN;           // Length dependence of etab
    parameter real lpclm = `NOT_GIVEN;           // Length dependence of pclm
    parameter real lpdiblc1 = `NOT_GIVEN;        // Length dependence of pdiblc1
    parameter real lpdiblc2 = `NOT_GIVEN;        // Length dependence of pdiblc2
    parameter real lpdiblcb = `NOT_GIVEN;        // Length dependence of pdiblcb
    parameter real lfprout = `NOT_GIVEN;         // Length dependence of pdiblcb
    parameter real lpdits = `NOT_GIVEN;          // Length dependence of pdits
    parameter real lpditsd = `NOT_GIVEN;         // Length dependence of pditsd
    parameter real lpscbe1 = `NOT_GIVEN;         // Length dependence of pscbe1
    parameter real lpscbe2 = `NOT_GIVEN;         // Length dependence of pscbe2
    parameter real lpvag = `NOT_GIVEN;           // Length dependence of pvag
    parameter real lwr = `NOT_GIVEN;             // Length dependence of wr
    parameter real ldwg = `NOT_GIVEN;            // Length dependence of dwg
    parameter real ldwb = `NOT_GIVEN;            // Length dependence of dwb
    parameter real lb0 = `NOT_GIVEN;             // Length dependence of b0
    parameter real lb1 = `NOT_GIVEN;             // Length dependence of b1
    parameter real lcgsl = `NOT_GIVEN;           // Length dependence of cgsl
    parameter real lcgdl = `NOT_GIVEN;           // Length dependence of cgdl
    parameter real lckappas = `NOT_GIVEN;        // Length dependence of ckappas
    parameter real lckappad = `NOT_GIVEN;        // Length dependence of ckappad
    parameter real lcf = `NOT_GIVEN;             // Length dependence of cf
    parameter real lclc = `NOT_GIVEN;            // Length dependence of clc
    parameter real lcle = `NOT_GIVEN;            // Length dependence of cle
    parameter real lalpha0 = `NOT_GIVEN;         // Length dependence of alpha0
    parameter real lalpha1 = `NOT_GIVEN;         // Length dependence of alpha1
    parameter real lbeta0 = `NOT_GIVEN;          // Length dependence of beta0
    parameter real lagidl = `NOT_GIVEN;          // Length dependence of agidl
    parameter real lbgidl = `NOT_GIVEN;          // Length dependence of bgidl
    parameter real lcgidl = `NOT_GIVEN;          // Length dependence of cgidl
    parameter real legidl = `NOT_GIVEN;          // Length dependence of egidl
    parameter real laigc = `NOT_GIVEN;           // Length dependence of aigc
    parameter real lbigc = `NOT_GIVEN;           // Length dependence of bigc
    parameter real lcigc = `NOT_GIVEN;           // Length dependence of cigc
    parameter real laigsd = `NOT_GIVEN;          // Length dependence of aigsd
    parameter real lbigsd = `NOT_GIVEN;          // Length dependence of bigsd
    parameter real lcigsd = `NOT_GIVEN;          // Length dependence of cigsd
    parameter real laigbacc = `NOT_GIVEN;        // Length dependence of aigbacc
    parameter real lbigbacc = `NOT_GIVEN;        // Length dependence of bigbacc
    parameter real lcigbacc = `NOT_GIVEN;        // Length dependence of cigbacc
    parameter real laigbinv = `NOT_GIVEN;        // Length dependence of aigbinv
    parameter real lbigbinv = `NOT_GIVEN;        // Length dependence of bigbinv
    parameter real lcigbinv = `NOT_GIVEN;        // Length dependence of cigbinv
    parameter real lnigc = `NOT_GIVEN;           // Length dependence of nigc
    parameter real lnigbinv = `NOT_GIVEN;        // Length dependence of nigbinv
    parameter real lnigbacc = `NOT_GIVEN;        // Length dependence of nigbacc
    parameter real lntox = `NOT_GIVEN;           // Length dependence of ntox
    parameter real leigbinv = `NOT_GIVEN;        // Length dependence for eigbinv
    parameter real lpigcd = `NOT_GIVEN;          // Length dependence for pigcd
    parameter real lpoxedge = `NOT_GIVEN;        // Length dependence for poxedge
    parameter real lvfbcv = `NOT_GIVEN;          // Length dependence of vfbcv
    parameter real lvfb = `NOT_GIVEN;            // Length dependence of vfb
    parameter real lacde = `NOT_GIVEN;           // Length dependence of acde
    parameter real lmoin = `NOT_GIVEN;           // Length dependence of moin
    parameter real lnoff = `NOT_GIVEN;           // Length dependence of noff
    parameter real lvoffcv = `NOT_GIVEN;         // Length dependence of voffcv
    parameter real lxrcrg1 = `NOT_GIVEN;         // Length dependence of xrcrg1
    parameter real lxrcrg2 = `NOT_GIVEN;         // Length dependence of xrcrg2
    parameter real leu = `NOT_GIVEN;             // Length dependence of eu
    parameter real wcdsc = `NOT_GIVEN;           // Width dependence of cdsc
    parameter real wcdscb = `NOT_GIVEN;          // Width dependence of cdscb
    parameter real wcdscd = `NOT_GIVEN;          // Width dependence of cdscd
    parameter real wcit = `NOT_GIVEN;            // Width dependence of cit
    parameter real wnfactor = `NOT_GIVEN;        // Width dependence of nfactor
    parameter real wxj = `NOT_GIVEN;             // Width dependence of xj
    parameter real wvsat = `NOT_GIVEN;           // Width dependence of vsat
    parameter real wat = `NOT_GIVEN;             // Width dependence of at
    parameter real wa0 = `NOT_GIVEN;             // Width dependence of a0
    parameter real wags = `NOT_GIVEN;            // Width dependence of ags
    parameter real wa1 = `NOT_GIVEN;             // Width dependence of a1
    parameter real wa2 = `NOT_GIVEN;             // Width dependence of a2
    parameter real wketa = `NOT_GIVEN;           // Width dependence of keta
    parameter real wnsub = `NOT_GIVEN;           // Width dependence of nsub
    parameter real wndep = `NOT_GIVEN;           // Width dependence of ndep
    parameter real wnsd = `NOT_GIVEN;            // Width dependence of nsd
    parameter real wphin = `NOT_GIVEN;           // Width dependence of phin
    parameter real wngate = `NOT_GIVEN;          // Width dependence of ngate
    parameter real wgamma1 = `NOT_GIVEN;         // Width dependence of gamma1
    parameter real wgamma2 = `NOT_GIVEN;         // Width dependence of gamma2
    parameter real wvbx = `NOT_GIVEN;            // Width dependence of vbx
    parameter real wvbm = `NOT_GIVEN;            // Width dependence of vbm
    parameter real wxt = `NOT_GIVEN;             // Width dependence of xt
    parameter real wk1 = `NOT_GIVEN;             // Width dependence of k1
    parameter real wkt1 = `NOT_GIVEN;            // Width dependence of kt1
    parameter real wkt1l = `NOT_GIVEN;           // Width dependence of kt1l
    parameter real wkt2 = `NOT_GIVEN;            // Width dependence of kt2
    parameter real wk2 = `NOT_GIVEN;             // Width dependence of k2
    parameter real wk3 = `NOT_GIVEN;             // Width dependence of k3
    parameter real wk3b = `NOT_GIVEN;            // Width dependence of k3b
    parameter real ww0 = `NOT_GIVEN;             // Width dependence of w0
    parameter real wdvtp0 = `NOT_GIVEN;          // Width dependence of dvtp0
    parameter real wdvtp1 = `NOT_GIVEN;          // Width dependence of dvtp1
    parameter real wlpe0 = `NOT_GIVEN;           // Width dependence of lpe0
    parameter real wlpeb = `NOT_GIVEN;           // Width dependence of lpeb
    parameter real wdvt0 = `NOT_GIVEN;           // Width dependence of dvt0
    parameter real wdvt1 = `NOT_GIVEN;           // Width dependence of dvt1
    parameter real wdvt2 = `NOT_GIVEN;           // Width dependence of dvt2
    parameter real wdvt0w = `NOT_GIVEN;          // Width dependence of dvt0w
    parameter real wdvt1w = `NOT_GIVEN;          // Width dependence of dvt1w
    parameter real wdvt2w = `NOT_GIVEN;          // Width dependence of dvt2w
    parameter real wdrout = `NOT_GIVEN;          // Width dependence of drout
    parameter real wdsub = `NOT_GIVEN;           // Width dependence of dsub
    parameter real wvth0 = `NOT_GIVEN;           // Width dependence of vto
    parameter real wua = `NOT_GIVEN;             // Width dependence of ua
    parameter real wua1 = `NOT_GIVEN;            // Width dependence of ua1
    parameter real wub = `NOT_GIVEN;             // Width dependence of ub
    parameter real wub1 = `NOT_GIVEN;            // Width dependence of ub1
    parameter real wuc = `NOT_GIVEN;             // Width dependence of uc
    parameter real wuc1 = `NOT_GIVEN;            // Width dependence of uc1
    parameter real wu0 = `NOT_GIVEN;             // Width dependence of u0
    parameter real wute = `NOT_GIVEN;            // Width dependence of ute
    parameter real wvoff = `NOT_GIVEN;           // Width dependence of voff
    parameter real wminv = `NOT_GIVEN;           // Width dependence of minv
    parameter real wdelta = `NOT_GIVEN;          // Width dependence of delta
    parameter real wrdsw = `NOT_GIVEN;           // Width dependence of rdsw
    parameter real wrsw = `NOT_GIVEN;            // Width dependence of rsw
    parameter real wrdw = `NOT_GIVEN;            // Width dependence of rdw
    parameter real wprwg = `NOT_GIVEN;           // Width dependence of prwg
    parameter real wprwb = `NOT_GIVEN;           // Width dependence of prwb
    parameter real wprt = `NOT_GIVEN;            // Width dependence of prt
    parameter real weta0 = `NOT_GIVEN;           // Width dependence of eta0
    parameter real wetab = `NOT_GIVEN;           // Width dependence of etab
    parameter real wpclm = `NOT_GIVEN;           // Width dependence of pclm
    parameter real wpdiblc1 = `NOT_GIVEN;        // Width dependence of pdiblc1
    parameter real wpdiblc2 = `NOT_GIVEN;        // Width dependence of pdiblc2
    parameter real wpdiblcb = `NOT_GIVEN;        // Width dependence of pdiblcb
    parameter real wfprout = `NOT_GIVEN;         // Width dependence of pdiblcb
    parameter real wpdits = `NOT_GIVEN;          // Width dependence of pdits
    parameter real wpditsd = `NOT_GIVEN;         // Width dependence of pditsd
    parameter real wpscbe1 = `NOT_GIVEN;         // Width dependence of pscbe1
    parameter real wpscbe2 = `NOT_GIVEN;         // Width dependence of pscbe2
    parameter real wpvag = `NOT_GIVEN;           // Width dependence of pvag
    parameter real wwr = `NOT_GIVEN;             // Width dependence of wr
    parameter real wdwg = `NOT_GIVEN;            // Width dependence of dwg
    parameter real wdwb = `NOT_GIVEN;            // Width dependence of dwb
    parameter real wb0 = `NOT_GIVEN;             // Width dependence of b0
    parameter real wb1 = `NOT_GIVEN;             // Width dependence of b1
    parameter real wcgsl = `NOT_GIVEN;           // Width dependence of cgsl
    parameter real wcgdl = `NOT_GIVEN;           // Width dependence of cgdl
    parameter real wckappas = `NOT_GIVEN;        // Width dependence of ckappas
    parameter real wckappad = `NOT_GIVEN;        // Width dependence of ckappad
    parameter real wcf = `NOT_GIVEN;             // Width dependence of cf
    parameter real wclc = `NOT_GIVEN;            // Width dependence of clc
    parameter real wcle = `NOT_GIVEN;            // Width dependence of cle
    parameter real walpha0 = `NOT_GIVEN;         // Width dependence of alpha0
    parameter real walpha1 = `NOT_GIVEN;         // Width dependence of alpha1
    parameter real wbeta0 = `NOT_GIVEN;          // Width dependence of beta0
    parameter real wagidl = `NOT_GIVEN;          // Width dependence of agidl
    parameter real wbgidl = `NOT_GIVEN;          // Width dependence of bgidl
    parameter real wcgidl = `NOT_GIVEN;          // Width dependence of cgidl
    parameter real wegidl = `NOT_GIVEN;          // Width dependence of egidl
    parameter real waigc = `NOT_GIVEN;           // Width dependence of aigc
    parameter real wbigc = `NOT_GIVEN;           // Width dependence of bigc
    parameter real wcigc = `NOT_GIVEN;           // Width dependence of cigc
    parameter real waigsd = `NOT_GIVEN;          // Width dependence of aigsd
    parameter real wbigsd = `NOT_GIVEN;          // Width dependence of bigsd
    parameter real wcigsd = `NOT_GIVEN;          // Width dependence of cigsd
    parameter real waigbacc = `NOT_GIVEN;        // Width dependence of aigbacc
    parameter real wbigbacc = `NOT_GIVEN;        // Width dependence of bigbacc
    parameter real wcigbacc = `NOT_GIVEN;        // Width dependence of cigbacc
    parameter real waigbinv = `NOT_GIVEN;        // Width dependence of aigbinv
    parameter real wbigbinv = `NOT_GIVEN;        // Width dependence of bigbinv
    parameter real wcigbinv = `NOT_GIVEN;        // Width dependence of cigbinv
    parameter real wnigc = `NOT_GIVEN;           // Width dependence of nigc
    parameter real wnigbinv = `NOT_GIVEN;        // Width dependence of nigbinv
    parameter real wnigbacc = `NOT_GIVEN;        // Width dependence of nigbacc
    parameter real wntox = `NOT_GIVEN;           // Width dependence of ntox
    parameter real weigbinv = `NOT_GIVEN;        // Width dependence for eigbinv
    parameter real wpigcd = `NOT_GIVEN;          // Width dependence for pigcd
    parameter real wpoxedge = `NOT_GIVEN;        // Width dependence for poxedge
    parameter real wvfbcv = `NOT_GIVEN;          // Width dependence of vfbcv
    parameter real wvfb = `NOT_GIVEN;            // Width dependence of vfb
    parameter real wacde = `NOT_GIVEN;           // Width dependence of acde
    parameter real wmoin = `NOT_GIVEN;           // Width dependence of moin
    parameter real wnoff = `NOT_GIVEN;           // Width dependence of noff
    parameter real wvoffcv = `NOT_GIVEN;         // Width dependence of voffcv
    parameter real wxrcrg1 = `NOT_GIVEN;         // Width dependence of xrcrg1
    parameter real wxrcrg2 = `NOT_GIVEN;         // Width dependence of xrcrg2
    parameter real weu = `NOT_GIVEN;             // Width dependence of eu
    parameter real pcdsc = `NOT_GIVEN;           // Cross-term dependence of cdsc
    parameter real pcdscb = `NOT_GIVEN;          // Cross-term dependence of cdscb
    parameter real pcdscd = `NOT_GIVEN;          // Cross-term dependence of cdscd
    parameter real pcit = `NOT_GIVEN;            // Cross-term dependence of cit
    parameter real pnfactor = `NOT_GIVEN;        // Cross-term dependence of nfactor
    parameter real pxj = `NOT_GIVEN;             // Cross-term dependence of xj
    parameter real pvsat = `NOT_GIVEN;           // Cross-term dependence of vsat
    parameter real pat = `NOT_GIVEN;             // Cross-term dependence of at
    parameter real pa0 = `NOT_GIVEN;             // Cross-term dependence of a0
    parameter real pags = `NOT_GIVEN;            // Cross-term dependence of ags
    parameter real pa1 = `NOT_GIVEN;             // Cross-term dependence of a1
    parameter real pa2 = `NOT_GIVEN;             // Cross-term dependence of a2
    parameter real pketa = `NOT_GIVEN;           // Cross-term dependence of keta
    parameter real pnsub = `NOT_GIVEN;           // Cross-term dependence of nsub
    parameter real pndep = `NOT_GIVEN;           // Cross-term dependence of ndep
    parameter real pnsd = `NOT_GIVEN;            // Cross-term dependence of nsd
    parameter real pphin = `NOT_GIVEN;           // Cross-term dependence of phin
    parameter real pngate = `NOT_GIVEN;          // Cross-term dependence of ngate
    parameter real pgamma1 = `NOT_GIVEN;         // Cross-term dependence of gamma1
    parameter real pgamma2 = `NOT_GIVEN;         // Cross-term dependence of gamma2
    parameter real pvbx = `NOT_GIVEN;            // Cross-term dependence of vbx
    parameter real pvbm = `NOT_GIVEN;            // Cross-term dependence of vbm
    parameter real pxt = `NOT_GIVEN;             // Cross-term dependence of xt
    parameter real pk1 = `NOT_GIVEN;             // Cross-term dependence of k1
    parameter real pkt1 = `NOT_GIVEN;            // Cross-term dependence of kt1
    parameter real pkt1l = `NOT_GIVEN;           // Cross-term dependence of kt1l
    parameter real pkt2 = `NOT_GIVEN;            // Cross-term dependence of kt2
    parameter real pk2 = `NOT_GIVEN;             // Cross-term dependence of k2
    parameter real pk3 = `NOT_GIVEN;             // Cross-term dependence of k3
    parameter real pk3b = `NOT_GIVEN;            // Cross-term dependence of k3b
    parameter real pw0 = `NOT_GIVEN;             // Cross-term dependence of w0
    parameter real pdvtp0 = `NOT_GIVEN;          // Cross-term dependence of dvtp0
    parameter real pdvtp1 = `NOT_GIVEN;          // Cross-term dependence of dvtp1
    parameter real plpe0 = `NOT_GIVEN;           // Cross-term dependence of lpe0
    parameter real plpeb = `NOT_GIVEN;           // Cross-term dependence of lpeb
    parameter real pdvt0 = `NOT_GIVEN;           // Cross-term dependence of dvt0
    parameter real pdvt1 = `NOT_GIVEN;           // Cross-term dependence of dvt1
    parameter real pdvt2 = `NOT_GIVEN;           // Cross-term dependence of dvt2
    parameter real pdvt0w = `NOT_GIVEN;          // Cross-term dependence of dvt0w
    parameter real pdvt1w = `NOT_GIVEN;          // Cross-term dependence of dvt1w
    parameter real pdvt2w = `NOT_GIVEN;          // Cross-term dependence of dvt2w
    parameter real pdrout = `NOT_GIVEN;          // Cross-term dependence of drout
    parameter real pdsub = `NOT_GIVEN;           // Cross-term dependence of dsub
    parameter real pvth0 = `NOT_GIVEN;           // Cross-term dependence of vto
    parameter real pua = `NOT_GIVEN;             // Cross-term dependence of ua
    parameter real pua1 = `NOT_GIVEN;            // Cross-term dependence of ua1
    parameter real pub = `NOT_GIVEN;             // Cross-term dependence of ub
    parameter real pub1 = `NOT_GIVEN;            // Cross-term dependence of ub1
    parameter real puc = `NOT_GIVEN;             // Cross-term dependence of uc
    parameter real puc1 = `NOT_GIVEN;            // Cross-term dependence of uc1
    parameter real pu0 = `NOT_GIVEN;             // Cross-term dependence of u0
    parameter real pute = `NOT_GIVEN;            // Cross-term dependence of ute
    parameter real pvoff = `NOT_GIVEN;           // Cross-term dependence of voff
    parameter real pminv = `NOT_GIVEN;           // Cross-term dependence of minv
    parameter real pdelta = `NOT_GIVEN;          // Cross-term dependence of delta
    parameter real prdsw = `NOT_GIVEN;           // Cross-term dependence of rdsw
    parameter real prsw = `NOT_GIVEN;            // Cross-term dependence of rsw
    parameter real prdw = `NOT_GIVEN;            // Cross-term dependence of rdw
    parameter real pprwg = `NOT_GIVEN;           // Cross-term dependence of prwg
    parameter real pprwb = `NOT_GIVEN;           // Cross-term dependence of prwb
    parameter real pprt = `NOT_GIVEN;            // Cross-term dependence of prt
    parameter real peta0 = `NOT_GIVEN;           // Cross-term dependence of eta0
    parameter real petab = `NOT_GIVEN;           // Cross-term dependence of etab
    parameter real ppclm = `NOT_GIVEN;           // Cross-term dependence of pclm
    parameter real ppdiblc1 = `NOT_GIVEN;        // Cross-term dependence of pdiblc1
    parameter real ppdiblc2 = `NOT_GIVEN;        // Cross-term dependence of pdiblc2
    parameter real ppdiblcb = `NOT_GIVEN;        // Cross-term dependence of pdiblcb
    parameter real pfprout = `NOT_GIVEN;         // Cross-term dependence of pdiblcb
    parameter real ppdits = `NOT_GIVEN;          // Cross-term dependence of pdits
    parameter real ppditsd = `NOT_GIVEN;         // Cross-term dependence of pditsd
    parameter real ppscbe1 = `NOT_GIVEN;         // Cross-term dependence of pscbe1
    parameter real ppscbe2 = `NOT_GIVEN;         // Cross-term dependence of pscbe2
    parameter real ppvag = `NOT_GIVEN;           // Cross-term dependence of pvag
    parameter real pwr = `NOT_GIVEN;             // Cross-term dependence of wr
    parameter real pdwg = `NOT_GIVEN;            // Cross-term dependence of dwg
    parameter real pdwb = `NOT_GIVEN;            // Cross-term dependence of dwb
    parameter real pb0 = `NOT_GIVEN;             // Cross-term dependence of b0
    parameter real pb1 = `NOT_GIVEN;             // Cross-term dependence of b1
    parameter real pcgsl = `NOT_GIVEN;           // Cross-term dependence of cgsl
    parameter real pcgdl = `NOT_GIVEN;           // Cross-term dependence of cgdl
    parameter real pckappas = `NOT_GIVEN;        // Cross-term dependence of ckappas
    parameter real pckappad = `NOT_GIVEN;        // Cross-term dependence of ckappad
    parameter real pcf = `NOT_GIVEN;             // Cross-term dependence of cf
    parameter real pclc = `NOT_GIVEN;            // Cross-term dependence of clc
    parameter real pcle = `NOT_GIVEN;            // Cross-term dependence of cle
    parameter real palpha0 = `NOT_GIVEN;         // Cross-term dependence of alpha0
    parameter real palpha1 = `NOT_GIVEN;         // Cross-term dependence of alpha1
    parameter real pbeta0 = `NOT_GIVEN;          // Cross-term dependence of beta0
    parameter real pagidl = `NOT_GIVEN;          // Cross-term dependence of agidl
    parameter real pbgidl = `NOT_GIVEN;          // Cross-term dependence of bgidl
    parameter real pcgidl = `NOT_GIVEN;          // Cross-term dependence of cgidl
    parameter real pegidl = `NOT_GIVEN;          // Cross-term dependence of egidl
    parameter real paigc = `NOT_GIVEN;           // Cross-term dependence of aigc
    parameter real pbigc = `NOT_GIVEN;           // Cross-term dependence of bigc
    parameter real pcigc = `NOT_GIVEN;           // Cross-term dependence of cigc
    parameter real paigsd = `NOT_GIVEN;          // Cross-term dependence of aigsd
    parameter real pbigsd = `NOT_GIVEN;          // Cross-term dependence of bigsd
    parameter real pcigsd = `NOT_GIVEN;          // Cross-term dependence of cigsd
    parameter real paigbacc = `NOT_GIVEN;        // Cross-term dependence of aigbacc
    parameter real pbigbacc = `NOT_GIVEN;        // Cross-term dependence of bigbacc
    parameter real pcigbacc = `NOT_GIVEN;        // Cross-term dependence of cigbacc
    parameter real paigbinv = `NOT_GIVEN;        // Cross-term dependence of aigbinv
    parameter real pbigbinv = `NOT_GIVEN;        // Cross-term dependence of bigbinv
    parameter real pcigbinv = `NOT_GIVEN;        // Cross-term dependence of cigbinv
    parameter real pnigc = `NOT_GIVEN;           // Cross-term dependence of nigc
    parameter real pnigbinv = `NOT_GIVEN;        // Cross-term dependence of nigbinv
    parameter real pnigbacc = `NOT_GIVEN;        // Cross-term dependence of nigbacc
    parameter real pntox = `NOT_GIVEN;           // Cross-term dependence of ntox
    parameter real peigbinv = `NOT_GIVEN;        // Cross-term dependence for eigbinv
    parameter real ppigcd = `NOT_GIVEN;          // Cross-term dependence for pigcd
    parameter real ppoxedge = `NOT_GIVEN;        // Cross-term dependence for poxedge
    parameter real pvfbcv = `NOT_GIVEN;          // Cross-term dependence of vfbcv
    parameter real pvfb = `NOT_GIVEN;            // Cross-term dependence of vfb
    parameter real pacde = `NOT_GIVEN;           // Cross-term dependence of acde
    parameter real pmoin = `NOT_GIVEN;           // Cross-term dependence of moin
    parameter real pnoff = `NOT_GIVEN;           // Cross-term dependence of noff
    parameter real pvoffcv = `NOT_GIVEN;         // Cross-term dependence of voffcv
    parameter real pxrcrg1 = `NOT_GIVEN;         // Cross-term dependence of xrcrg1
    parameter real pxrcrg2 = `NOT_GIVEN;         // Cross-term dependence of xrcrg2
    parameter real peu = `NOT_GIVEN;             // Cross-term dependence of eu
    parameter real noia = `NOT_GIVEN;            // Flicker noise parameter
    parameter real noib = `NOT_GIVEN;            // Flicker noise parameter
    parameter real noic = `NOT_GIVEN;            // Flicker noise parameter
    parameter real tnoia = `NOT_GIVEN;           // Thermal noise parameter
    parameter real tnoib = `NOT_GIVEN;           // Thermal noise parameter
    parameter real tnoic = `NOT_GIVEN;           // Thermal noise parameter
    parameter real ntnoi = `NOT_GIVEN;           // Thermal noise parameter
    parameter real em = `NOT_GIVEN;              // Flicker noise parameter
    parameter real ef = `NOT_GIVEN;              // Flicker noise frequency exponent
    parameter real af = `NOT_GIVEN;              // Flicker noise exponent
    parameter real kf = `NOT_GIVEN;              // Flicker noise coeff
   
   //  BSIM4.3
   
    parameter real sa = `NOT_GIVEN;              // Distance between OD edge to Poly [m]
    parameter real sb = `NOT_GIVEN;              // Distance between OD edge to Poly (other side) [m]
    parameter real sd = `NOT_GIVEN;              // Distance between neighboring fingers [m]
    parameter real saref = `NOT_GIVEN;           // Reference distance between OD and edge to poly of one side [m]
    parameter real sbref = `NOT_GIVEN;           // Reference distance between OD and edge to poly of the other side [m]
    parameter real wlod = `NOT_GIVEN;            // Width parameter for stress effect [m]
    parameter real ku0 = `NOT_GIVEN;             // Mobility degradation/enhancement coefficient for stress effect [m]
    parameter real kvsat = `NOT_GIVEN;           // Saturation velocity degradation/enhancement parameter for stress effect [m]
    parameter real tku0 = `NOT_GIVEN;            // Temperature coefficient of KU0
    parameter real lku0 = `NOT_GIVEN;            // Length dependence of ku0
    parameter real wku0 = `NOT_GIVEN;            // Width dependence of ku0
    parameter real pku0 = `NOT_GIVEN;            // Cross-term dependence of ku0
    parameter real llodku0 = `NOT_GIVEN;         // Length parameter for u0 stress effect 
    parameter real wlodku0 = `NOT_GIVEN;         // Width parameter for u0 stress effect 
    parameter real kvth0 = `NOT_GIVEN;           // Threshold shift parameter for stress effect
    parameter real lkvth0 = `NOT_GIVEN;          // Length dependence of kvth0
    parameter real wkvth0 = `NOT_GIVEN;          // Width dependence of kvth0
    parameter real pkvth0  = `NOT_GIVEN;         // Cross-term dependence of kvth0
    parameter real llodvth = `NOT_GIVEN;         // Length parameter for Vth stress effect 
    parameter real wlodvth = `NOT_GIVEN;         // Width parameter for Vth stress effect 
    parameter real stk2 = `NOT_GIVEN;            // K2 shift factor related to Vth0 change [m]
    parameter real lodk2 = `NOT_GIVEN;           // K2 shift modification factor for stress effect 
    parameter real steta0 = `NOT_GIVEN;          // eta0 shift factor related to Vth0 change [m]
    parameter real lodeta0 = `NOT_GIVEN;         // eta0 shift modification factor for stress effect 
    parameter real xn = `NOT_GIVEN;              // Velocity back scattering
    parameter real lxn = `NOT_GIVEN;             // Length dependence of velocity back scattering
    parameter real wxn = `NOT_GIVEN;             // Width dependence of velocity back scattering
    parameter real pxn = `NOT_GIVEN;             // Cross-term dependence of velocity back scattering
    parameter real lambda = `NOT_GIVEN;          // Velocity overshoot coefficient
    parameter real llambda = `NOT_GIVEN;         // Length dependence of velocity overshoot coefficient
    parameter real wlambda = `NOT_GIVEN;         // Width dependence of velocity overshoot coefficient
    parameter real plambda = `NOT_GIVEN;         // Cross-term dependence of velocity overshoot coefficient
    parameter real rnoia = `NOT_GIVEN;           // Thermal noise coefficient
    parameter real rnoib = `NOT_GIVEN;           // Thermal noise coefficient
    parameter real rnoic = `NOT_GIVEN;           // Thermal noise coefficient
    parameter real vtl = `NOT_GIVEN;             // Thermal velocity
    parameter real lvtl = `NOT_GIVEN;            // Length dependence of thermal velocity
    parameter real wvtl = `NOT_GIVEN;            // Width dependence of thermal velocity
    parameter real pvtl = `NOT_GIVEN;            // Cross-term dependence of thermal velocity
    parameter real lc = `NOT_GIVEN;              // Velocity back scattering coefficient [m]
    
    parameter real _ckt_gmin = 1e-12;            // Only for pseudo-body network nodes, tiny one to avoid accuracy issue
    // New model BSIM4 version > 4.3 
    parameter real sc = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real tvoffcv = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wtvoffcv = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ltvoffcv = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ptvoffcv = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real teta0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wteta0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lteta0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pteta0 = `NOT_GIVEN;		//Enh new params version >4.3    
    parameter real rbpdl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpdnf = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real voffcvl = `NOT_GIVEN;	//Enh new params version >4.3    
    parameter real tnfactor = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real wtnfactor = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real ltnfactor = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real ptnfactor = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real minvcv = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wminvcv = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real lminvcv = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real pminvcv = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real tvfbsdoff = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real wtvfbsdoff = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real ltvfbsdoff = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real ptvfbsdoff = `NOT_GIVEN;	//Enh new params version >4.3
    
    parameter integer gidlmod = `INT_NOT_GIVEN;	//Enh new params version >4.3    
    parameter real aigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real waigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real laigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real paigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real bigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wbigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lbigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pbigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real cigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wcigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lcigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pcigs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real aigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real waigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real laigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real paigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real bigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wbigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lbigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pbigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real cigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wcigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lcigd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pcigd = `NOT_GIVEN;		//Enh new params version >4.3    
    parameter real delvto = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ados = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real bdos = `NOT_GIVEN;		//Enh new params version >4.3    
    parameter real agisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wagisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lagisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pagisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real bgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wbgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lbgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pbgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real cgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wcgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lcgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pcgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real egisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wegisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real legisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pegisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wrgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lrgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real prgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real kgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wkgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lkgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pkgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real fgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wfgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lfgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pfgisl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wrgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lrgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real prgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real kgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wkgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lkgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pkgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real fgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wfgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lfgidl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pfgidl = `NOT_GIVEN;		//Enh new params version >4.3

    parameter integer cvchargemod = `INT_NOT_GIVEN;	//Enh new params version >4.3
    parameter real ud = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wud = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lud = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pud = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ud1 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wud1 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lud1 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pud1 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real up = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wup = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lup = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pup = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lp = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wlp = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real llp = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real plp = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ucs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wucs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lucs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pucs = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ucste = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wucste = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lucste = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pucste = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real kvth0we = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real wkvth0we = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real lkvth0we = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real pkvth0we = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real k2we = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wk2we = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lk2we = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pk2we = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ku0we = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wku0we = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real lku0we = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pku0we = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real vfbsdoff = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real wvfbsdoff = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real lvfbsdoff = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real pvfbsdoff = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real tvoff = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wtvoff = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ltvoff = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ptvoff = `NOT_GIVEN;		//Enh new params version >4.3    
    parameter integer wpemod = `INT_NOT_GIVEN;	//Enh new params version >4.3
    parameter real sca = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real scb = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real scc = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real web = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wec = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real scref = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbps0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpsl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpsw = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpsnf = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpd0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpdw = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpbx0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpbxl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpbxw = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpbxnf = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real rbpby0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpbyl = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpbyw = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbpbynf = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real rbsbx0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbsby0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbdbx0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbdby0 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real rbsdbxl = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real rbsdbxw = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real rbsdbxnf = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real rbsdbyl = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real rbsdbyw = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real rbsdbynf = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real jtss = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real jtssws = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real jtsswgs = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real jtweff = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real njts = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real njtssw = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real njtsswg = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real xtss = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real xtssws = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real xtsswgs = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real vtss = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real vtssws = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real vtsswgs = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real tnjts = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real tnjtssw = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real tnjtsswg = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real jtsd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real jtsswd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real jtsswgd = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real njtsd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real njtsswd = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real njtsswgd = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real xtsd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real xtsswd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real xtsswgd = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real vtsd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real vtsswd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real vtsswgd = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real tnjtsd = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real tnjtsswd = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real tnjtsswgd = `NOT_GIVEN;	//Enh new params version >4.3   
    parameter real epsrsub = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real phig = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real easub = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real mtrlcompatmod = `INT_NOT_GIVEN;	//Enh new params version >4.3
    parameter real mtrlmod = `INT_NOT_GIVEN;	//Enh new params version >4.3
    parameter real tempeot = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real leffeot = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real weffeot = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real vddeot = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real eot = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real epsrgate = `NOT_GIVEN;	//Enh new params version >4.3    
    parameter real ni0sub = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real bg0sub = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real tbgasub = `NOT_GIVEN;	//Enh new params version >4.3
    parameter real tbgbsub = `NOT_GIVEN;	//Enh new params version >4.3    
    parameter real dvtp2 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wdvtp2 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ldvtp2 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pdvtp2 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real dvtp3 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wdvtp3 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ldvtp3 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pdvtp3 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real dvtp4 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wdvtp4 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ldvtp4 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pdvtp4 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real dvtp5 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real wdvtp5 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real ldvtp5 = `NOT_GIVEN;		//Enh new params version >4.3
    parameter real pdvtp5 = `NOT_GIVEN;		//Enh new params version >4.3

    //real BSIM4ad, BSIM4as, BSIM4pd, BSIM4ps, BSIM4nrd, BSIM4nrs,BSIM4gcrgs;
    //real BSIM4von, BSIM4qgdo, BSIM4qgso,BSIM4cd,BSIM4vbsc,BSIM4fpkt,BSIM4plcr; 
    //real BSIM4qgate, BSIM4qbulk, BSIM4qdrn, BSIM4qsrc;
    real BSIM4ueff, BSIM4thetavth, BSIM4cgdo, BSIM4cgso;
    real BSIM4grbsb, BSIM4grbdb, BSIM4grbpb, BSIM4grbps, BSIM4grbpd;
    real BSIM4vjsmFwd, BSIM4vjsmRev, BSIM4vjdmFwd, BSIM4vjdmRev, BSIM4XExpBVS;
    real BSIM4XExpBVD, BSIM4SslpFwd, BSIM4SslpRev, BSIM4DslpFwd, BSIM4DslpRev;
    real BSIM4IVjsmFwd, BSIM4IVjsmRev, BSIM4IVjdmFwd, BSIM4IVjdmRev;
    real BSIM4grgeltd, BSIM4Pseff, BSIM4Pdeff, BSIM4Aseff, BSIM4Adeff; 
    real BSIM4l, BSIM4w, BSIM4drainArea, BSIM4sourceArea, BSIM4drainSquares;
    real BSIM4sourceSquares, BSIM4drainPerimeter, BSIM4sourcePerimeter;
    real BSIM4sourceConductance, BSIM4drainConductance, BSIM4rbdb, BSIM4rbsb;
    real BSIM4rbpb, BSIM4rbps, BSIM4rbpd, BSIM4icVDS, BSIM4icVGS, BSIM4icVBS;
    real BSIM4qinv, BSIM4cbd, BSIM4cbs, BSIM4gbd, BSIM4gbs;
    real BSIM4gcrg, BSIM4gcrgd, BSIM4gcrgg,BSIM4gcrgb;
    real BSIM4qbs, BSIM4qbd;
    real BSIM4qchqs, BSIM4taunet;
   
    integer BSIM4nf, BSIM4off, BSIM4mode, BSIM4trnqsMod, BSIM4acnqsMod;
    integer BSIM4rbodyMod, BSIM4rgateMod, BSIM4geoMod, BSIM4rgeoMod;
    integer BSIM4capMod, BSIM4dioMod, BSIM4rdsMod, BSIM4paramChk, BSIM4fnoiMod;
    integer BSIM4tnoiMod, BSIM4igcMod, BSIM4igbMod, BSIM4binUnit, BSIM4min;
    integer BSIM4lGiven, BSIM4wGiven, BSIM4nfGiven, BSIM4minGiven;
    integer BSIM4drainAreaGiven, BSIM4sourceAreaGiven, BSIM4drainSquaresGiven;
    integer BSIM4sourceSquaresGiven, BSIM4drainPerimeterGiven;
    integer BSIM4sourcePerimeterGiven, BSIM4rbdbGiven, BSIM4rbsbGiven;
    integer BSIM4rbpbGiven, BSIM4rbpdGiven, BSIM4rbpsGiven, BSIM4icVDSGiven;
    integer BSIM4icVGSGiven, BSIM4icVBSGiven, BSIM4trnqsModGiven;
    integer BSIM4acnqsModGiven, BSIM4rbodyModGiven, BSIM4rgateModGiven;
    integer BSIM4geoModGiven, BSIM4rgeoModGiven;

    real BSIM4sa, BSIM4sb, BSIM4sd, BSIM4saref, BSIM4sbref, BSIM4wlod, BSIM4ku0;
    real BSIM4kvsat, BSIM4tku0, BSIM4lku0, BSIM4wku0, BSIM4pku0, BSIM4rnoia;
    real BSIM4rnoib, BSIM4rnoic, BSIM4tnoic,BSIM4llodku0, BSIM4wlodku0, BSIM4kvth0, BSIM4lkvth0;
    real BSIM4wkvth0, BSIM4pkvth0, BSIM4llodvth, BSIM4wlodvth, BSIM4stk2;
    real BSIM4lodk2, BSIM4steta0, BSIM4lodeta0;
   
    real BSIM4lambda, BSIM4llambda, BSIM4wlambda, BSIM4plambda;
    real BSIM4vtl, BSIM4lvtl, BSIM4wvtl, BSIM4pvtl;
    real BSIM4xn, BSIM4lxn, BSIM4wxn, BSIM4pxn, BSIM4lc;
    real BSIM4tfactor, BSIM4ku0temp, BSIM4inv_od_ref, BSIM4rho_ref;
    real vs, Fsevl, Inv_saref, Inv_sbref, Inv_sa, Inv_sb, rho, Ldrn, Wdrn;
    real dvth0_lod, W_tmp, Inv_ODeff, OD_offset, dk2_lod, deta0_lod,sceff;
    real BSIM4vfbzbfactor,toxpf,toxpi;

    integer i, niter; 
    integer BSIM4tempMod, BSIM4lambdaGiven, BSIM4llambdaGiven, BSIM4wlambdaGiven;
    integer BSIM4plambdaGiven, BSIM4lcGiven;
    integer BSIM4saGiven, BSIM4sbGiven, BSIM4sdGiven;
    integer BSIM4sarefGiven, BSIM4sbrefGiven, BSIM4wlodGiven, BSIM4rnoiaGiven;
    integer BSIM4rnoibGiven, BSIM4rnoicGiven, BSIM4tnoicGiven;
    integer BSIM4ku0Given, BSIM4kvsatGiven, BSIM4tku0Given;
    integer BSIM4lku0Given, BSIM4wku0Given, BSIM4pku0Given;
    integer BSIM4wlodku0Given, BSIM4kvth0Given, BSIM4lkvth0Given;
    integer BSIM4wkvth0Given, BSIM4pkvth0Given, BSIM4llodvthGiven;
    integer BSIM4wlodvthGiven, BSIM4stk2Given, BSIM4lodk2Given;
    integer BSIM4steta0Given, BSIM4lodeta0Given;
    integer BSIM4vtlGiven, BSIM4lvtlGiven, BSIM4wvtlGiven, BSIM4pvtlGiven;
    integer BSIM4xnGiven, BSIM4lxnGiven, BSIM4wxnGiven, BSIM4pxnGiven;   
    integer BSIM4llodku0Given, BSIM4tempModGiven;
   
    real BSIM4cdsc, BSIM4cdscb, BSIM4cdscd, BSIM4cit, BSIM4nfactor, BSIM4xj;
    real BSIM4vsat, BSIM4at, BSIM4a0, BSIM4ags, BSIM4a1, BSIM4a2, BSIM4keta;
    real BSIM4nsub, BSIM4ndep, BSIM4nsd, BSIM4phin, BSIM4ngate, BSIM4gamma1;
    real BSIM4gamma2, BSIM4vbx, BSIM4vbi, BSIM4vbm, BSIM4xt;
    real BSIM4phi, BSIM4litl, BSIM4k1, BSIM4kt1, BSIM4kt1l, BSIM4kt2, BSIM4k2;
    real BSIM4k3, BSIM4k3b, BSIM4w0, BSIM4dvtp0, BSIM4dvtp1, BSIM4lpe0;
    real BSIM4lpeb, BSIM4dvt0, BSIM4dvt1, BSIM4dvt2, BSIM4dvt0w, BSIM4dvt1w;
    real BSIM4dvt2w, BSIM4drout, BSIM4dsub;      
    real BSIM4vth0, BSIM4ua, BSIM4ua1, BSIM4ub, BSIM4ub1, BSIM4uc, BSIM4uc1;
    real BSIM4u0;
    real BSIM4eu, BSIM4ute, BSIM4voff, BSIM4minv, BSIM4vfb, BSIM4delta, BSIM4rdsw;
    real BSIM4rds0, BSIM4rs0, BSIM4rd0, BSIM4rsw, BSIM4rdw, BSIM4prwg, BSIM4prwb;
    real BSIM4prt, BSIM4eta0, BSIM4etab, BSIM4pclm, BSIM4pdibl1;      
    real BSIM4pdibl2, BSIM4pdiblb, BSIM4fprout, BSIM4pdits, BSIM4pditsd,DITS_Sft2,dDITS_Sft2_dVd;
    real BSIM4pscbe1, BSIM4pscbe2, BSIM4pvag, BSIM4wr;
    real BSIM4dwg, BSIM4dwb, BSIM4b0, BSIM4b1, BSIM4alpha0, BSIM4alpha1;
    real BSIM4beta0;
    real BSIM4cgidl, BSIM4egidl, BSIM4aigc, BSIM4bigc, BSIM4cigc, BSIM4aigsd;
    real BSIM4bigsd, BSIM4cigsd, BSIM4aigbacc, BSIM4agidl, BSIM4bgidl;
    real BSIM4bigbacc, BSIM4cigbacc, BSIM4aigbinv, BSIM4bigbinv, BSIM4cigbinv;
    real BSIM4nigc, BSIM4nigbacc, BSIM4nigbinv, BSIM4ntox;
    real BSIM4eigbinv, BSIM4pigcd, BSIM4poxedge, BSIM4xrcrg1, BSIM4xrcrg2;
    //real  BSIM4plcrl, BSIM4plcrd,BSIM4cof1,BSIM4cof2, BSIM4cof3, BSIM4cof4,BSIM4vfbzb, BSIM4k2ox;

    /* CV model */
    real BSIM4cgsl, BSIM4cgdl, BSIM4ckappas, BSIM4ckappad, BSIM4cf, BSIM4clc;
    real BSIM4cle, BSIM4vfbcv, BSIM4noff, BSIM4voffcv, BSIM4acde, BSIM4moin; 
    real BSIM4dw, BSIM4dl, BSIM4leff, BSIM4weff, BSIM4dwc, BSIM4dlc;
    real BSIM4dlcig, BSIM4dlcigd, BSIM4dwj, BSIM4leffCV, BSIM4weffCV, BSIM4weffCJ;
    real BSIM4abulkCVfactor, BSIM4cgbo, BSIM4u0temp, BSIM4vsattemp, BSIM4sqrtPhi;
    real here_BSIM4vsattemp, here_BSIM4u0temp, here_BSIM4vth0, here_BSIM4vfb;
    real here_BSIM4vfbzb, here_BSIM4vtfbphi1, param_BSIM4kvth0;
    real here_BSIM4vtfbphi2, here_BSIM4vbsc, here_BSIM4k2ox, here_BSIM4eta0;
    real here_BSIM4k2, BSIM4phis3, BSIM4Xdep0, BSIM4sqrtXdep0, BSIM4theta0vb0;
    real BSIM4thetaRout, BSIM4mstar, BSIM4voffcbn, BSIM4rdswmin, BSIM4rdwmin,BSIM4mstarcv,BSIM4voffcbncv;
    real BSIM4rswmin, BSIM4vfbsd;
    real BSIM4cdep0, BSIM4k1ox; 
    //real BSIM4vtfbphi1, BSIM4vtfbphi2; 
    real BSIM4ToxRatio, BSIM4Aechvb, BSIM4Bechvb;
    real BSIM4ToxRatioEdge, BSIM4AechvbEdgeS, BSIM4AechvbEdgeD, BSIM4BechvbEdge, BSIM4ldeb;

    integer BSIM4type, BSIM4mobMod;

    real BSIM4version, BSIM4toxe, BSIM4toxp, BSIM4toxm, BSIM4dtox, BSIM4epsrox;
    real epsroxl, toxel, epssubl;
    real BSIM4voffl, BSIM4lpdibl1, BSIM4lpdibl2, BSIM4lpdiblb, BSIM4wpdibl1;
    real BSIM4wpdibl2, BSIM4wpdiblb, BSIM4ppdibl1, BSIM4ppdibl2, BSIM4ppdiblb;
    real BSIM4pditsl, BSIM4toxref, BSIM4ijthdfwd, BSIM4ijthsfwd, BSIM4ijthdrev;
    real BSIM4ijthsrev, BSIM4xjbvd, BSIM4xjbvs, BSIM4bvd, BSIM4bvs, BSIM4gbmin;
    //real BSIM4noia, BSIM4noib, BSIM4noic, 
    real BSIM4tnoia, BSIM4tnoib, BSIM4ntnoi;

    /* CV model and Parasitics */
    real BSIM4xw, BSIM4xl, BSIM4tcj, BSIM4tcjsw, BSIM4tcjswg, BSIM4tpb;
    real BSIM4tpbsw;
    real BSIM4tpbswg, BSIM4dmcg, BSIM4dmci, BSIM4dmdg, BSIM4dmcgt, BSIM4xgw;
    real BSIM4xgl, BSIM4rsh, BSIM4rshg, BSIM4ngcon;

    /* Length Dependence */
    real BSIM4lcdsc, BSIM4lcdscb, BSIM4lcdscd, BSIM4lcit, BSIM4lnfactor;
    real BSIM4la0, BSIM4lags, BSIM4la1, BSIM4la2, BSIM4lketa, BSIM4lnsub;
    real BSIM4lndep, BSIM4lnsd, BSIM4lxj, BSIM4lvsat, BSIM4lat;         
    real BSIM4lphin, BSIM4lngate, BSIM4lgamma1, BSIM4lgamma2, BSIM4lvbx;
    real BSIM4lvbm, BSIM4lxt, BSIM4lk1, BSIM4lkt1, BSIM4lkt1l, BSIM4lkt2;
    real BSIM4lk2, BSIM4lk3, BSIM4lk3b, BSIM4lw0, BSIM4ldvtp0;
    real BSIM4ldvtp1, BSIM4llpe0, BSIM4llpeb, BSIM4ldvt0, BSIM4ldvt1, BSIM4ldvt2;
    real BSIM4ldvt0w, BSIM4ldvt1w, BSIM4ldvt2w, BSIM4ldrout, BSIM4ldsub;
    real BSIM4lvth0, BSIM4lua, BSIM4lua1, BSIM4lub, BSIM4lub1;
    real BSIM4luc, BSIM4luc1, BSIM4lu0, BSIM4leu, BSIM4lute, BSIM4lvoff;
    real BSIM4lminv;
    real BSIM4ldelta, BSIM4lrdsw, BSIM4lrsw, BSIM4lrdw, BSIM4lprwg, BSIM4lprwb;
    real BSIM4lprt, BSIM4leta0, BSIM4letab;         
    real BSIM4lpclm, BSIM4lfprout, BSIM4lpdits, BSIM4lpditsd, BSIM4lpscbe1;
    real BSIM4lpscbe2, BSIM4lpvag, BSIM4lwr, BSIM4ldwg, BSIM4ldwb, BSIM4lb0;
    real BSIM4lb1, BSIM4lalpha0, BSIM4lalpha1, BSIM4lbeta0;
    real BSIM4lvfb, BSIM4lagidl, BSIM4lbgidl, BSIM4lcgidl, BSIM4legidl;
    real BSIM4laigc, BSIM4lbigc, BSIM4lcigc;
    real BSIM4laigsd, BSIM4lbigsd, BSIM4lcigsd, BSIM4laigbacc, BSIM4lbigbacc;
    real BSIM4lcigbacc, BSIM4laigbinv, BSIM4lbigbinv;
    real BSIM4lcigbinv, BSIM4lnigc, BSIM4lnigbacc, BSIM4lnigbinv, BSIM4lntox;
    real BSIM4leigbinv, BSIM4lpigcd, BSIM4lpoxedge;
    real BSIM4lxrcrg1, BSIM4lxrcrg2;

    /* CV model */
    real BSIM4lcgsl, BSIM4lcgdl, BSIM4lckappas, BSIM4lckappad, BSIM4lcf;
    real BSIM4lclc, BSIM4lcle, BSIM4lvfbcv;
    real BSIM4lnoff, BSIM4lvoffcv, BSIM4lacde, BSIM4lmoin;

    /* Width Dependence */
    real BSIM4wcdsc, BSIM4wcdscb, BSIM4wcdscd, BSIM4wcit, BSIM4wnfactor;
    real BSIM4wxj, BSIM4wvsat, BSIM4wat;         
    real BSIM4wa0, BSIM4wags, BSIM4wa1, BSIM4wa2, BSIM4wketa, BSIM4wnsub;
    real BSIM4wndep, BSIM4wnsd;
    real BSIM4wphin, BSIM4wngate, BSIM4wgamma1, BSIM4wgamma2, BSIM4wvbx;
    real BSIM4wvbm, BSIM4wxt, BSIM4wk1;
    real BSIM4wkt1, BSIM4wkt1l, BSIM4wkt2, BSIM4wk2, BSIM4wk3, BSIM4wk3b;
    real BSIM4ww0, BSIM4wdvtp0, BSIM4wdvtp1, BSIM4wlpe0, BSIM4wlpeb, BSIM4wdvt0;
    real BSIM4wdvt1, BSIM4wdvt2, BSIM4wdvt0w, BSIM4wdvt1w;      
    real BSIM4wdvt2w, BSIM4wdrout, BSIM4wdsub, BSIM4wvth0, BSIM4wua, BSIM4wua1;
    real BSIM4wub, BSIM4wub1, BSIM4wuc, BSIM4wuc1, BSIM4wu0, BSIM4weu, BSIM4wute;
    real BSIM4wvoff, BSIM4wminv, BSIM4wdelta, BSIM4wrdsw, BSIM4wrsw, BSIM4wrdw;
    real BSIM4wprwg, BSIM4wprwb, BSIM4wprt, BSIM4weta0, BSIM4wetab, BSIM4wpclm;
    real BSIM4wfprout, BSIM4wpdits, BSIM4wpditsd, BSIM4wpscbe1, BSIM4wpscbe2;
    real BSIM4wpvag, BSIM4wwr, BSIM4wdwg, BSIM4wdwb, BSIM4wb0, BSIM4wb1;
    real BSIM4walpha0, BSIM4walpha1, BSIM4wbeta0;
    real BSIM4wvfb, BSIM4wagidl, BSIM4wbgidl, BSIM4wcgidl, BSIM4wegidl;
    real BSIM4waigc, BSIM4wbigc, BSIM4wcigc;
    real BSIM4waigsd, BSIM4wbigsd, BSIM4wcigsd, BSIM4waigbacc, BSIM4wbigbacc;
    real BSIM4wcigbacc, BSIM4waigbinv, BSIM4wbigbinv;
    real BSIM4wcigbinv, BSIM4wnigc, BSIM4wnigbacc, BSIM4wnigbinv, BSIM4wntox;
    real BSIM4weigbinv, BSIM4wpigcd, BSIM4wpoxedge, BSIM4wxrcrg1, BSIM4wxrcrg2;

    /* CV model */
    real BSIM4wcgsl, BSIM4wcgdl, BSIM4wckappas, BSIM4wckappad, BSIM4wcf;
    real BSIM4wclc, BSIM4wcle, BSIM4wvfbcv;
    real BSIM4wnoff, BSIM4wvoffcv, BSIM4wacde, BSIM4wmoin;

    /* Cross-term Dependence */
    real BSIM4pcdsc, BSIM4pcdscb, BSIM4pcdscd, BSIM4pcit, BSIM4pnfactor;
    real BSIM4pxj, BSIM4pvsat, BSIM4pat;         
    real BSIM4pa0, BSIM4pags, BSIM4pa1, BSIM4pa2, BSIM4pketa, BSIM4pnsub;
    real BSIM4pndep, BSIM4pnsd;
    real BSIM4pphin, BSIM4pngate, BSIM4pgamma1, BSIM4pgamma2, BSIM4pvbx;
    real BSIM4pvbm, BSIM4pxt, BSIM4pk1;
    real BSIM4pkt1, BSIM4pkt1l, BSIM4pkt2, BSIM4pk2, BSIM4pk3, BSIM4pk3b;
    real BSIM4pw0, BSIM4pdvtp0;
    real BSIM4pdvtp1, BSIM4plpe0, BSIM4plpeb, BSIM4pdvt0, BSIM4pdvt1, BSIM4pdvt2;
    real BSIM4pdvt0w, BSIM4pdvt1w;      
    real BSIM4pdvt2w, BSIM4pdrout, BSIM4pdsub, BSIM4pvth0, BSIM4pua, BSIM4pua1;
    real BSIM4pub, BSIM4pub1;
    real BSIM4puc, BSIM4puc1, BSIM4pu0, BSIM4peu, BSIM4pute, BSIM4pvoff;
    real BSIM4pminv, BSIM4pdelta;
    real BSIM4prdsw, BSIM4prsw, BSIM4prdw, BSIM4pprwg, BSIM4pprwb, BSIM4pprt;
    real BSIM4peta0, BSIM4petab;         
    real BSIM4ppclm, BSIM4pfprout, BSIM4ppdits, BSIM4ppditsd, BSIM4ppscbe1;
    real BSIM4ppscbe2, BSIM4ppvag, BSIM4pwr;
    real BSIM4pdwg, BSIM4pdwb, BSIM4pb0, BSIM4pb1, BSIM4palpha0, BSIM4palpha1;
    real BSIM4pbeta0, BSIM4pvfb;
    real BSIM4pagidl, BSIM4pbgidl, BSIM4pcgidl, BSIM4pegidl, BSIM4paigc;
    real BSIM4pbigc, BSIM4pcigc, BSIM4paigsd;
    real BSIM4pbigsd, BSIM4pcigsd, BSIM4paigbacc, BSIM4pbigbacc, BSIM4pcigbacc;
    real BSIM4paigbinv, BSIM4pbigbinv, BSIM4pcigbinv;
    real BSIM4pnigc, BSIM4pnigbacc, BSIM4pnigbinv, BSIM4pntox, BSIM4peigbinv;
    real BSIM4ppigcd, BSIM4ppoxedge, BSIM4pxrcrg1, BSIM4pxrcrg2;

    /* CV model */
    real BSIM4pcgsl, BSIM4pcgdl, BSIM4pckappas, BSIM4pckappad, BSIM4pcf;
    real BSIM4pclc, BSIM4pcle, BSIM4pvfbcv;
    real BSIM4pnoff, BSIM4pvoffcv, BSIM4pacde, BSIM4pmoin, BSIM4tnom, BSIM4xpart;
    //real BSIM4cFringOut, BSIM4cFringMax;

    real BSIM4SjctTempRevSatCur,BSIM4DjctTempRevSatCur,BSIM4SswTempRevSatCur;
    real BSIM4DswTempRevSatCur,BSIM4SswgTempRevSatCur,BSIM4DswgTempRevSatCur;
    real BSIM4sheetResistance, BSIM4SjctSatCurDensity, BSIM4DjctSatCurDensity;
    real BSIM4SjctSidewallSatCurDensity, BSIM4DjctSidewallSatCurDensity;
    real BSIM4SjctGateSidewallSatCurDensity;
    real BSIM4DjctGateSidewallSatCurDensity, BSIM4SbulkJctPotential;
    real BSIM4DbulkJctPotential, BSIM4SbulkJctBotGradingCoeff;
    real BSIM4DbulkJctBotGradingCoeff, BSIM4SbulkJctSideGradingCoeff;
    real BSIM4DbulkJctSideGradingCoeff, BSIM4SbulkJctGateSideGradingCoeff;
    real BSIM4DbulkJctGateSideGradingCoeff, BSIM4SsidewallJctPotential;
    real BSIM4DsidewallJctPotential, BSIM4SGatesidewallJctPotential;
    real BSIM4DGatesidewallJctPotential, BSIM4SunitAreaJctCap;
    real BSIM4DunitAreaJctCap;
    real BSIM4SunitLengthSidewallJctCap, BSIM4DunitLengthSidewallJctCap;
    real BSIM4SunitLengthGateSidewallJctCap;
    real BSIM4DunitLengthGateSidewallJctCap, BSIM4SjctEmissionCoeff;
    real BSIM4DjctEmissionCoeff, BSIM4SjctTempExponent, BSIM4DjctTempExponent;
    real BSIM4Lint, BSIM4Ll;
    real BSIM4Llc, BSIM4Lln, BSIM4Lw, BSIM4Lwc, BSIM4Lwn, BSIM4Lwl, BSIM4Lwlc;
    real BSIM4Lmin;
    real BSIM4Lmax, BSIM4Wint, BSIM4Wl, BSIM4Wlc, BSIM4Wln, BSIM4Ww, BSIM4Wwc;
    real BSIM4Wwn, BSIM4Wwl, BSIM4Wwlc, BSIM4Wmin, BSIM4Wmax, BSIM4jss, BSIM4jsws;
    real BSIM4jswgs, BSIM4pbs, BSIM4njs, BSIM4xtis, BSIM4mjs, BSIM4pbsws;
    real BSIM4mjsws, BSIM4pbswgs;
    real BSIM4mjswgs, BSIM4cjs, BSIM4cjsws, BSIM4cjswgs, BSIM4jsd, BSIM4jswd;
    real BSIM4jswgd, BSIM4pbd;
    real BSIM4njd, BSIM4xtid, BSIM4mjd, BSIM4pbswd, BSIM4mjswd, BSIM4pbswgd;
    real BSIM4mjswgd, BSIM4cjd;
    real BSIM4cjswd, BSIM4cjswgd;   

    //New model parameters version > 4.3
    real BSIM4sc;
    integer BSIM4scGiven;
    real BSIM4tvoffcv,BSIM4wtvoffcv,BSIM4ltvoffcv,BSIM4ptvoffcv,BSIM4teta0;
    integer BSIM4tvoffcvGiven,BSIM4wtvoffcvGiven,BSIM4ltvoffcvGiven,BSIM4ptvoffcvGiven,BSIM4teta0Given;
    real BSIM4wteta0,BSIM4lteta0,BSIM4pteta0;
    integer BSIM4wteta0Given,BSIM4lteta0Given,BSIM4pteta0Given;
    
    real BSIM4rbpdl,BSIM4rbpdnf,BSIM4voffcvl;
    integer BSIM4rbpdlGiven,BSIM4rbpdnfGiven,BSIM4voffcvlGiven;
    real BSIM4tnfactor,BSIM4wtnfactor,BSIM4ltnfactor,BSIM4ptnfactor,BSIM4minvcv;
    integer BSIM4tnfactorGiven,BSIM4wtnfactorGiven,BSIM4ltnfactorGiven,BSIM4ptnfactorGiven,BSIM4minvcvGiven;
    real BSIM4wminvcv,BSIM4lminvcv,BSIM4pminvcv,BSIM4tvfbsdoff,BSIM4wtvfbsdoff;
    integer BSIM4wminvcvGiven,BSIM4lminvcvGiven,BSIM4pminvcvGiven,BSIM4tvfbsdoffGiven,BSIM4wtvfbsdoffGiven;
    real BSIM4ltvfbsdoff,BSIM4ptvfbsdoff;
    integer BSIM4ltvfbsdoffGiven,BSIM4ptvfbsdoffGiven;
    
    real lnl,lnw,lnnf;
    integer BSIM4gidlMod, BSIM4gidlModGiven,bodymode;
    real BSIM4aigs,BSIM4waigs,BSIM4laigs,BSIM4paigs,BSIM4bigs;
    integer BSIM4aigsGiven,BSIM4waigsGiven,BSIM4laigsGiven,BSIM4paigsGiven,BSIM4bigsGiven;
    real BSIM4wbigs,BSIM4lbigs,BSIM4pbigs,BSIM4cigs,BSIM4wcigs;
    integer BSIM4wbigsGiven,BSIM4lbigsGiven,BSIM4pbigsGiven,BSIM4cigsGiven,BSIM4wcigsGiven;
    real BSIM4lcigs,BSIM4pcigs,BSIM4aigd,BSIM4waigd,BSIM4laigd;
    integer BSIM4lcigsGiven,BSIM4pcigsGiven,BSIM4aigdGiven,BSIM4waigdGiven,BSIM4laigdGiven;
    real BSIM4paigd,BSIM4bigd,BSIM4wbigd,BSIM4lbigd,BSIM4pbigd;
    integer BSIM4paigdGiven,BSIM4bigdGiven,BSIM4wbigdGiven,BSIM4lbigdGiven,BSIM4pbigdGiven;
    real BSIM4cigd,BSIM4wcigd,BSIM4lcigd,BSIM4pcigd;
    integer BSIM4cigdGiven,BSIM4wcigdGiven,BSIM4lcigdGiven,BSIM4pcigdGiven;    
    real BSIM4delvto,BSIM4ados,BSIM4bdos;
    integer BSIM4delvtoGiven,BSIM4adosGiven,BSIM4bdosGiven;
    real BSIM4agisl,BSIM4wagisl,BSIM4lagisl,BSIM4pagisl,BSIM4bgisl;
    integer BSIM4agislGiven,BSIM4wagislGiven,BSIM4lagislGiven,BSIM4pagislGiven,BSIM4bgislGiven;
    real BSIM4wbgisl,BSIM4lbgisl,BSIM4pbgisl,BSIM4cgisl,BSIM4wcgisl;
    integer BSIM4wbgislGiven,BSIM4lbgislGiven,BSIM4pbgislGiven,BSIM4cgislGiven,BSIM4wcgislGiven;
    real BSIM4lcgisl,BSIM4pcgisl,BSIM4egisl,BSIM4wegisl,BSIM4legisl;
    integer BSIM4lcgislGiven,BSIM4pcgislGiven,BSIM4egislGiven,BSIM4wegislGiven,BSIM4legislGiven;
    real BSIM4pegisl,BSIM4rgisl,BSIM4wrgisl,BSIM4lrgisl,BSIM4prgisl;
    integer BSIM4pegislGiven,BSIM4rgislGiven,BSIM4wrgislGiven,BSIM4lrgislGiven,BSIM4prgislGiven;
    real BSIM4kgisl,BSIM4wkgisl,BSIM4lkgisl,BSIM4pkgisl,BSIM4fgisl;
    integer BSIM4kgislGiven,BSIM4wkgislGiven,BSIM4lkgislGiven,BSIM4pkgislGiven,BSIM4fgislGiven;
    real BSIM4wfgisl,BSIM4lfgisl,BSIM4pfgisl,BSIM4rgidl,BSIM4wrgidl;
    integer BSIM4wfgislGiven,BSIM4lfgislGiven,BSIM4pfgislGiven,BSIM4rgidlGiven,BSIM4wrgidlGiven;
    real BSIM4lrgidl,BSIM4prgidl,BSIM4kgidl,BSIM4wkgidl,BSIM4lkgidl;
    integer BSIM4lrgidlGiven,BSIM4prgidlGiven,BSIM4kgidlGiven,BSIM4wkgidlGiven,BSIM4lkgidlGiven;
    real BSIM4pkgidl,BSIM4fgidl,BSIM4wfgidl,BSIM4lfgidl,BSIM4pfgidl;
    integer BSIM4pkgidlGiven,BSIM4fgidlGiven,BSIM4wfgidlGiven,BSIM4lfgidlGiven,BSIM4pfgidlGiven;
    
    real BSIM4dvtp2,BSIM4wdvtp2,BSIM4ldvtp2,BSIM4pdvtp2,BSIM4dvtp3,BSIM4dvtp2factor;
    integer BSIM4dvtp2Given,BSIM4wdvtp2Given,BSIM4ldvtp2Given,BSIM4pdvtp2Given,BSIM4dvtp3Given;
    real BSIM4wdvtp3,BSIM4ldvtp3,BSIM4pdvtp3,BSIM4dvtp4,BSIM4wdvtp4;
    integer BSIM4wdvtp3Given,BSIM4ldvtp3Given,BSIM4pdvtp3Given,BSIM4dvtp4Given,BSIM4wdvtp4Given;
    real BSIM4ldvtp4,BSIM4pdvtp4,BSIM4dvtp5,BSIM4wdvtp5,BSIM4ldvtp5;
    integer BSIM4ldvtp4Given,BSIM4pdvtp4Given,BSIM4dvtp5Given,BSIM4wdvtp5Given,BSIM4ldvtp5Given;
    real BSIM4pdvtp5;
    integer BSIM4pdvtp5Given;
    
    real BSIM4ni0sub,BSIM4bg0sub,BSIM4tbgasub,BSIM4tbgbsub;
    integer BSIM4ni0subGiven,BSIM4bg0subGiven,BSIM4tbgasubGiven,BSIM4tbgbsubGiven;
    real BSIM4tempeot,BSIM4leffeot,BSIM4weffeot,BSIM4vddeot,BSIM4eot,BSIM4epsrgate,vddeotl;
    integer BSIM4tempeotGiven,BSIM4leffeotGiven,BSIM4weffeotGiven,BSIM4vddeotGiven,BSIM4epsrgateGiven,BSIM4eotGiven;
    real BSIM4epsrsub,BSIM4phig,BSIM4easub,BSIM4Eg0;
    integer BSIM4mtrlcompatmod,BSIM4mtrlmod,BSIM4cvchargeMod,BSIM4cvchargeModGiven;
    integer BSIM4epsrsubGiven,BSIM4phigGiven,BSIM4easubGiven,BSIM4mtrlcompatmodGiven,BSIM4mtrlmodGiven;
    real BSIM4ud,BSIM4wud,BSIM4lud,BSIM4pud,BSIM4ud1;
    integer BSIM4udGiven,BSIM4wudGiven,BSIM4ludGiven,BSIM4pudGiven,BSIM4ud1Given;
    real BSIM4wud1,BSIM4lud1,BSIM4pud1,BSIM4up,BSIM4wup;
    integer BSIM4wud1Given,BSIM4lud1Given,BSIM4pud1Given,BSIM4upGiven,BSIM4wupGiven;
    real BSIM4lup,BSIM4pup,BSIM4lp,BSIM4wlp,BSIM4llp;
    integer BSIM4lupGiven,BSIM4pupGiven,BSIM4lpGiven,BSIM4wlpGiven,BSIM4llpGiven;
    real BSIM4plp,BSIM4ucs,BSIM4wucs,BSIM4lucs,BSIM4pucs;
    integer BSIM4plpGiven,BSIM4ucsGiven,BSIM4wucsGiven,BSIM4lucsGiven,BSIM4pucsGiven;
    real BSIM4ucste,BSIM4wucste,BSIM4lucste,BSIM4pucste,BSIM4kvth0we;
    integer BSIM4ucsteGiven,BSIM4wucsteGiven,BSIM4lucsteGiven,BSIM4pucsteGiven,BSIM4kvth0weGiven;
    real BSIM4wkvth0we,BSIM4lkvth0we,BSIM4pkvth0we,BSIM4k2we,BSIM4wk2we;
    integer BSIM4wkvth0weGiven,BSIM4lkvth0weGiven,BSIM4pkvth0weGiven,BSIM4k2weGiven,BSIM4wk2weGiven;
    real BSIM4lk2we,BSIM4pk2we,BSIM4ku0we,BSIM4wku0we,BSIM4lku0we;
    integer BSIM4lk2weGiven,BSIM4pk2weGiven,BSIM4ku0weGiven,BSIM4wku0weGiven,BSIM4lku0weGiven;
    real BSIM4pku0we,BSIM4vfbsdoff,BSIM4wvfbsdoff,BSIM4lvfbsdoff,BSIM4pvfbsdoff;
    integer BSIM4pku0weGiven,BSIM4vfbsdoffGiven,BSIM4wvfbsdoffGiven,BSIM4lvfbsdoffGiven,BSIM4pvfbsdoffGiven;
    real BSIM4tvoff,BSIM4wtvoff,BSIM4ltvoff,BSIM4ptvoff;
    integer BSIM4tvoffGiven,BSIM4wtvoffGiven,BSIM4ltvoffGiven,BSIM4ptvoffGiven;
    real BSIM4wpemod,BSIM4sca,BSIM4scb,BSIM4scc,BSIM4web;
    integer BSIM4wpemodGiven,BSIM4scaGiven,BSIM4scbGiven,BSIM4sccGiven,BSIM4webGiven;
    real BSIM4wec,BSIM4scref,BSIM4rbps0,BSIM4rbpsl,BSIM4rbpsw;
    integer BSIM4wecGiven,BSIM4screfGiven,BSIM4rbps0Given,BSIM4rbpslGiven,BSIM4rbpswGiven;
    real BSIM4rbpsnf,BSIM4rbpd0,BSIM4rbpdw,BSIM4rbpbx0,BSIM4rbpbxl;
    integer BSIM4rbpsnfGiven,BSIM4rbpd0Given,BSIM4rbpdwGiven,BSIM4rbpbx0Given,BSIM4rbpbxlGiven;
    real BSIM4rbpbxw,BSIM4rbpbxnf,BSIM4rbpby0,BSIM4rbpbyl,BSIM4rbpbyw;
    integer BSIM4rbpbxwGiven,BSIM4rbpbxnfGiven,BSIM4rbpby0Given,BSIM4rbpbylGiven,BSIM4rbpbywGiven;
    real BSIM4rbpbynf,BSIM4rbsbx0,BSIM4rbsby0,BSIM4rbdbx0,BSIM4rbdby0;
    integer BSIM4rbpbynfGiven,BSIM4rbsbx0Given,BSIM4rbsby0Given,BSIM4rbdbx0Given,BSIM4rbdby0Given;
    real BSIM4rbsdbxl,BSIM4rbsdbxw,BSIM4rbsdbxnf,BSIM4rbsdbyl,BSIM4rbsdbyw;
    integer BSIM4rbsdbxlGiven,BSIM4rbsdbxwGiven,BSIM4rbsdbxnfGiven,BSIM4rbsdbylGiven,BSIM4rbsdbywGiven;
    real BSIM4rbsdbynf,BSIM4jtss,BSIM4jtssws,BSIM4jtsswgs;
    integer BSIM4rbsdbynfGiven,BSIM4jtssGiven,BSIM4jtsswsGiven,BSIM4jtsswgsGiven;
    real BSIM4jtweff,BSIM4njts,BSIM4njtssw,BSIM4njtsswg,BSIM4xtss;
    integer BSIM4jtweffGiven,BSIM4njtsGiven,BSIM4njtsswGiven,BSIM4njtsswgGiven,BSIM4xtssGiven;
    real BSIM4xtssws,BSIM4xtsswgs,BSIM4vtss,BSIM4vtssws,BSIM4vtsswgs;
    integer BSIM4xtsswsGiven,BSIM4xtsswgsGiven,BSIM4vtssGiven,BSIM4vtsswsGiven,BSIM4vtsswgsGiven;
    real BSIM4tnjts,BSIM4tnjtssw,BSIM4tnjtsswg,BSIM4jtsd,BSIM4jtsswd;
    integer BSIM4tnjtsGiven,BSIM4tnjtsswGiven,BSIM4tnjtsswgGiven,BSIM4jtsdGiven,BSIM4jtsswdGiven;
    real BSIM4jtsswgd,BSIM4njtsd,BSIM4njtsswd,BSIM4njtsswgd;
    integer BSIM4jtsswgdGiven,BSIM4njtsdGiven,BSIM4njtsswdGiven,BSIM4njtsswgdGiven;
    real BSIM4xtsd,BSIM4xtsswd,BSIM4xtsswgd,BSIM4vtsd,BSIM4vtsswd;
    integer BSIM4xtsdGiven,BSIM4xtsswdGiven,BSIM4xtsswgdGiven,BSIM4vtsdGiven,BSIM4vtsswdGiven;
    real BSIM4vtsswgd,BSIM4tnjtsd,BSIM4tnjtsswd,BSIM4tnjtsswgd;
    integer BSIM4vtsswgdGiven,BSIM4tnjtsdGiven,BSIM4tnjtsswdGiven,BSIM4tnjtsswgdGiven;
    real BSIM4VgsteffVth;
    real BSIM4njtsstemp,BSIM4njtsswstemp,BSIM4njtsswgstemp,BSIM4njtsdtemp,BSIM4njtsswdtemp,BSIM4njtsswgdtemp;
    real Nvtmrssws,Nvtmrsswgs,Nvtmrss,Nvtmrsswd,Nvtmrsswgd,Nvtmrsd;


    /* Pre-calculated constants move to size-dependent param */
    real BSIM4vtm, BSIM4coxe, BSIM4coxp, /*BSIM4vcrit,*/ BSIM4factor1;
    real BSIM4PhiBS, BSIM4PhiBSWS, BSIM4PhiBSWGS;
    real BSIM4SjctTempSatCurDensity, BSIM4SjctSidewallTempSatCurDensity;
    real BSIM4SjctGateSidewallTempSatCurDensity;
    real BSIM4PhiBD, BSIM4PhiBSWD, BSIM4PhiBSWGD, BSIM4DjctTempSatCurDensity;
    real BSIM4DjctSidewallTempSatCurDensity;
    real BSIM4DjctGateSidewallTempSatCurDensity, BSIM4SunitAreaTempJctCap;
    real BSIM4DunitAreaTempJctCap;
    real BSIM4SunitLengthSidewallTempJctCap;
    real BSIM4DunitLengthSidewallTempJctCap;
    real BSIM4SunitLengthGateSidewallTempJctCap;
    real BSIM4DunitLengthGateSidewallTempJctCap, BSIM4oxideTrapDensityA;      
    real BSIM4oxideTrapDensityB, BSIM4oxideTrapDensityC, BSIM4em, BSIM4ef;
    real BSIM4af, BSIM4kf, BSIM4perMod;
   

    /* Flags */
    integer BSIM4mobModGiven, BSIM4binUnitGiven, BSIM4capModGiven;
    integer BSIM4dioModGiven, BSIM4rdsModGiven, BSIM4perModGiven;
    integer BSIM4paramChkGiven, BSIM4fnoiModGiven;
    integer BSIM4tnoiModGiven, BSIM4igcModGiven, BSIM4igbModGiven, BSIM4typeGiven;
    integer BSIM4toxrefGiven;
    integer BSIM4toxeGiven, BSIM4toxpGiven, BSIM4toxmGiven;
    integer BSIM4dtoxGiven, BSIM4epsroxGiven, BSIM4versionGiven, BSIM4cdscGiven;
    integer BSIM4cdscbGiven;
    integer BSIM4cdscdGiven, BSIM4citGiven, BSIM4nfactorGiven;
    integer BSIM4xjGiven, BSIM4vsatGiven, BSIM4atGiven, BSIM4a0Given;
    integer BSIM4agsGiven, BSIM4a1Given, BSIM4a2Given, BSIM4ketaGiven;    
    integer BSIM4nsubGiven, BSIM4ndepGiven, BSIM4nsdGiven, BSIM4phinGiven;
    integer BSIM4ngateGiven, BSIM4gamma1Given, BSIM4gamma2Given, BSIM4vbxGiven;
    integer BSIM4vbmGiven, BSIM4xtGiven, BSIM4k1Given, BSIM4kt1Given;
    integer BSIM4kt1lGiven, BSIM4kt2Given, BSIM4k2Given, BSIM4k3Given;
    integer BSIM4k3bGiven, BSIM4w0Given, BSIM4dvtp0Given, BSIM4dvtp1Given;
    integer BSIM4lpe0Given, BSIM4lpebGiven, BSIM4dvt0Given, BSIM4dvt1Given;     
    integer BSIM4dvt2Given, BSIM4dvt0wGiven, BSIM4dvt1wGiven, BSIM4dvt2wGiven;
    integer BSIM4droutGiven, BSIM4dsubGiven, BSIM4vth0Given, BSIM4euGiven;
    integer BSIM4uaGiven, BSIM4ua1Given, BSIM4ubGiven, BSIM4ub1Given;
    integer BSIM4ucGiven, BSIM4uc1Given, BSIM4u0Given, BSIM4uteGiven;
    integer BSIM4voffGiven, BSIM4vofflGiven, BSIM4minvGiven, BSIM4rdswGiven;
    integer BSIM4rdswminGiven, BSIM4rdwminGiven, BSIM4rswminGiven, BSIM4rswGiven;
    integer BSIM4rdwGiven, BSIM4prwgGiven, BSIM4prwbGiven, BSIM4prtGiven;
    integer BSIM4eta0Given, BSIM4etabGiven, BSIM4pclmGiven, BSIM4pdibl1Given;   
    integer BSIM4pdibl2Given, BSIM4pdiblbGiven, BSIM4fproutGiven;
    integer BSIM4pditsGiven, BSIM4pditsdGiven, BSIM4pditslGiven;
    integer BSIM4pscbe1Given, BSIM4pscbe2Given;    
    integer BSIM4pvagGiven, BSIM4deltaGiven, BSIM4wrGiven, BSIM4dwgGiven;
    integer BSIM4dwbGiven, BSIM4b0Given, BSIM4b1Given, BSIM4alpha0Given;
    integer BSIM4alpha1Given, BSIM4beta0Given, BSIM4agidlGiven, BSIM4bgidlGiven;
    integer BSIM4cgidlGiven, BSIM4egidlGiven, BSIM4aigcGiven, BSIM4bigcGiven;
    integer BSIM4cigcGiven, BSIM4aigsdGiven, BSIM4bigsdGiven, BSIM4cigsdGiven;
    integer BSIM4aigbaccGiven, BSIM4bigbaccGiven, BSIM4cigbaccGiven;
    integer BSIM4aigbinvGiven;
    integer BSIM4bigbinvGiven, BSIM4cigbinvGiven, BSIM4nigcGiven;
    integer BSIM4nigbinvGiven, BSIM4nigbaccGiven, BSIM4ntoxGiven;
    integer BSIM4eigbinvGiven, BSIM4pigcdGiven;
    integer BSIM4poxedgeGiven, BSIM4ijthdfwdGiven, BSIM4ijthsfwdGiven;
    integer BSIM4ijthdrevGiven, BSIM4ijthsrevGiven, BSIM4xjbvdGiven;
    integer BSIM4xjbvsGiven, BSIM4bvdGiven;
    integer BSIM4bvsGiven, BSIM4vfbGiven, BSIM4gbminGiven, BSIM4xrcrg1Given;
    integer BSIM4xrcrg2Given, BSIM4tnoiaGiven, BSIM4tnoibGiven, BSIM4ntnoiGiven;
   
    /* CV model and parasitics */ 
    integer BSIM4cgslGiven, BSIM4cgdlGiven, BSIM4ckappasGiven, BSIM4ckappadGiven;
    integer BSIM4cfGiven, BSIM4vfbcvGiven;
    integer BSIM4clcGiven, BSIM4cleGiven, BSIM4dwcGiven, BSIM4dlcGiven;
    integer BSIM4xwGiven, BSIM4xlGiven, BSIM4dlcigGiven, BSIM4dlcigdGiven, BSIM4dwjGiven;
    integer BSIM4noffGiven, BSIM4voffcvGiven, BSIM4acdeGiven, BSIM4moinGiven;
    integer BSIM4tcjGiven, BSIM4tcjswGiven, BSIM4tcjswgGiven, BSIM4tpbGiven;
    integer BSIM4tpbswGiven, BSIM4tpbswgGiven, BSIM4dmcgGiven, BSIM4dmciGiven;
    integer BSIM4dmdgGiven, BSIM4dmcgtGiven, BSIM4xgwGiven, BSIM4xglGiven;
    integer BSIM4rshgGiven, BSIM4ngconGiven; 

    /* Length dependence */ 
    integer BSIM4lcdscGiven, BSIM4lcdscbGiven, BSIM4lcdscdGiven, BSIM4lcitGiven;
    integer BSIM4lnfactorGiven, BSIM4lxjGiven, BSIM4lvsatGiven, BSIM4latGiven;
    integer BSIM4la0Given, BSIM4lagsGiven, BSIM4la1Given, BSIM4la2Given;
    integer BSIM4lketaGiven, BSIM4lnsubGiven, BSIM4lndepGiven, BSIM4lnsdGiven;
    integer BSIM4lphinGiven, BSIM4lngateGiven, BSIM4lgamma1Given;
    integer BSIM4lgamma2Given, BSIM4lvbxGiven, BSIM4lvbmGiven, BSIM4lxtGiven;
    integer BSIM4lk1Given, BSIM4lkt1Given, BSIM4lkt1lGiven, BSIM4lkt2Given;
    integer BSIM4lk2Given;
    integer BSIM4lk3Given, BSIM4lk3bGiven, BSIM4lw0Given, BSIM4ldvtp0Given;
    integer BSIM4ldvtp1Given, BSIM4llpe0Given, BSIM4llpebGiven, BSIM4ldvt0Given;
    integer BSIM4ldvt1Given, BSIM4ldvt2Given, BSIM4ldvt0wGiven, BSIM4ldvt1wGiven;
    integer BSIM4ldvt2wGiven, BSIM4ldroutGiven, BSIM4ldsubGiven, BSIM4lvth0Given;
    integer BSIM4luaGiven, BSIM4lua1Given, BSIM4lubGiven, BSIM4lub1Given;
    integer BSIM4lucGiven, BSIM4luc1Given, BSIM4lu0Given, BSIM4leuGiven;
    integer BSIM4luteGiven, BSIM4lvoffGiven, BSIM4lminvGiven, BSIM4lrdswGiven;
    integer BSIM4lrswGiven, BSIM4lrdwGiven, BSIM4lprwgGiven, BSIM4lprwbGiven;     
    integer BSIM4lprtGiven, BSIM4leta0Given, BSIM4letabGiven, BSIM4lpclmGiven;
    integer BSIM4lpdibl1Given, BSIM4lpdibl2Given, BSIM4lpdiblbGiven;
    integer BSIM4lfproutGiven;
    integer BSIM4lpditsGiven, BSIM4lpditsdGiven, BSIM4lpscbe1Given;
    integer BSIM4lpscbe2Given, BSIM4lpvagGiven, BSIM4ldeltaGiven, BSIM4lwrGiven;
    integer BSIM4ldwgGiven;
    integer BSIM4ldwbGiven, BSIM4lb0Given, BSIM4lb1Given, BSIM4lalpha0Given;
    integer BSIM4lalpha1Given, BSIM4lbeta0Given, BSIM4lvfbGiven, BSIM4lagidlGiven;
    integer BSIM4lbgidlGiven, BSIM4lcgidlGiven, BSIM4legidlGiven;
    integer BSIM4laigcGiven, BSIM4lbigcGiven, BSIM4lcigcGiven, BSIM4laigsdGiven;
    integer BSIM4lbigsdGiven;
    integer BSIM4lcigsdGiven, BSIM4laigbaccGiven, BSIM4lbigbaccGiven;
    integer BSIM4lcigbaccGiven, BSIM4laigbinvGiven, BSIM4lbigbinvGiven;
    integer BSIM4lcigbinvGiven, BSIM4lnigcGiven;
    integer BSIM4lnigbinvGiven, BSIM4lnigbaccGiven, BSIM4lntoxGiven;
    integer BSIM4leigbinvGiven, BSIM4lpigcdGiven, BSIM4lpoxedgeGiven;
    integer BSIM4lxrcrg1Given, BSIM4lxrcrg2Given;

    /* CV model */
    integer BSIM4lcgslGiven, BSIM4lcgdlGiven, BSIM4lckappasGiven;
    integer BSIM4lckappadGiven, BSIM4lcfGiven, BSIM4lclcGiven, BSIM4lcleGiven;
    integer BSIM4lvfbcvGiven;
    integer BSIM4lnoffGiven, BSIM4lvoffcvGiven, BSIM4lacdeGiven, BSIM4lmoinGiven;

    /* Width dependence */
    integer BSIM4wcdscGiven, BSIM4wcdscbGiven, BSIM4wcdscdGiven, BSIM4wcitGiven;
    integer BSIM4wnfactorGiven, BSIM4wxjGiven, BSIM4wvsatGiven, BSIM4watGiven;
    integer BSIM4wa0Given, BSIM4wagsGiven, BSIM4wa1Given, BSIM4wa2Given;
    integer BSIM4wketaGiven, BSIM4wnsubGiven, BSIM4wndepGiven, BSIM4wnsdGiven;
    integer BSIM4wphinGiven, BSIM4wngateGiven, BSIM4wgamma1Given;
    integer BSIM4wgamma2Given, BSIM4wvbxGiven, BSIM4wvbmGiven, BSIM4wxtGiven;
    integer BSIM4wk1Given;
    integer BSIM4wkt1Given, BSIM4wkt1lGiven, BSIM4wkt2Given, BSIM4wk2Given;
    integer BSIM4wk3Given, BSIM4wk3bGiven, BSIM4ww0Given, BSIM4wdvtp0Given;
    integer BSIM4wdvtp1Given, BSIM4wlpe0Given, BSIM4wlpebGiven, BSIM4wdvt0Given;
    integer BSIM4wdvt1Given, BSIM4wdvt2Given, BSIM4wdvt0wGiven, BSIM4wdvt1wGiven; 
    integer BSIM4wdvt2wGiven, BSIM4wdroutGiven, BSIM4wdsubGiven, BSIM4wvth0Given;
    integer BSIM4wuaGiven, BSIM4wua1Given, BSIM4wubGiven, BSIM4wub1Given;
    integer BSIM4wucGiven, BSIM4wuc1Given, BSIM4wu0Given, BSIM4weuGiven;
    integer BSIM4wuteGiven, BSIM4wvoffGiven, BSIM4wminvGiven, BSIM4wrdswGiven;   
    integer BSIM4wrswGiven, BSIM4wrdwGiven, BSIM4wprwgGiven, BSIM4wprwbGiven;
    integer BSIM4wprtGiven, BSIM4weta0Given, BSIM4wetabGiven, BSIM4wpclmGiven;   
    integer BSIM4wpdibl1Given, BSIM4wpdibl2Given, BSIM4wpdiblbGiven;
    integer BSIM4wfproutGiven, BSIM4wpditsGiven, BSIM4wpditsdGiven;
    integer BSIM4wpscbe1Given, BSIM4wpscbe2Given;    
    integer BSIM4wpvagGiven, BSIM4wdeltaGiven, BSIM4wwrGiven, BSIM4wdwgGiven;
    integer BSIM4wdwbGiven, BSIM4wb0Given, BSIM4wb1Given, BSIM4walpha0Given;
    integer BSIM4walpha1Given, BSIM4wbeta0Given, BSIM4wvfbGiven;
    integer BSIM4wagidlGiven, BSIM4wbgidlGiven, BSIM4wcgidlGiven;
    integer BSIM4wegidlGiven, BSIM4waigcGiven;
    integer BSIM4wbigcGiven, BSIM4wcigcGiven, BSIM4waigsdGiven, BSIM4wbigsdGiven;
    integer BSIM4wcigsdGiven, BSIM4waigbaccGiven, BSIM4wbigbaccGiven;
    integer BSIM4wcigbaccGiven;
    integer BSIM4waigbinvGiven, BSIM4wbigbinvGiven, BSIM4wcigbinvGiven;
    integer BSIM4wnigcGiven, BSIM4wnigbinvGiven, BSIM4wnigbaccGiven;
    integer BSIM4wntoxGiven, BSIM4weigbinvGiven;
    integer BSIM4wpigcdGiven, BSIM4wpoxedgeGiven, BSIM4wxrcrg1Given;
    integer BSIM4wxrcrg2Given; 

    /* CV model */ 
    integer BSIM4wcgslGiven, BSIM4wcgdlGiven;
    integer BSIM4wckappasGiven, BSIM4wckappadGiven, BSIM4wcfGiven;
    integer BSIM4wclcGiven, BSIM4wcleGiven, BSIM4wvfbcvGiven, BSIM4wnoffGiven;
    integer BSIM4wvoffcvGiven;
    integer BSIM4wacdeGiven, BSIM4wmoinGiven;

    /* Cross-term dependence */
    integer BSIM4pcdscGiven, BSIM4pcdscbGiven, BSIM4pcdscdGiven, BSIM4pcitGiven;
    integer BSIM4pnfactorGiven, BSIM4pxjGiven, BSIM4pvsatGiven, BSIM4patGiven;
    integer BSIM4pa0Given, BSIM4pagsGiven, BSIM4pa1Given, BSIM4pa2Given;
    integer BSIM4pketaGiven, BSIM4pnsubGiven, BSIM4pndepGiven, BSIM4pnsdGiven;
    integer BSIM4pphinGiven, BSIM4pngateGiven, BSIM4pgamma1Given;
    integer BSIM4pgamma2Given, BSIM4pvbxGiven, BSIM4pvbmGiven, BSIM4pxtGiven;
    integer BSIM4pk1Given;
    integer BSIM4pkt1Given, BSIM4pkt1lGiven, BSIM4pkt2Given, BSIM4pk2Given;
    integer BSIM4pk3Given, BSIM4pk3bGiven, BSIM4pw0Given, BSIM4pdvtp0Given;
    integer BSIM4pdvtp1Given, BSIM4plpe0Given, BSIM4plpebGiven, BSIM4pdvt0Given;
    integer BSIM4pdvt1Given, BSIM4pdvt2Given, BSIM4pdvt0wGiven, BSIM4pdvt1wGiven;
    integer BSIM4pdvt2wGiven, BSIM4pdroutGiven, BSIM4pdsubGiven, BSIM4pvth0Given;
    integer BSIM4puaGiven, BSIM4pua1Given, BSIM4pubGiven, BSIM4pub1Given;
    integer BSIM4pucGiven, BSIM4puc1Given, BSIM4pu0Given, BSIM4peuGiven;
    integer BSIM4puteGiven, BSIM4pvoffGiven, BSIM4pminvGiven, BSIM4prdswGiven; 
    integer BSIM4prswGiven, BSIM4prdwGiven, BSIM4pprwgGiven, BSIM4pprwbGiven;
    integer BSIM4pprtGiven, BSIM4peta0Given, BSIM4petabGiven, BSIM4ppclmGiven;   
    integer BSIM4ppdibl1Given, BSIM4ppdibl2Given, BSIM4ppdiblbGiven;
    integer BSIM4pfproutGiven, BSIM4ppditsGiven, BSIM4ppditsdGiven;
    integer BSIM4ppscbe1Given, BSIM4ppscbe2Given;    
    integer BSIM4ppvagGiven, BSIM4pdeltaGiven, BSIM4pwrGiven, BSIM4pdwgGiven;
    integer BSIM4pdwbGiven, BSIM4pb0Given, BSIM4pb1Given, BSIM4palpha0Given;
    integer BSIM4palpha1Given, BSIM4pbeta0Given, BSIM4pvfbGiven;
    integer BSIM4pagidlGiven, BSIM4pbgidlGiven, BSIM4pcgidlGiven;
    integer BSIM4pegidlGiven, BSIM4paigcGiven;
    integer BSIM4pbigcGiven, BSIM4pcigcGiven, BSIM4paigsdGiven, BSIM4pbigsdGiven;
    integer BSIM4pcigsdGiven, BSIM4paigbaccGiven, BSIM4pbigbaccGiven;
    integer BSIM4pcigbaccGiven;
    integer BSIM4paigbinvGiven, BSIM4pbigbinvGiven, BSIM4pcigbinvGiven;
    integer BSIM4pnigcGiven, BSIM4pnigbinvGiven, BSIM4pnigbaccGiven;
    integer BSIM4pntoxGiven, BSIM4peigbinvGiven;
    integer BSIM4ppigcdGiven, BSIM4ppoxedgeGiven, BSIM4pxrcrg1Given;
    integer BSIM4pxrcrg2Given;

    /* CV model */
    integer BSIM4pcgslGiven, BSIM4pcgdlGiven, BSIM4pckappasGiven;
    integer BSIM4pckappadGiven, BSIM4pcfGiven, BSIM4pclcGiven, BSIM4pcleGiven;
    integer BSIM4pvfbcvGiven;
    integer BSIM4pnoffGiven, BSIM4pvoffcvGiven, BSIM4pacdeGiven, BSIM4pmoinGiven;
    integer BSIM4tnomGiven;
    integer BSIM4cgsoGiven, BSIM4cgdoGiven, BSIM4cgboGiven, BSIM4xpartGiven;
    integer BSIM4sheetResistanceGiven, BSIM4SjctSatCurDensityGiven;
    integer BSIM4SjctSidewallSatCurDensityGiven;
    integer BSIM4SjctGateSidewallSatCurDensityGiven, BSIM4SbulkJctPotentialGiven;
    integer BSIM4SbulkJctBotGradingCoeffGiven, BSIM4SsidewallJctPotentialGiven;
    integer BSIM4SGatesidewallJctPotentialGiven;
    integer BSIM4SbulkJctSideGradingCoeffGiven, BSIM4SunitAreaJctCapGiven;
    integer BSIM4SunitLengthSidewallJctCapGiven;
    integer BSIM4SbulkJctGateSideGradingCoeffGiven;
    integer BSIM4SunitLengthGateSidewallJctCapGiven, BSIM4SjctEmissionCoeffGiven;
    integer BSIM4SjctTempExponentGiven, BSIM4DjctSatCurDensityGiven;
    integer BSIM4DjctSidewallSatCurDensityGiven;
    integer BSIM4DjctGateSidewallSatCurDensityGiven;
    integer BSIM4DbulkJctPotentialGiven, BSIM4DbulkJctBotGradingCoeffGiven;
    integer BSIM4DsidewallJctPotentialGiven, BSIM4DGatesidewallJctPotentialGiven;
    integer BSIM4DbulkJctSideGradingCoeffGiven, BSIM4DunitAreaJctCapGiven;
    integer BSIM4DunitLengthSidewallJctCapGiven;
    integer BSIM4DbulkJctGateSideGradingCoeffGiven;
    integer BSIM4DunitLengthGateSidewallJctCapGiven, BSIM4DjctEmissionCoeffGiven;
    integer BSIM4DjctTempExponentGiven, BSIM4oxideTrapDensityAGiven;
    integer BSIM4oxideTrapDensityBGiven, BSIM4oxideTrapDensityCGiven;
    integer BSIM4emGiven, BSIM4efGiven;     
    integer BSIM4afGiven, BSIM4kfGiven, BSIM4LintGiven, BSIM4LlGiven;
    integer BSIM4LlcGiven, BSIM4LlnGiven, BSIM4LwGiven, BSIM4LwcGiven;
    integer BSIM4LwnGiven, BSIM4LwlGiven, BSIM4LwlcGiven, BSIM4LminGiven;
    integer BSIM4LmaxGiven, BSIM4WintGiven, BSIM4WlGiven, BSIM4WlcGiven;
    integer BSIM4WlnGiven, BSIM4WwGiven, BSIM4WwcGiven, BSIM4WwnGiven;
    integer BSIM4WwlGiven, BSIM4WwlcGiven, BSIM4WminGiven, BSIM4WmaxGiven;


    // The following are used by the macro definitions:
    real ADiso, ADsha, ADmer, ASiso, ASsha, ASmer;
    real PDiso, PDsha, PDmer, PSiso, PSsha, PSmer;
    real nuIntD, nuEndD, nuIntS, nuEndS;
    real Rint, Rend;

    //integer noiseAnalGiven;
    real DMCGeff, DMCIeff, DMDGeff;
    real tmp, tmp1, tmp2, tmp3, tmp4, Eg, Eg0, ni;
    real T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, Lnew, Wnew;
    real delTemp, T, TRatio, Inv_L, Inv_W, Inv_LW, Vtm0, Tnom;
    real dumPs, dumPd, dumAs, dumAd, PowWeffWr;
    real Nvtms, Nvtmd;
    real Rs, Rd;
    real vgs_eff, vgd_eff;
    real vses, vdes;
    real vges, vgms, vged, vgmd;
    real vgmb, qgmb, qgmid;
    real vgdx,vgsx;
    real vbd, vbs, vds, vgb, vgd, vgs;
    real vdbs, vdbd, vsbs;
    real vbs_jct, vbd_jct, SourceSatCurrent, DrainSatCurrent;
    real qgb, VgstNVt, ExpVgst, cdrain;
    //real cdrain, ceqdrn, ceqbd, ceqbs, ceqjd, ceqjs, gjbd, gjbs;
    //real delvbd, delvbs, delvds, delvgd, delvgs;
    //cqgate, cqbody, cqdrn;
    //real Vgsaddvth, Vgsaddvth2,Vgsaddvth1o3; 
    real czbd, czbdsw, czbdswg, czbs, czbssw, czbsswg, evbd, evbs, arg, sarg;
    real Vfbeff, V3, V4;
    real MJD, MJSWD, MJSWGD, MJS, MJSWS, MJSWGS;
    real qgate, qbulk, qdrn, qsrc; 
    real Vdb, Vds, Vgs, Vbs;
    real Igidl, Voxacc, Voxdepinv, VxNVt, ExpVxNVt, Vaux;
    real Igc, Igcs, Igcd, Igs, Igbacc, Igbinv, Igb, Igd, Pigcd;
    real Vgs_eff, Vfb, Vth_NarrowW, dvgs_eff_dvg, dvgd_eff_dvg;
    real Phis, sqrtPhis, Vth, Vgst, Vtm, dVgs_eff_dVg;
    real n, local_voffcv, local_noff;
    real V0, CoxWLcen, QovCox, LINK, VgDP;
    real DeltaPhi, Cox, Tox, Tcen, Ccen, Coxeff;
    real Denomi, ueff, Esat, Vdsat, EsatL;
    real Vasat, Va, Vbseff;
    real Arg1, One_Third_CoxWL, Two_Third_CoxWL, Alphaz, CoxWL; 
    real T10, T11, T12, T13, T14;
    real Abulk, here_Abulk, Abulk0, Cclm, FP, VADITS, Lpe_Vb;
    real VACLM, VADIBL, VASCBE, Xdep, lt1, ltw, Delt_vth;
    real Theta0, TempRatio;
    real DIBL_Sft, dDIBL_Sft_dVd, Lambda;
    real a1l, PvagTerm;
    real Vgsteff, here_Vgsteff, Vdseff, here_Vdseff, VdseffCV, VbseffCV;
    real diffVds, dAbulk_dVg;
    real beta, gche, fgche1, fgche2, Idl;
    real Idsa, Ids, Gm, Gds, Gmb, devbs_dvb, devbd_dvb;
    real Isub, Gbd, Gbg, Gbb;
    real CoxeffWovL, Rds, WVCox, WVCoxRds;
    real Vgst2Vtm, VdsatCV, Leff, Weff, AbulkCV;
    real qcheq, qdef ;
    real qgdo, qgso;
    real Qac0, Qsub0, Igisl;
    real Fatal_Flag, Issi, Iddi;
    real vtfbphi2eot, phieot, TempRatioeot, Vtm0eot, Vtmeot,vbieot;
   
    real flickerNoiseContrib, thermalNoiseContrib; 
    real esat, DelClm, N0, Nl, AbovVgst2Vtm, BSIM4nstar;
    real gspr, gdpr, grdsw, inv_grdsw; 
    real npart_beta, npart_theta, IdovVds;
    real igsquare, Swi, Ssi;
    real BSIM4gstot, BSIM4gdtot;

    // The following are only needed for the tnoiMod==1 
    real dT0_dvg;
    real dT1_dvb;
    real dT3_dvg, dT3_dvb;
    real dT0_dVg, dT0_dVd, dT0_dVb;
    real dT1_dVg, dT1_dVd, dT1_dVb;
    real dT2_dVg, dT2_dVd, dT2_dVb;
    real dT3_dVg, dT3_dVd, dT3_dVb;
    real dT4_dVd, dT4_dVb;
    real dT5_dVb;
    real dT6_dVg, dT6_dVd, dT6_dVb;
    real dT7_dVg, dT7_dVd, dT7_dVb;
    real dT8_dVg, dT8_dVd, dT8_dVb;
    real dT9_dVg, dT9_dVd, dT9_dVb;
    real dT10_dVg, dT10_dVd, dT10_dVb;
    real dgstot_dvg, dgstot_dvd, dgstot_dvb, dgstot_dvs;
    real dgdtot_dvg, dgdtot_dvd, dgdtot_dvb, dgdtot_dvs;
    real dbeta_dVg, dbeta_dVd, dbeta_dVb;
    real dCoxeff_dVg ;
    real dTcen_dVg ;
    real dVasat_dVg, dVasat_dVd, dVasat_dVb;
    real dVdseff_dVg, dVdseff_dVd, dVdseff_dVb;
    real dVdsat_dVg, dVdsat_dVd, dVdsat_dVb;
    real dLambda_dVg;
    real dgche_dVg, dgche_dVd, dgche_dVb;
    real dfgche1_dVg, dfgche1_dVd, dfgche1_dVb;
    real dfgche2_dVg, dfgche2_dVd, dfgche2_dVb;
    real dIdsa_dVg, dIdsa_dVd, dIdsa_dVb;
    real dVASCBE_dVg, dVASCBE_dVd, dVASCBE_dVb;
    real dVADITS_dVg, dVADITS_dVd;
    real dVa_dVg, dVa_dVd, dVa_dVb;
    real dVADIBL_dVg, dVADIBL_dVd, dVADIBL_dVb;
    real dVACLM_dVg, dVACLM_dVd, dVACLM_dVb;
    real dCclm_dVg, dCclm_dVd, dCclm_dVb;
    real dPvagTerm_dVg, dPvagTerm_dVd, dPvagTerm_dVb;
    real dFP_dVg;
    real dIdl_dVg, dIdl_dVd, dIdl_dVb;
    real dEsatL_dVg, dEsatL_dVd, dEsatL_dVb;
    real dAbulk_dVb;
    real dAbulk0_dVb;
    real dn_dVd, dn_dVb;
    real dVth_dVd, dVth_dVb;
    real dRs_dvg, dRs_dvb;
    real dRd_dvg, dRd_dvb;
    real dTheta0_dVb;
    real dDelt_vth_dVb;
    real dDITS_Sft_dVd, dDITS_Sft_dVb;
    real dVgsteff_dVg, dVgsteff_dVd, dVgsteff_dVb;
    real dRds_dVg, dRds_dVb;
    real dWeff_dVg, dWeff_dVb;
    real dDenomi_dVg, dDenomi_dVd, dDenomi_dVb;
    real dueff_dVg, dueff_dVd, dueff_dVb;
    real dVfbeff_dVg, dVfbeff_dVb;
    real dVoxacc_dVg, dVoxacc_dVb;
    real dVoxdepinv_dVg, dVoxdepinv_dVd, dVoxdepinv_dVb;
    real dVaux_dVg, dVaux_dVd, dVaux_dVb;
    real dIgc_dVg, dIgc_dVd, dIgc_dVb;
    real dPigcd_dVg, dPigcd_dVd, dPigcd_dVb;
    real dIgcs_dVg, dIgcs_dVd, dIgcs_dVb;
    real dIgcd_dVg, dIgcd_dVd, dIgcd_dVb;
    real dIgs_dVg, dIgs_dVs;
    real dIgd_dVg, dIgd_dVd;
    real dIgbacc_dVg, dIgbacc_dVb;
    real dIgbinv_dVg, dIgbinv_dVd, dIgbinv_dVb;
    real dVbseff_dVb;
    real dPhis_dVb, dsqrtPhis_dVb, dXdep_dVb, dlt1_dVb, dltw_dVb;

    analog begin

        @(initial_step) begin
            T = $temperature; //move into @initial_step block to avoid va-parsing error
            BSIM4Adeff = 0.0;
            BSIM4Aseff = 0.0;
            BSIM4DslpFwd = 0.0;
            BSIM4DslpRev = 0.0;
            BSIM4DunitAreaTempJctCap = 0.0;
            BSIM4DunitLengthGateSidewallTempJctCap = 0.0;
            BSIM4DunitLengthSidewallTempJctCap = 0.0;
            BSIM4IVjdmFwd = 0.0;
            BSIM4IVjdmRev = 0.0;
            BSIM4IVjsmFwd = 0.0;
            BSIM4IVjsmRev = 0.0;
            BSIM4Pdeff = 0.0;
            BSIM4Pseff = 0.0;
            BSIM4SslpFwd = 0.0;
            BSIM4SslpRev = 0.0;
            BSIM4SunitAreaTempJctCap = 0.0;
            BSIM4SunitLengthGateSidewallTempJctCap = 0.0;
            BSIM4SunitLengthSidewallTempJctCap = 0.0;
            BSIM4af = af;
            BSIM4kf = kf;
            BSIM4ef = ef;
            BSIM4em = em;
            BSIM4cbd = 0.0;
            BSIM4cbs = 0.0;
            BSIM4gbd = 0.0;
            BSIM4gbs = 0.0;
            BSIM4gcrg = 0.0;
            BSIM4gcrgb = 0.0;
            BSIM4gcrgd = 0.0;
            BSIM4gcrgg = 0.0;
            BSIM4grbdb = 0.0;
            BSIM4grbpb = 0.0;
            BSIM4grbpd = 0.0;
            BSIM4grbps = 0.0;
            BSIM4grbsb = 0.0;
            BSIM4icVBS = 0.0;
            BSIM4icVDS = 0.0;
            BSIM4icVGS = 0.0;
            BSIM4qbd = 0.0;
            BSIM4qbs = 0.0;
            BSIM4qchqs = 0.0;
            BSIM4vjdmFwd = 0.0;
            BSIM4vjdmRev = 0.0;
            BSIM4vjsmFwd = 0.0;
            BSIM4vjsmRev = 0.0;
            DrainSatCurrent = 0.0;
            Igd = 0.0;
            Igs = 0.0;
            Nvtmd = 0.0;
            Rd = 0.0;
            Rend = 0.0;
            Rint = 0.0;
            Rs = 0.0;
            Vfb = 0.0;
            Voxacc = 0.0;
            Voxdepinv = 0.0;
            nuEndD = 0.0;
            nuEndS = 0.0;
            nuIntD = 0.0;
            nuIntS = 0.0;
            qbulk = 0.0;
            qdef = 0.0;
            qdrn = 0.0;      
            qgate = 0.0;
            tmp = 0.0;
    
            dVdsat_dVb = 0.0;
            dVdsat_dVd = 0.0;
            dVdsat_dVg = 0.0;
            dVdseff_dVb = 0.0;
            dVdseff_dVd = 0.0;
            dVdseff_dVg = 0.0;
            dVgs_eff_dVg = 0.0;
            dVgsteff_dVb = 0.0;
            dVgsteff_dVd = 0.0;
            dVgsteff_dVg = 0.0;
            dVoxacc_dVb = 0.0;
            dVoxacc_dVg = 0.0;
            dVoxdepinv_dVb = 0.0;
            dVoxdepinv_dVd = 0.0;
            dVoxdepinv_dVg = 0.0;
            dVth_dVb = 0.0;
            dVth_dVd = 0.0;
            dWeff_dVb = 0.0;
            dWeff_dVg = 0.0;
            dXdep_dVb = 0.0;
            dltw_dVb = 0.0;
            dn_dVb = 0.0;
            dn_dVd = 0.0;
            dsqrtPhis_dVb = 0.0;
            dueff_dVb = 0.0;
            dueff_dVd = 0.0;
            dueff_dVg = 0.0;
            grdsw = 0.0;
            inv_grdsw = 0.0;
            BSIM4gdtot= 0.0;
            BSIM4gstot= 0.0;
            BSIM4lxn= 0.0;
            BSIM4pxn= 0.0;
            BSIM4qinv= 0.0;
            BSIM4tfactor= 0.0;
            BSIM4wxn= 0.0;
            ExpVxNVt= 0.0;
            Gds= 0.0;
            Gm= 0.0;
            Gmb= 0.0;
            Igc= 0.0;
            Pigcd= 0.0;
            T6= 0.0;
            Vaux= 0.0;
            Vfbeff= 0.0;
            dAbulk_dVb= 0.0;
            dCclm_dVb= 0.0;
            dCclm_dVd= 0.0;
            dCclm_dVg= 0.0;
            dDelt_vth_dVb= 0.0;
            dEsatL_dVb= 0.0;
            dEsatL_dVd= 0.0;
            dEsatL_dVg= 0.0;
            dFP_dVg= 0.0;
            dIdl_dVb= 0.0;
            dIdl_dVd= 0.0;
            dIdl_dVg= 0.0;
            dIdsa_dVb= 0.0;
            dIdsa_dVd= 0.0;
            dIdsa_dVg= 0.0;
            dLambda_dVg= 0.0;
            dPvagTerm_dVb= 0.0;
            dPvagTerm_dVd= 0.0;
            dPvagTerm_dVg= 0.0;
            dRds_dVb= 0.0;
            dRds_dVg= 0.0;
            dTheta0_dVb= 0.0;
            dVACLM_dVb= 0.0;
            dVACLM_dVd= 0.0;
            dVACLM_dVg= 0.0;
            dVADIBL_dVb= 0.0;
            dVADIBL_dVd= 0.0;
            dVADIBL_dVg= 0.0;
            dVASCBE_dVb= 0.0;
            dVASCBE_dVd= 0.0;
            dVASCBE_dVg= 0.0;
            dVa_dVb= 0.0;
            dVa_dVd= 0.0;
            dVa_dVg= 0.0;
            dVasat_dVb= 0.0;
            dVasat_dVd= 0.0;
            dVasat_dVg= 0.0;
            dVbseff_dVb= 0.0;
    
            BSIM4l = l;
            BSIM4w = w;
            BSIM4nf = nf;
            
            // BSIM4.3
            Ldrn = BSIM4l;
            BSIM4lc = lc;
            BSIM4llodku0 = llodku0;
            BSIM4wlodku0 = wlodku0;
    
            BSIM4rnoia = rnoia;
            BSIM4rnoib = rnoib;      
            BSIM4rnoic = rnoic;      
            
            BSIM4min = _min;
            BSIM4drainArea = ad;
            BSIM4sourceArea = as;
            BSIM4drainSquares = nrd;
            BSIM4sourceSquares = nrs;
            BSIM4sourcePerimeter = ps;
            BSIM4drainPerimeter = pd;
            BSIM4off = off;
            BSIM4trnqsMod = trnqsmod;
            BSIM4acnqsMod = acnqsmod;
            BSIM4rbodyMod = rbodymod;
            BSIM4rgateMod = rgatemod;
            BSIM4geoMod = geomod;
            BSIM4rgeoMod = rgeomod;
            BSIM4capMod = capmod; 
            BSIM4dioMod = diomod;
            BSIM4rdsMod = rdsmod;
            BSIM4fnoiMod = fnoimod;
            BSIM4tnoiMod = tnoimod;
            BSIM4igcMod = igcmod;
            BSIM4igbMod = igbmod;
            
            BSIM4type = type;
            BSIM4mobMod = mobmod;
            BSIM4tempMod = tempmod;
            
            BSIM4binUnit = binunit;
            BSIM4paramChk = paramchk;
            BSIM4perMod = permod;
            BSIM4version = version;
            BSIM4toxe = toxe;
            BSIM4toxp = toxp;
            BSIM4toxm = toxm;
            BSIM4dtox = dtox;
            BSIM4epsrox = epsrox;
            BSIM4cdsc = cdsc;
            BSIM4cdscb = cdscb;
            BSIM4cdscd = cdscd;
            BSIM4cit = cit;
            BSIM4nfactor = nfactor;
            BSIM4xj = xj;
            BSIM4vsat = vsat;
            BSIM4at = at;
            BSIM4a0 = a0;
            BSIM4ags = ags;
            BSIM4a1 = a1;
            BSIM4a2 = a2;
            BSIM4keta = keta;
            BSIM4nsub = nsub;
            BSIM4ndep = ndep;
            BSIM4nsd = nsd;
            BSIM4phin = phin;
            BSIM4ngate = ngate;
            BSIM4gamma1 = gamma1;
            BSIM4gamma2 = gamma2;
            BSIM4vbx = vbx;
            BSIM4vbm = vbm;
            BSIM4xt = xt;
            BSIM4k1 = k1;
            BSIM4kt1 = kt1;
            BSIM4kt1l = kt1l;
            BSIM4kt2 = kt2;
            BSIM4k2 = k2;
            BSIM4k3 = k3;
            BSIM4k3b = k3b;
            BSIM4w0 = w0;
            BSIM4dvtp0 = dvtp0;
            BSIM4dvtp1 = dvtp1;
            BSIM4lpe0 = lpe0;
            BSIM4lpeb = lpeb;
            BSIM4dvt0 = dvt0;
            BSIM4dvt1 = dvt1;
            BSIM4dvt2 = dvt2;
            BSIM4dvt0w = dvt0w;
            BSIM4dvt1w = dvt1w;
            BSIM4dvt2w = dvt2w;
            BSIM4drout = drout;
            BSIM4dsub = dsub;
            BSIM4vth0 = vth0;
            BSIM4eu = eu;
            BSIM4ua = ua;
            BSIM4ua1 = ua1;
            BSIM4ub = ub;
            BSIM4ub1 = ub1;
            BSIM4uc = uc;
            BSIM4uc1 = uc1;
            BSIM4u0 = u0;
            BSIM4ute = ute;
            BSIM4voff = voff;
            BSIM4minv = minv;
            BSIM4voffl = voffl;
            BSIM4delta = delta;
            BSIM4rdsw = rdsw;
            BSIM4rdswmin = rdswmin;
            BSIM4rdwmin = rdwmin;
            BSIM4rswmin = rswmin;
            BSIM4rsw = rsw;
            BSIM4rdw = rdw;
            BSIM4prwg = prwg;
            BSIM4prwb = prwb;
            BSIM4prt = prt;
            BSIM4eta0 = eta0;
            BSIM4etab = etab;
            BSIM4pclm = pclm;
            BSIM4pdibl1 = pdiblc1;
            BSIM4pdibl2 = pdiblc2;
            BSIM4pdiblb = pdiblcb;
            BSIM4lpdibl1 = lpdiblc1;
            BSIM4lpdibl2 = lpdiblc2;
            BSIM4lpdiblb = lpdiblcb;
            BSIM4wpdibl1 = wpdiblc1;
            BSIM4wpdibl2 = wpdiblc2;
            BSIM4wpdiblb = wpdiblcb;
            BSIM4ppdibl1 = ppdiblc1;
            BSIM4ppdibl2 = ppdiblc2;
            BSIM4ppdiblb = ppdiblcb;
            BSIM4fprout = fprout;
            BSIM4pdits = pdits;
            BSIM4pditsd = pditsd;
            BSIM4pditsl = pditsl;
            BSIM4pscbe1 = pscbe1;
            BSIM4pscbe2 = pscbe2;
            BSIM4pvag = pvag;
            BSIM4wr = wr;
            BSIM4dwg = dwg;
            BSIM4dwb = dwb;
            BSIM4b0 = b0;
            BSIM4b1 = b1;
            BSIM4alpha0 = alpha0;
            BSIM4alpha1 = alpha1;
            BSIM4beta0 = beta0;
            BSIM4agidl = agidl;
            BSIM4bgidl = bgidl;
            BSIM4cgidl = cgidl;
            BSIM4egidl = egidl;
            BSIM4aigc = aigc;
            BSIM4bigc = bigc;
            BSIM4cigc = cigc;
            BSIM4aigsd = aigsd;
            BSIM4bigsd = bigsd;
            BSIM4cigsd = cigsd;
            BSIM4aigbacc = aigbacc;
            BSIM4bigbacc = bigbacc;
            BSIM4cigbacc = cigbacc;
            BSIM4aigbinv = aigbinv;
            BSIM4bigbinv = bigbinv;
            BSIM4cigbinv = cigbinv;
            BSIM4nigc = nigc;
            BSIM4nigbacc = nigbacc;
            BSIM4nigbinv = nigbinv;
            BSIM4ntox = ntox;
            BSIM4eigbinv = eigbinv;
            BSIM4pigcd = pigcd;
            BSIM4poxedge = poxedge;
            BSIM4toxref = toxref;
            BSIM4ijthdfwd = ijthdfwd;
            BSIM4ijthsfwd = ijthsfwd;
            BSIM4ijthdrev = ijthdrev;
            BSIM4ijthsrev = ijthsrev;
            BSIM4xjbvd = xjbvd;
            BSIM4xjbvs = xjbvs;
            BSIM4bvd = bvd;
            BSIM4bvs = bvs;
            BSIM4xrcrg1 = xrcrg1;
            BSIM4xrcrg2 = xrcrg2;
            BSIM4vfb = vfb;
            BSIM4gbmin = gbmin;
            BSIM4rbdb = rbdb;
            BSIM4rbsb = rbsb;
            BSIM4rbpb = rbpb;
            BSIM4rbps = rbps;
            BSIM4rbpd = rbpd;
            BSIM4oxideTrapDensityA = noia;
            BSIM4oxideTrapDensityB = noib;
            BSIM4oxideTrapDensityC = noic;
            BSIM4tnoia = tnoia;
            BSIM4tnoib = tnoib;
            BSIM4tnoic = tnoic;
            BSIM4ntnoi = ntnoi;
            BSIM4cgsl = cgsl;
            BSIM4cgdl = cgdl;
            BSIM4ckappas = ckappas;
            BSIM4ckappad = ckappad;
            BSIM4cf = cf;
            BSIM4vfbcv = vfbcv;
            BSIM4clc = clc;
            BSIM4cle = cle;
            BSIM4dwc = dwc;
            BSIM4dlc = dlc;
            BSIM4xw = xw;
            BSIM4xl = xl;
            BSIM4dlcig = dlcig;
            BSIM4dlcigd = dlcigd;
            BSIM4dwj = dwj;
            BSIM4noff = noff;
            BSIM4voffcv = voffcv;
            BSIM4acde = acde;
            BSIM4moin = moin;
            BSIM4tcj = tcj;
            BSIM4tcjsw = tcjsw;
            BSIM4tcjswg = tcjswg;
            BSIM4tpb = tpb;
            BSIM4tpbsw = tpbsw;
            BSIM4tpbswg = tpbswg;
            BSIM4dmcg = dmcg;
            BSIM4dmci = dmci;
            BSIM4dmdg = dmdg;
            BSIM4dmcgt = dmcgt;
            BSIM4xgw = xgw;
            BSIM4xgl = xgl;
            BSIM4rsh = rsh;
            BSIM4rshg = rshg;
            BSIM4ngcon = ngcon;
            BSIM4lcdsc = lcdsc;
            BSIM4lcdscb = lcdscb;
            BSIM4lcdscd = lcdscd;
            BSIM4lcit = lcit;
            BSIM4lnfactor = lnfactor;
            BSIM4lxj = lxj;
            BSIM4lvsat = lvsat;
            BSIM4lat = lat;
            BSIM4la0 = la0;
            BSIM4lags = lags;
            BSIM4la1 = la1;
            BSIM4la2 = la2;
            BSIM4lketa = lketa;
            BSIM4lnsub = lnsub;
            BSIM4lndep = lndep;
            BSIM4lnsd = lnsd;
            BSIM4lphin = lphin;
            BSIM4lngate = lngate;
            BSIM4lgamma1 = lgamma1;
            BSIM4lgamma2 = lgamma2;
            BSIM4lvbx = lvbx;
            BSIM4lvbm = lvbm;
            BSIM4lxt = lxt;
            BSIM4lk1 = lk1;
            BSIM4lkt1 = lkt1;
            BSIM4lkt1l = lkt1l;
            BSIM4lkt2 = lkt2;
            BSIM4lk2 = lk2;
            BSIM4lk3 = lk3;
            BSIM4lk3b = lk3b;
            BSIM4lw0 = lw0;
            BSIM4ldvtp0 = ldvtp0;
            BSIM4ldvtp1 = ldvtp1;
            BSIM4llpe0 = llpe0;
            BSIM4llpeb = llpeb;
            BSIM4ldvt0 = ldvt0;
            BSIM4ldvt1 = ldvt1;
            BSIM4ldvt2 = ldvt2;
            BSIM4ldvt0w = ldvt0w;
            BSIM4ldvt1w = ldvt1w;
            BSIM4ldvt2w = ldvt2w;
            BSIM4ldrout = ldrout;
            BSIM4ldsub = ldsub;
            BSIM4lvth0 = lvth0;
            BSIM4lua = lua;
            BSIM4lua1 = lua1;
            BSIM4lub = lub;
            BSIM4lub1 = lub1;
            BSIM4luc = luc;
            BSIM4luc1 = luc1;
            BSIM4lu0 = lu0;
            BSIM4leu = leu;
            BSIM4lute = lute;
            BSIM4lvoff = lvoff;
            BSIM4lminv = lminv;
            BSIM4ldelta = ldelta;
            BSIM4lrdsw = lrdsw;
            BSIM4lrsw = lrsw;
            BSIM4lrdw = lrdw;
            BSIM4lprwg = lprwg;
            BSIM4lprwb = lprwb;
            BSIM4lprt = lprt;
            BSIM4leta0 = leta0;
            BSIM4letab = letab;
            BSIM4lpclm = lpclm;
            BSIM4lfprout = lfprout;
            BSIM4lpdits = lpdits;
            BSIM4lpditsd = lpditsd;
            BSIM4lpscbe1 = lpscbe1;
            BSIM4lpscbe2 = lpscbe2;
            BSIM4lpvag = lpvag;
            BSIM4lwr = lwr;
            BSIM4ldwg = ldwg;
            BSIM4ldwb = ldwb;
            BSIM4lb0 = lb0;
            BSIM4lb1 = lb1;
            BSIM4lalpha0 = lalpha0;
            BSIM4lalpha1 = lalpha1;
            BSIM4lbeta0 = lbeta0;
            BSIM4lvfb = lvfb;
            BSIM4lagidl = lagidl;
            BSIM4lbgidl = lbgidl;
            BSIM4lcgidl = lcgidl;
            BSIM4legidl = legidl;
            BSIM4laigc = laigc;
            BSIM4lbigc = lbigc;
            BSIM4lcigc = lcigc;
            BSIM4laigsd = laigsd;
            BSIM4lbigsd = lbigsd;
            BSIM4lcigsd = lcigsd;
            BSIM4laigbacc = laigbacc;
            BSIM4lbigbacc = lbigbacc;
            BSIM4lcigbacc = lcigbacc;
            BSIM4laigbinv = laigbinv;
            BSIM4lbigbinv = lbigbinv;
            BSIM4lcigbinv = lcigbinv;
            BSIM4lnigc = lnigc;
            BSIM4lnigbacc = lnigbacc;
            BSIM4lnigbinv = lnigbinv;
            BSIM4lntox = lntox;
            BSIM4leigbinv = leigbinv;
            BSIM4lpigcd = lpigcd;
            BSIM4lpoxedge = lpoxedge;
            BSIM4lxrcrg1 = lxrcrg1;
            BSIM4lxrcrg2 = lxrcrg2;
            BSIM4lcgsl = lcgsl;
            BSIM4lcgdl = lcgdl;
            BSIM4lckappas = lckappas;
            BSIM4lckappad = lckappad;
            BSIM4lcf = lcf;
            BSIM4lclc = lclc;
            BSIM4lcle = lcle;
            BSIM4lvfbcv = lvfbcv;
            BSIM4lnoff = lnoff;
            BSIM4lvoffcv = lvoffcv;
            BSIM4lacde = lacde;
            BSIM4lmoin = lmoin;
            BSIM4wcdsc = wcdsc;
            BSIM4wcdscb = wcdscb;
            BSIM4wcdscd = wcdscd;
            BSIM4wcit = wcit;
            BSIM4wnfactor = wnfactor;
            BSIM4wxj = wxj;
            BSIM4wvsat = wvsat;
            BSIM4wat = wat;
            BSIM4wa0 = wa0;
            BSIM4wags = wags;
            BSIM4wa1 = wa1;
            BSIM4wa2 = wa2;
            BSIM4wketa = wketa;
            BSIM4wnsub = wnsub;
            BSIM4wndep = wndep;
            BSIM4wnsd = wnsd;
            BSIM4wphin = wphin;
            BSIM4wngate = wngate;
            BSIM4wgamma1 = wgamma1;
            BSIM4wgamma2 = wgamma2;
            BSIM4wvbx = wvbx;
            BSIM4wvbm = wvbm;
            BSIM4wxt = wxt;
            BSIM4wk1 = wk1;
            BSIM4wkt1 = wkt1;
            BSIM4wkt1l = wkt1l;
            BSIM4wkt2 = wkt2;
            BSIM4wk2 = wk2;
            BSIM4wk3 = wk3;
            BSIM4wk3b = wk3b;
            BSIM4ww0 = ww0;
            BSIM4wdvtp0 = wdvtp0;
            BSIM4wdvtp1 = wdvtp1;
            BSIM4wlpe0 = wlpe0;
            BSIM4wlpeb = wlpeb;
            BSIM4wdvt0 = wdvt0;
            BSIM4wdvt1 = wdvt1;
            BSIM4wdvt2 = wdvt2;
            BSIM4wdvt0w = wdvt0w;
            BSIM4wdvt1w = wdvt1w;
            BSIM4wdvt2w = wdvt2w;
            BSIM4wdrout = wdrout;
            BSIM4wdsub = wdsub;
            BSIM4wvth0 = wvth0;
            BSIM4wua = wua;
            BSIM4wua1 = wua1;
            BSIM4wub = wub;
            BSIM4wub1 = wub1;
            BSIM4wuc = wuc;
            BSIM4wuc1 = wuc1;
            BSIM4wu0 = wu0;
            BSIM4weu = weu;
            BSIM4wute = wute;
            BSIM4wvoff = wvoff;
            BSIM4wminv = wminv;
            BSIM4wdelta = wdelta;
            BSIM4wrdsw = wrdsw;
            BSIM4wrsw = wrsw;
            BSIM4wrdw = wrdw;
            BSIM4wprwg = wprwg;
            BSIM4wprwb = wprwb;
            BSIM4wprt = wprt;
            BSIM4weta0 = weta0;
            BSIM4wetab = wetab;
            BSIM4wpclm = wpclm;
            BSIM4wfprout = wfprout;
            BSIM4wpdits = wpdits;
            BSIM4wpditsd = wpditsd;
            BSIM4wpscbe1 = wpscbe1;
            BSIM4wpscbe2 = wpscbe2;
            BSIM4wpvag = wpvag;
            BSIM4wwr = wwr;
            BSIM4wdwg = wdwg;
            BSIM4wdwb = wdwb;
            BSIM4wb0 = wb0;
            BSIM4wb1 = wb1;
            BSIM4walpha0 = walpha0;
            BSIM4walpha1 = walpha1;
            BSIM4wbeta0 = wbeta0;
            BSIM4wvfb = wvfb;
            BSIM4wagidl = wagidl;
            BSIM4wbgidl = wbgidl;
            BSIM4wcgidl = wcgidl;
            BSIM4wegidl = wegidl;
            BSIM4waigc = waigc;
            BSIM4wbigc = wbigc;
            BSIM4wcigc = wcigc;
            BSIM4waigsd = waigsd;
            BSIM4wbigsd = wbigsd;
            BSIM4wcigsd = wcigsd;
            BSIM4waigbacc = waigbacc;
            BSIM4wbigbacc = wbigbacc;
            BSIM4wcigbacc = wcigbacc;
            BSIM4waigbinv = waigbinv;
            BSIM4wbigbinv = wbigbinv;
            BSIM4wcigbinv = wcigbinv;
            BSIM4wnigc = wnigc;
            BSIM4wnigbacc = wnigbacc;
            BSIM4wnigbinv = wnigbinv;
            BSIM4wntox = wntox;
            BSIM4weigbinv = weigbinv;
            BSIM4wpigcd = wpigcd;
            BSIM4wpoxedge = wpoxedge;
            BSIM4wxrcrg1 = wxrcrg1;
            BSIM4wxrcrg2 = wxrcrg2;
            BSIM4wcgsl = wcgsl;
            BSIM4wcgdl = wcgdl;
            BSIM4wckappas = wckappas;
            BSIM4wckappad = wckappad;
            BSIM4wcf = wcf;
            BSIM4wclc = wclc;
            BSIM4wcle = wcle;
            BSIM4wvfbcv = wvfbcv;
            BSIM4wnoff = wnoff;
            BSIM4wvoffcv = wvoffcv;
            BSIM4wacde = wacde;
            BSIM4wmoin = wmoin;
            BSIM4pcdsc = pcdsc;
            BSIM4pcdscb = pcdscb;
            BSIM4pcdscd = pcdscd;
            BSIM4pcit = pcit;
            BSIM4pnfactor = pnfactor;
            BSIM4pxj = pxj;
            BSIM4pvsat = pvsat;
            BSIM4pat = pat;
            BSIM4pa0 = pa0;
            BSIM4pags = pags;
            BSIM4pa1 = pa1;
            BSIM4pa2 = pa2;
            BSIM4pketa = pketa;
            BSIM4pnsub = pnsub;
            BSIM4pndep = pndep;
            BSIM4pnsd = pnsd;
            BSIM4pphin = pphin;
            BSIM4pngate = pngate;
            BSIM4pgamma1 = pgamma1;
            BSIM4pgamma2 = pgamma2;
            BSIM4pvbx = pvbx;
            BSIM4pvbm = pvbm;
            BSIM4pxt = pxt;
            BSIM4pk1 = pk1;
            BSIM4pkt1 = pkt1;
            BSIM4pkt1l = pkt1l;
            BSIM4pkt2 = pkt2;
            BSIM4pk2 = pk2;
            BSIM4pk3 = pk3;
            BSIM4pk3b = pk3b;
            BSIM4pw0 = pw0;
            BSIM4pdvtp0 = pdvtp0;
            BSIM4pdvtp1 = pdvtp1;
            BSIM4plpe0 = plpe0;
            BSIM4plpeb = plpeb;
            BSIM4pdvt0 = pdvt0;
            BSIM4pdvt1 = pdvt1;
            BSIM4pdvt2 = pdvt2;
            BSIM4pdvt0w = pdvt0w;
            BSIM4pdvt1w = pdvt1w;
            BSIM4pdvt2w = pdvt2w;
            BSIM4pdrout = pdrout;
            BSIM4pdsub = pdsub;
            BSIM4pvth0 = pvth0;
            BSIM4pua = pua;
            BSIM4pua1 = pua1;
            BSIM4pub = pub;
            BSIM4pub1 = pub1;
            BSIM4puc = puc;
            BSIM4puc1 = puc1;
            BSIM4pu0 = pu0;
            BSIM4peu = peu;
            BSIM4pute = pute;
            BSIM4pvoff = pvoff;
            BSIM4pminv = pminv;
            BSIM4pdelta = pdelta;
            BSIM4prdsw = prdsw;
            BSIM4prsw = prsw;
            BSIM4prdw = prdw;
            BSIM4pprwg = pprwg;
            BSIM4pprwb = pprwb;
            BSIM4pprt = pprt;
            BSIM4peta0 = peta0;
            BSIM4petab = petab;
            BSIM4ppclm = ppclm;
            BSIM4pfprout = pfprout;
            BSIM4ppdits = ppdits;
            BSIM4ppditsd = ppditsd;
            BSIM4ppscbe1 = ppscbe1;
            BSIM4ppscbe2 = ppscbe2;
            BSIM4ppvag = ppvag;
            BSIM4pwr = pwr;
            BSIM4pdwg = pdwg;
            BSIM4pdwb = pdwb;
            BSIM4pb0 = pb0;
            BSIM4pb1 = pb1;
            BSIM4palpha0 = palpha0;
            BSIM4palpha1 = palpha1;
            BSIM4pbeta0 = pbeta0;
            BSIM4pvfb = pvfb;
            BSIM4pagidl = pagidl;
            BSIM4pbgidl = pbgidl;
            BSIM4pcgidl = pcgidl;
            BSIM4pegidl = pegidl;
            BSIM4paigc = paigc;
            BSIM4pbigc = pbigc;
            BSIM4pcigc = pcigc;
            BSIM4paigsd = paigsd;
            BSIM4pbigsd = pbigsd;
            BSIM4pcigsd = pcigsd;
            BSIM4paigbacc = paigbacc;
            BSIM4pbigbacc = pbigbacc;
            BSIM4pcigbacc = pcigbacc;
            BSIM4paigbinv = paigbinv;
            BSIM4pbigbinv = pbigbinv;
            BSIM4pcigbinv = pcigbinv;
            BSIM4pnigc = pnigc;
            BSIM4pnigbacc = pnigbacc;
            BSIM4pnigbinv = pnigbinv;
            BSIM4pntox = pntox;
            BSIM4peigbinv = peigbinv;
            BSIM4ppigcd = ppigcd;
            BSIM4ppoxedge = ppoxedge;
            BSIM4pxrcrg1 = pxrcrg1;
            BSIM4pxrcrg2 = pxrcrg2;
            BSIM4pcgsl = pcgsl;
            BSIM4pcgdl = pcgdl;
            BSIM4pckappas = pckappas;
            BSIM4pckappad = pckappad;
            BSIM4pcf = pcf;
            BSIM4pclc = pclc;
            BSIM4pcle = pcle;
            BSIM4pvfbcv = pvfbcv;
            BSIM4pnoff = pnoff;
            BSIM4pvoffcv = pvoffcv;
            BSIM4pacde = pacde;
            BSIM4pmoin = pmoin;
            BSIM4tnom = tnom;
            BSIM4cgso = cgso;
            BSIM4cgdo = cgdo;
            BSIM4cgbo = cgbo;
            BSIM4xpart = xpart;
            BSIM4sheetResistance = rsh;
            BSIM4SjctSatCurDensity = jss;
            BSIM4DjctSatCurDensity = jsd;
            BSIM4SjctSidewallSatCurDensity = jsws;
            BSIM4DjctSidewallSatCurDensity = jswd;
            BSIM4SjctGateSidewallSatCurDensity = jswgs;
            BSIM4DjctGateSidewallSatCurDensity = jswgd;
            BSIM4SbulkJctPotential = pbs;
            BSIM4DbulkJctPotential = pbd;
            BSIM4SbulkJctBotGradingCoeff = mjs;
            BSIM4DbulkJctBotGradingCoeff = mjd;
            BSIM4SbulkJctSideGradingCoeff = mjsws; 
            BSIM4DbulkJctSideGradingCoeff = mjswd;
            BSIM4SbulkJctGateSideGradingCoeff = mjswgs;
            BSIM4DbulkJctGateSideGradingCoeff = mjswgd;
            BSIM4SsidewallJctPotential = pbsws;
            BSIM4DsidewallJctPotential = pbswd;
            BSIM4SGatesidewallJctPotential = pbswgs;
            BSIM4DGatesidewallJctPotential = pbswgd;
            BSIM4SunitAreaJctCap = cjs;
            BSIM4DunitAreaJctCap = cjd;
            BSIM4SunitLengthSidewallJctCap = cjsws;
            BSIM4DunitLengthSidewallJctCap = cjswd;
            BSIM4SunitLengthGateSidewallJctCap = cjswgs;
            BSIM4DunitLengthGateSidewallJctCap = cjswgd;
            BSIM4SjctEmissionCoeff = njs;
            BSIM4DjctEmissionCoeff = njd;
            BSIM4SjctTempExponent = xtis;
            BSIM4DjctTempExponent = xtid;
            BSIM4Lint = lint;
            BSIM4Ll = ll;
            BSIM4Llc = llc;
            BSIM4Lln = lln;
            BSIM4Lw = lw;
            BSIM4Lwc = lwc;
            BSIM4Lwn = lwn;
            BSIM4Lwl = lwl;
            BSIM4Lwlc = lwlc;
            BSIM4Lmin = lmin;
            BSIM4Lmax = lmax;
            BSIM4Wint = wint;
            BSIM4Wl = wl;
            BSIM4Wlc = wlc;
            BSIM4Wln = wln;
            BSIM4Ww = ww;
            BSIM4Wwc = wwc;
            BSIM4Wwn = wwn;
            BSIM4Wwl = wwl;
            BSIM4Wwlc = wwlc;
            BSIM4Wmin = wmin;
            BSIM4Wmax = wmax;
            BSIM4jss = jss;
            BSIM4jsws = jsws;
            BSIM4jswgs = jswgs;
            BSIM4pbs = pbs;
            BSIM4njs = njs;
            BSIM4xtis = xtis;
            BSIM4mjs = mjs;
            BSIM4pbsws = pbsws;
            BSIM4mjsws = mjsws;
            BSIM4pbswgs = pbswgs;
            BSIM4mjswgs = mjswgs;
            BSIM4cjs = cjs;
            BSIM4cjsws = cjsws;
            BSIM4cjswgs = cjswgs;
            BSIM4jsd = jsd;
            BSIM4jswd = jswd;
            BSIM4jswgd = jswgd;
            BSIM4pbd = pbd;
            BSIM4njd = njd;
            BSIM4xtid = xtid;
            BSIM4mjd = mjd;
            BSIM4pbswd = pbswd;
            BSIM4mjswd = mjswd;
            BSIM4pbswgd = pbswgd;
            BSIM4mjswgd = mjswgd;
            BSIM4cjd = cjd;
            BSIM4cjswd = cjswd;
            BSIM4cjswgd = cjswgd;
    
            // BSIM4.3
            BSIM4lambda = lambda;
            BSIM4llambda = llambda;
            BSIM4wlambda = wlambda;
            BSIM4plambda = plambda;
            BSIM4vtl = vtl;
            BSIM4lvtl = lvtl;
            BSIM4wvtl = wvtl;
            BSIM4pvtl = pvtl;
            BSIM4xn = xn;      
             
            BSIM4sa = sa; 
            BSIM4sb = sb; 
            BSIM4sd = sd; 
            BSIM4saref = saref;
            BSIM4sbref = sbref;
            BSIM4wlod = wlod;
            BSIM4ku0 = ku0;
            BSIM4kvsat = kvsat;
            BSIM4tku0 = tku0;
            BSIM4lku0 = lku0;
            BSIM4wku0 = wku0;
            BSIM4pku0 = pku0;
            BSIM4kvth0 = kvth0;
            BSIM4wlodku0 = wlodku0;
            BSIM4lkvth0 = lkvth0;
            BSIM4wkvth0 = wkvth0;
            BSIM4pkvth0 = pkvth0;
            BSIM4llodvth = llodvth;
            BSIM4wlodvth = wlodvth;
            BSIM4stk2 = stk2;
            BSIM4lodk2 = lodk2;
            BSIM4steta0 = steta0;
            BSIM4lodeta0 = lodeta0;

            //New model version > 4.3
            BSIM4sc = sc;
            BSIM4tvoffcv = tvoffcv;
            BSIM4wtvoffcv = wtvoffcv;
            BSIM4ltvoffcv = ltvoffcv;
            BSIM4ptvoffcv = ptvoffcv;
            BSIM4teta0 = teta0;
            BSIM4wteta0 = wteta0;
            BSIM4lteta0 = lteta0;
            BSIM4pteta0 = pteta0;
            
            BSIM4rbpdl = rbpdl;
            BSIM4rbpdnf = rbpdnf;
            BSIM4voffcvl = voffcvl;
            
            BSIM4tnfactor = tnfactor;
            BSIM4wtnfactor = wtnfactor;
            BSIM4ltnfactor = ltnfactor;
            BSIM4ptnfactor = ptnfactor;
            BSIM4minvcv = minvcv;
            BSIM4wminvcv = wminvcv;
            BSIM4lminvcv = lminvcv;
            BSIM4pminvcv = pminvcv;
            BSIM4tvfbsdoff = tvfbsdoff;
            BSIM4wtvfbsdoff = wtvfbsdoff;
            BSIM4ltvfbsdoff = ltvfbsdoff;
            BSIM4ptvfbsdoff = ptvfbsdoff;
            
            BSIM4gidlMod = gidlmod;
            BSIM4aigs = aigs;
            BSIM4waigs = waigs;
            BSIM4laigs = laigs;
            BSIM4paigs = paigs;
            BSIM4bigs = bigs;
            BSIM4wbigs = wbigs;
            BSIM4lbigs = lbigs;
            BSIM4pbigs = pbigs;
            BSIM4cigs = cigs;
            BSIM4wcigs = wcigs;
            BSIM4lcigs = lcigs;
            BSIM4pcigs = pcigs;
            BSIM4aigd = aigd;
            BSIM4waigd = waigd;
            BSIM4laigd = laigd;
            BSIM4paigd = paigd;
            BSIM4bigd = bigd;
            BSIM4wbigd = wbigd;
            BSIM4lbigd = lbigd;
            BSIM4pbigd = pbigd;
            BSIM4cigd = cigd;
            BSIM4wcigd = wcigd;
            BSIM4lcigd = lcigd;
            BSIM4pcigd = pcigd;
            BSIM4delvto = delvto;
            BSIM4ados = ados;
            BSIM4bdos = bdos;
            BSIM4agisl = agisl;
            BSIM4wagisl = wagisl;
            BSIM4lagisl = lagisl;
            BSIM4pagisl = pagisl;
            BSIM4bgisl = bgisl;
            BSIM4wbgisl = wbgisl;
            BSIM4lbgisl = lbgisl;
            BSIM4pbgisl = pbgisl;
            BSIM4cgisl = cgisl;
            BSIM4wcgisl = wcgisl;
            BSIM4lcgisl = lcgisl;
            BSIM4pcgisl = pcgisl;
            BSIM4egisl = egisl;
            BSIM4wegisl = wegisl;
            BSIM4legisl = legisl;
            BSIM4pegisl = pegisl;
            BSIM4rgisl = rgisl;
            BSIM4wrgisl = wrgisl;
            BSIM4lrgisl = lrgisl;
            BSIM4prgisl = prgisl;
            BSIM4kgisl = kgisl;
            BSIM4wkgisl = wkgisl;
            BSIM4lkgisl = lkgisl;
            BSIM4pkgisl = pkgisl;
            BSIM4fgisl = fgisl;
            BSIM4wfgisl = wfgisl;
            BSIM4lfgisl = lfgisl;
            BSIM4pfgisl = pfgisl;
            BSIM4rgidl = rgidl;
            BSIM4wrgidl = wrgidl;
            BSIM4lrgidl = lrgidl;
            BSIM4prgidl = prgidl;
            BSIM4kgidl = kgidl;
            BSIM4wkgidl = wkgidl;
            BSIM4lkgidl = lkgidl;
            BSIM4pkgidl = pkgidl;
            BSIM4fgidl = fgidl;
            BSIM4wfgidl = wfgidl;
            BSIM4lfgidl = lfgidl;
            BSIM4pfgidl = pfgidl;
            
            BSIM4dvtp2 = dvtp2;
            BSIM4wdvtp2 = wdvtp2;
            BSIM4ldvtp2 = ldvtp2;
            BSIM4pdvtp2 = pdvtp2;
            BSIM4dvtp3 = dvtp3;
            BSIM4wdvtp3 = wdvtp3;
            BSIM4ldvtp3 = ldvtp3;
            BSIM4pdvtp3 = pdvtp3;
            BSIM4dvtp4 = dvtp4;
            BSIM4wdvtp4 = wdvtp4;
            BSIM4ldvtp4 = ldvtp4;
            BSIM4pdvtp4 = pdvtp4;
            BSIM4dvtp5 = dvtp5;
            BSIM4wdvtp5 = wdvtp5;
            BSIM4ldvtp5 = ldvtp5;
            BSIM4pdvtp5 = pdvtp5;
            
            BSIM4ni0sub = ni0sub;
            BSIM4bg0sub = bg0sub;
            BSIM4tbgasub = tbgasub;
            BSIM4tbgbsub = tbgbsub;
            BSIM4tempeot = tempeot;
            BSIM4leffeot = leffeot;
            BSIM4weffeot = weffeot;
            BSIM4vddeot = vddeot;
            BSIM4eot = eot;
            BSIM4epsrgate = epsrgate;
            BSIM4epsrsub = epsrsub;
            BSIM4phig = phig;
            BSIM4easub = easub;
            BSIM4mtrlcompatmod = mtrlcompatmod;
            BSIM4mtrlmod = mtrlmod;
            BSIM4cvchargeMod = cvchargemod;
            
            BSIM4ud = ud;
            BSIM4wud = wud;
            BSIM4lud = lud;
            BSIM4pud = pud;
            BSIM4ud1 = ud1;
            BSIM4wud1 = wud1;
            BSIM4lud1 = lud1;
            BSIM4pud1 = pud1;
            BSIM4up = up;
            BSIM4wup = wup;
            BSIM4lup = lup;
            BSIM4pup = pup;
            BSIM4lp = lp;
            BSIM4wlp = wlp;
            BSIM4llp = llp;
            BSIM4plp = plp;
            BSIM4ucs = ucs;
            BSIM4wucs = wucs;
            BSIM4lucs = lucs;
            BSIM4pucs = pucs;
            BSIM4ucste = ucste;
            BSIM4wucste = wucste;
            BSIM4lucste = lucste;
            BSIM4pucste = pucste;
            BSIM4kvth0we = kvth0we;
            BSIM4wkvth0we = wkvth0we;
            BSIM4lkvth0we = lkvth0we;
            BSIM4pkvth0we = pkvth0we;
            BSIM4k2we = k2we;
            BSIM4wk2we = wk2we;
            BSIM4lk2we = lk2we;
            BSIM4pk2we = pk2we;
            BSIM4ku0we = ku0we;
            BSIM4wku0we = wku0we;
            BSIM4lku0we = lku0we;
            BSIM4pku0we = pku0we;
            BSIM4vfbsdoff = vfbsdoff;
            BSIM4wvfbsdoff = wvfbsdoff;
            BSIM4lvfbsdoff = lvfbsdoff;
            BSIM4pvfbsdoff = pvfbsdoff;
            BSIM4tvoff = tvoff;
            BSIM4wtvoff = wtvoff;
            BSIM4ltvoff = ltvoff;
            BSIM4ptvoff = ptvoff;
            BSIM4wpemod = wpemod;
            BSIM4sca = sca;
            BSIM4scb = scb;
            BSIM4scc = scc;
            BSIM4web = web;
            BSIM4wec = wec;
            BSIM4scref = scref;
            BSIM4rbps0 = rbps0;
            BSIM4rbpsl = rbpsl;
            BSIM4rbpsw = rbpsw;
            BSIM4rbpsnf = rbpsnf;
            BSIM4rbpd0 = rbpd0;
            BSIM4rbpdw = rbpdw;
            BSIM4rbpbx0 = rbpbx0;
            BSIM4rbpbxl = rbpbxl;
            BSIM4rbpbxw = rbpbxw;
            BSIM4rbpbxnf = rbpbxnf;
            BSIM4rbpby0 = rbpby0;
            BSIM4rbpbyl = rbpbyl;
            BSIM4rbpbyw = rbpbyw;
            BSIM4rbpbynf = rbpbynf;
            BSIM4rbsbx0 = rbsbx0;
            BSIM4rbsby0 = rbsby0;
            BSIM4rbdbx0 = rbdbx0;
            BSIM4rbdby0 = rbdby0;
            BSIM4rbsdbxl = rbsdbxl;
            BSIM4rbsdbxw = rbsdbxw;
            BSIM4rbsdbxnf = rbsdbxnf;
            BSIM4rbsdbyl = rbsdbyl;
            BSIM4rbsdbyw = rbsdbyw;
            BSIM4rbsdbynf = rbsdbynf;
            BSIM4jtss = jtss;
            BSIM4jtssws = jtssws;
            BSIM4jtsswgs = jtsswgs;
            BSIM4jtweff = jtweff;
            BSIM4njts = njts;
            BSIM4njtssw = njtssw;
            BSIM4njtsswg = njtsswg;
            BSIM4xtss = xtss;
            BSIM4xtssws = xtssws;
            BSIM4xtsswgs = xtsswgs;
            BSIM4vtss = vtss;
            BSIM4vtssws = vtssws;
            BSIM4vtsswgs = vtsswgs;
            BSIM4tnjts = tnjts;
            BSIM4tnjtssw = tnjtssw;
            BSIM4tnjtsswg = tnjtsswg;
            BSIM4jtsd = jtsd;
            BSIM4jtsswd = jtsswd;
            BSIM4jtsswgd = jtsswgd;
            BSIM4njtsd = njtsd;
            BSIM4njtsswd = njtsswd;
            BSIM4njtsswgd = njtsswgd;
            BSIM4xtsd = xtsd;
            BSIM4xtsswd = xtsswd;
            BSIM4xtsswgd = xtsswgd;
            BSIM4vtsd = vtsd;
            BSIM4vtsswd = vtsswd;
            BSIM4vtsswgd = vtsswgd;
            BSIM4tnjtsd = tnjtsd;
            BSIM4tnjtsswd = tnjtsswd;
            BSIM4tnjtsswgd = tnjtsswgd;
            BSIM4VgsteffVth = 0.0;

            //New model version > 4.3
            BSIM4scGiven = (BSIM4sc == `NOT_GIVEN) ? 0 : 1;
            BSIM4tvoffcvGiven = (BSIM4tvoffcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wtvoffcvGiven = (BSIM4wtvoffcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4ltvoffcvGiven = (BSIM4ltvoffcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4ptvoffcvGiven = (BSIM4ptvoffcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4teta0Given = (BSIM4teta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wteta0Given = (BSIM4wteta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lteta0Given = (BSIM4lteta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pteta0Given = (BSIM4pteta0 == `NOT_GIVEN) ? 0 : 1;
            
            BSIM4rbpdlGiven = (BSIM4rbpdl == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpdnfGiven = (BSIM4rbpdnf == `NOT_GIVEN) ? 0 : 1;
            BSIM4voffcvlGiven = (BSIM4voffcvl == `NOT_GIVEN) ? 0 : 1;
            
            BSIM4tnfactorGiven = (BSIM4tnfactor == `NOT_GIVEN) ? 0 : 1;
            BSIM4wtnfactorGiven = (BSIM4wtnfactor == `NOT_GIVEN) ? 0 : 1;
            BSIM4ltnfactorGiven = (BSIM4ltnfactor == `NOT_GIVEN) ? 0 : 1;
            BSIM4ptnfactorGiven = (BSIM4ptnfactor == `NOT_GIVEN) ? 0 : 1;
            BSIM4minvcvGiven = (BSIM4minvcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wminvcvGiven = (BSIM4wminvcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4lminvcvGiven = (BSIM4lminvcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4pminvcvGiven = (BSIM4pminvcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4tvfbsdoffGiven = (BSIM4tvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4wtvfbsdoffGiven = (BSIM4wtvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4ltvfbsdoffGiven = (BSIM4ltvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4ptvfbsdoffGiven = (BSIM4ptvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            
            BSIM4gidlModGiven = (BSIM4gidlMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4aigsGiven = (BSIM4aigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4waigsGiven = (BSIM4waigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4laigsGiven = (BSIM4laigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4paigsGiven = (BSIM4paigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4bigsGiven = (BSIM4bigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4wbigsGiven = (BSIM4wbigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4lbigsGiven = (BSIM4lbigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4pbigsGiven = (BSIM4pbigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4cigsGiven = (BSIM4cigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcigsGiven = (BSIM4wcigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcigsGiven = (BSIM4lcigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcigsGiven = (BSIM4pcigs == `NOT_GIVEN) ? 0 : 1;
            BSIM4aigdGiven = (BSIM4aigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4waigdGiven = (BSIM4waigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4laigdGiven = (BSIM4laigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4paigdGiven = (BSIM4paigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4bigdGiven = (BSIM4bigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4wbigdGiven = (BSIM4wbigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4lbigdGiven = (BSIM4lbigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4pbigdGiven = (BSIM4pbigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4cigdGiven = (BSIM4cigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcigdGiven = (BSIM4wcigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcigdGiven = (BSIM4lcigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcigdGiven = (BSIM4pcigd == `NOT_GIVEN) ? 0 : 1;
            
            BSIM4delvtoGiven = (BSIM4delvto == `NOT_GIVEN) ? 0 : 1;
            BSIM4adosGiven = (BSIM4ados == `NOT_GIVEN) ? 0 : 1;
            BSIM4bdosGiven = (BSIM4bdos == `NOT_GIVEN) ? 0 : 1;
            BSIM4agislGiven = (BSIM4agisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wagislGiven = (BSIM4wagisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lagislGiven = (BSIM4lagisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pagislGiven = (BSIM4pagisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4bgislGiven = (BSIM4bgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wbgislGiven = (BSIM4wbgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lbgislGiven = (BSIM4lbgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pbgislGiven = (BSIM4pbgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4cgislGiven = (BSIM4cgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcgislGiven = (BSIM4wcgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcgislGiven = (BSIM4lcgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcgislGiven = (BSIM4pcgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4egislGiven = (BSIM4egisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wegislGiven = (BSIM4wegisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4legislGiven = (BSIM4legisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pegislGiven = (BSIM4pegisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4rgislGiven = (BSIM4rgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wrgislGiven = (BSIM4wrgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lrgislGiven = (BSIM4lrgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4prgislGiven = (BSIM4prgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4kgislGiven = (BSIM4kgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wkgislGiven = (BSIM4wkgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lkgislGiven = (BSIM4lkgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pkgislGiven = (BSIM4pkgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4fgislGiven = (BSIM4fgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wfgislGiven = (BSIM4wfgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lfgislGiven = (BSIM4lfgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pfgislGiven = (BSIM4pfgisl == `NOT_GIVEN) ? 0 : 1;
            BSIM4rgidlGiven = (BSIM4rgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wrgidlGiven = (BSIM4wrgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lrgidlGiven = (BSIM4lrgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4prgidlGiven = (BSIM4prgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4kgidlGiven = (BSIM4kgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wkgidlGiven = (BSIM4wkgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lkgidlGiven = (BSIM4lkgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pkgidlGiven = (BSIM4pkgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4fgidlGiven = (BSIM4fgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wfgidlGiven = (BSIM4wfgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lfgidlGiven = (BSIM4lfgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pfgidlGiven = (BSIM4pfgidl == `NOT_GIVEN) ? 0 : 1;

            BSIM4cvchargeModGiven = (BSIM4cvchargeMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4dvtp2Given = (BSIM4dvtp2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvtp2Given = (BSIM4wdvtp2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvtp2Given = (BSIM4ldvtp2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvtp2Given = (BSIM4pdvtp2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvtp3Given = (BSIM4dvtp3 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvtp3Given = (BSIM4wdvtp3 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvtp3Given = (BSIM4ldvtp3 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvtp3Given = (BSIM4pdvtp3 == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvtp4Given = (BSIM4dvtp4 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvtp4Given = (BSIM4wdvtp4 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvtp4Given = (BSIM4ldvtp4 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvtp4Given = (BSIM4pdvtp4 == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvtp5Given = (BSIM4dvtp5 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvtp5Given = (BSIM4wdvtp5 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvtp5Given = (BSIM4ldvtp5 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvtp5Given = (BSIM4pdvtp5 == `NOT_GIVEN) ? 0 : 1;
            
            BSIM4tempeotGiven = (BSIM4tempeot == `NOT_GIVEN) ? 0 : 1;
            BSIM4leffeotGiven = (BSIM4leffeot == `NOT_GIVEN) ? 0 : 1;
            BSIM4weffeotGiven = (BSIM4weffeot == `NOT_GIVEN) ? 0 : 1;
            BSIM4vddeotGiven = (BSIM4vddeot == `NOT_GIVEN) ? 0 : 1;
            BSIM4eotGiven = (BSIM4eot == `NOT_GIVEN) ? 0 : 1;
            BSIM4epsrgateGiven = (BSIM4epsrgate == `NOT_GIVEN) ? 0 : 1;

            BSIM4epsrsubGiven = (BSIM4epsrsub == `NOT_GIVEN) ? 0 : 1;
            BSIM4phigGiven = (BSIM4phig == `NOT_GIVEN) ? 0 : 1;
            BSIM4easubGiven = (BSIM4easub == `NOT_GIVEN) ? 0 : 1;
            BSIM4mtrlcompatmodGiven = (BSIM4mtrlcompatmod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4mtrlmodGiven = (BSIM4mtrlmod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4ni0subGiven = (BSIM4ni0sub == `NOT_GIVEN) ? 0 : 1;
            BSIM4bg0subGiven = (BSIM4bg0sub == `NOT_GIVEN) ? 0 : 1;
            BSIM4tbgasubGiven = (BSIM4tbgasub == `NOT_GIVEN) ? 0 : 1;
            BSIM4tbgbsubGiven = (BSIM4tbgbsub == `NOT_GIVEN) ? 0 : 1;
            
            BSIM4udGiven = (BSIM4ud == `NOT_GIVEN) ? 0 : 1;
            BSIM4wudGiven = (BSIM4wud == `NOT_GIVEN) ? 0 : 1;
            BSIM4ludGiven = (BSIM4lud == `NOT_GIVEN) ? 0 : 1;
            BSIM4pudGiven = (BSIM4pud == `NOT_GIVEN) ? 0 : 1;
            BSIM4ud1Given = (BSIM4ud1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wud1Given = (BSIM4wud1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lud1Given = (BSIM4lud1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pud1Given = (BSIM4pud1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4upGiven = (BSIM4up == `NOT_GIVEN) ? 0 : 1;
            BSIM4wupGiven = (BSIM4wup == `NOT_GIVEN) ? 0 : 1;
            BSIM4lupGiven = (BSIM4lup == `NOT_GIVEN) ? 0 : 1;
            BSIM4pupGiven = (BSIM4pup == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpGiven = (BSIM4lp == `NOT_GIVEN) ? 0 : 1;
            BSIM4wlpGiven = (BSIM4wlp == `NOT_GIVEN) ? 0 : 1;
            BSIM4llpGiven = (BSIM4llp == `NOT_GIVEN) ? 0 : 1;
            BSIM4plpGiven = (BSIM4plp == `NOT_GIVEN) ? 0 : 1;
            BSIM4ucsGiven = (BSIM4ucs == `NOT_GIVEN) ? 0 : 1;
            BSIM4wucsGiven = (BSIM4wucs == `NOT_GIVEN) ? 0 : 1;
            BSIM4lucsGiven = (BSIM4lucs == `NOT_GIVEN) ? 0 : 1;
            BSIM4pucsGiven = (BSIM4pucs == `NOT_GIVEN) ? 0 : 1;
            BSIM4ucsteGiven = (BSIM4ucste == `NOT_GIVEN) ? 0 : 1;
            BSIM4wucsteGiven = (BSIM4wucste == `NOT_GIVEN) ? 0 : 1;
            BSIM4lucsteGiven = (BSIM4lucste == `NOT_GIVEN) ? 0 : 1;
            BSIM4pucsteGiven = (BSIM4pucste == `NOT_GIVEN) ? 0 : 1;
            BSIM4kvth0weGiven = (BSIM4kvth0we == `NOT_GIVEN) ? 0 : 1;
            BSIM4wkvth0weGiven = (BSIM4wkvth0we == `NOT_GIVEN) ? 0 : 1;
            BSIM4lkvth0weGiven = (BSIM4lkvth0we == `NOT_GIVEN) ? 0 : 1;
            BSIM4pkvth0weGiven = (BSIM4pkvth0we == `NOT_GIVEN) ? 0 : 1;
            BSIM4k2weGiven = (BSIM4k2we == `NOT_GIVEN) ? 0 : 1;
            BSIM4wk2weGiven = (BSIM4wk2we == `NOT_GIVEN) ? 0 : 1;
            BSIM4lk2weGiven = (BSIM4lk2we == `NOT_GIVEN) ? 0 : 1;
            BSIM4pk2weGiven = (BSIM4pk2we == `NOT_GIVEN) ? 0 : 1;
            BSIM4ku0weGiven = (BSIM4ku0we == `NOT_GIVEN) ? 0 : 1;
            BSIM4wku0weGiven = (BSIM4wku0we == `NOT_GIVEN) ? 0 : 1;
            BSIM4lku0weGiven = (BSIM4lku0we == `NOT_GIVEN) ? 0 : 1;
            BSIM4pku0weGiven = (BSIM4pku0we == `NOT_GIVEN) ? 0 : 1;
            BSIM4vfbsdoffGiven = (BSIM4vfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvfbsdoffGiven = (BSIM4wvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvfbsdoffGiven = (BSIM4lvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvfbsdoffGiven = (BSIM4pvfbsdoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4tvoffGiven = (BSIM4tvoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4wtvoffGiven = (BSIM4wtvoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4ltvoffGiven = (BSIM4ltvoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4ptvoffGiven = (BSIM4ptvoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpemodGiven = (BSIM4wpemod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4scaGiven = (BSIM4sca == `NOT_GIVEN) ? 0 : 1;
            BSIM4scbGiven = (BSIM4scb == `NOT_GIVEN) ? 0 : 1;
            BSIM4sccGiven = (BSIM4scc == `NOT_GIVEN) ? 0 : 1;
            BSIM4webGiven = (BSIM4web == `NOT_GIVEN) ? 0 : 1;
            BSIM4wecGiven = (BSIM4wec == `NOT_GIVEN) ? 0 : 1;
            BSIM4screfGiven = (BSIM4scref == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbps0Given = (BSIM4rbps0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpslGiven = (BSIM4rbpsl == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpswGiven = (BSIM4rbpsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpsnfGiven = (BSIM4rbpsnf == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpd0Given = (BSIM4rbpd0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpdwGiven = (BSIM4rbpdw == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpbx0Given = (BSIM4rbpbx0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpbxlGiven = (BSIM4rbpbxl == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpbxwGiven = (BSIM4rbpbxw == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpbxnfGiven = (BSIM4rbpbxnf == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpby0Given = (BSIM4rbpby0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpbylGiven = (BSIM4rbpbyl == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpbywGiven = (BSIM4rbpbyw == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpbynfGiven = (BSIM4rbpbynf == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbsbx0Given = (BSIM4rbsbx0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbsby0Given = (BSIM4rbsby0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbdbx0Given = (BSIM4rbdbx0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbdby0Given = (BSIM4rbdby0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbsdbxlGiven = (BSIM4rbsdbxl == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbsdbxwGiven = (BSIM4rbsdbxw == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbsdbxnfGiven = (BSIM4rbsdbxnf == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbsdbylGiven = (BSIM4rbsdbyl == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbsdbywGiven = (BSIM4rbsdbyw == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbsdbynfGiven = (BSIM4rbsdbynf == `NOT_GIVEN) ? 0 : 1;
            BSIM4jtssGiven = (BSIM4jtss == `NOT_GIVEN) ? 0 : 1;
            BSIM4jtsswsGiven = (BSIM4jtssws == `NOT_GIVEN) ? 0 : 1;
            BSIM4jtsswgsGiven = (BSIM4jtsswgs == `NOT_GIVEN) ? 0 : 1;
            BSIM4jtweffGiven = (BSIM4jtweff == `NOT_GIVEN) ? 0 : 1;
            BSIM4njtsGiven = (BSIM4njts == `NOT_GIVEN) ? 0 : 1;
            BSIM4njtsswGiven = (BSIM4njtssw == `NOT_GIVEN) ? 0 : 1;
            BSIM4njtsswgGiven = (BSIM4njtsswg == `NOT_GIVEN) ? 0 : 1;
            BSIM4xtssGiven = (BSIM4xtss == `NOT_GIVEN) ? 0 : 1;
            BSIM4xtsswsGiven = (BSIM4xtssws == `NOT_GIVEN) ? 0 : 1;
            BSIM4xtsswgsGiven = (BSIM4xtsswgs == `NOT_GIVEN) ? 0 : 1;
            BSIM4vtssGiven = (BSIM4vtss == `NOT_GIVEN) ? 0 : 1;
            BSIM4vtsswsGiven = (BSIM4vtssws == `NOT_GIVEN) ? 0 : 1;
            BSIM4vtsswgsGiven = (BSIM4vtsswgs == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnjtsGiven = (BSIM4tnjts == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnjtsswGiven = (BSIM4tnjtssw == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnjtsswgGiven = (BSIM4tnjtsswg == `NOT_GIVEN) ? 0 : 1;
            BSIM4jtsdGiven = (BSIM4jtsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4jtsswdGiven = (BSIM4jtsswd == `NOT_GIVEN) ? 0 : 1;
            BSIM4jtsswgdGiven = (BSIM4jtsswgd == `NOT_GIVEN) ? 0 : 1;
            BSIM4njtsdGiven = (BSIM4njtsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4njtsswdGiven = (BSIM4njtsswd == `NOT_GIVEN) ? 0 : 1;
            BSIM4njtsswgdGiven = (BSIM4njtsswgd == `NOT_GIVEN) ? 0 : 1;
            BSIM4xtsdGiven = (BSIM4xtsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4xtsswdGiven = (BSIM4xtsswd == `NOT_GIVEN) ? 0 : 1;
            BSIM4xtsswgdGiven = (BSIM4xtsswgd == `NOT_GIVEN) ? 0 : 1;
            BSIM4vtsdGiven = (BSIM4vtsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4vtsswdGiven = (BSIM4vtsswd == `NOT_GIVEN) ? 0 : 1;
            BSIM4vtsswgdGiven = (BSIM4vtsswgd == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnjtsdGiven = (BSIM4tnjtsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnjtsswdGiven = (BSIM4tnjtsswd == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnjtsswgdGiven = (BSIM4tnjtsswgd == `NOT_GIVEN) ? 0 : 1;

            
            BSIM4lGiven = (BSIM4l == `NOT_GIVEN) ? 0 : 1;        
            BSIM4wGiven = (BSIM4w == `NOT_GIVEN) ? 0 : 1;
            BSIM4nfGiven = (BSIM4nf == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4minGiven = (BSIM4min == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4drainAreaGiven = (BSIM4drainArea == `NOT_GIVEN) ? 0 : 1;
            BSIM4sourceAreaGiven = (BSIM4sourceArea == `NOT_GIVEN) ? 0 : 1;
            BSIM4drainSquaresGiven = (BSIM4drainSquares == `NOT_GIVEN) ? 0 : 1;
            BSIM4sourceSquaresGiven = (BSIM4sourceSquares == `NOT_GIVEN) ? 0 : 1;
            BSIM4drainPerimeterGiven = (BSIM4drainPerimeter == `NOT_GIVEN) ? 0 : 1;
            BSIM4sourcePerimeterGiven = (BSIM4sourcePerimeter == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbdbGiven = (BSIM4rbdb == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbsbGiven = (BSIM4rbsb == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpbGiven = (BSIM4rbpb == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpdGiven = (BSIM4rbpd == `NOT_GIVEN) ? 0 : 1;
            BSIM4rbpsGiven = (BSIM4rbps == `NOT_GIVEN) ? 0 : 1;
            BSIM4icVDSGiven = (BSIM4icVDS == `NOT_GIVEN) ? 0 : 1;
            BSIM4icVGSGiven = (BSIM4icVGS == `NOT_GIVEN) ? 0 : 1;
            BSIM4icVBSGiven = (BSIM4icVBS == `NOT_GIVEN) ? 0 : 1;
            BSIM4acnqsModGiven = (BSIM4acnqsMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4rbodyModGiven = (BSIM4rbodyMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4geoModGiven = (BSIM4geoMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4rgeoModGiven = (BSIM4rgeoMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4mobModGiven = (BSIM4mobMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4binUnitGiven = (BSIM4binUnit == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4capModGiven = (BSIM4capMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4dioModGiven = (BSIM4dioMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4rdsModGiven = (BSIM4rdsMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4rgateModGiven = (BSIM4rgateMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4perModGiven = (BSIM4perMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4paramChkGiven = (BSIM4paramChk == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4trnqsModGiven = (BSIM4trnqsMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4fnoiModGiven = (BSIM4fnoiMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4tnoiModGiven = (BSIM4tnoiMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4igcModGiven = (BSIM4igcMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4igbModGiven = (BSIM4igbMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4typeGiven = (BSIM4type == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4toxrefGiven = (BSIM4toxref == `NOT_GIVEN) ? 0 : 1;
            BSIM4toxeGiven = (BSIM4toxe == `NOT_GIVEN) ? 0 : 1;
            BSIM4toxpGiven = (BSIM4toxp == `NOT_GIVEN) ? 0 : 1;
            BSIM4toxmGiven = (BSIM4toxm == `NOT_GIVEN) ? 0 : 1;
            BSIM4dtoxGiven = (BSIM4dtox == `NOT_GIVEN) ? 0 : 1;
            BSIM4epsroxGiven = (BSIM4epsrox == `NOT_GIVEN) ? 0 : 1;
            BSIM4versionGiven = (BSIM4version == `NOT_GIVEN) ? 0 : 1;
            BSIM4cdscGiven = (BSIM4cdsc == `NOT_GIVEN) ? 0 : 1;
            BSIM4cdscbGiven = (BSIM4cdscb == `NOT_GIVEN) ? 0 : 1;
            BSIM4cdscdGiven = (BSIM4cdscd == `NOT_GIVEN) ? 0 : 1;
            BSIM4citGiven = (BSIM4cit == `NOT_GIVEN) ? 0 : 1;
            BSIM4nfactorGiven = (BSIM4nfactor == `NOT_GIVEN) ? 0 : 1;
            BSIM4xjGiven = (BSIM4xj == `NOT_GIVEN) ? 0 : 1;
            BSIM4vsatGiven = (BSIM4vsat == `NOT_GIVEN) ? 0 : 1;
            BSIM4atGiven = (BSIM4at == `NOT_GIVEN) ? 0 : 1;
            BSIM4a0Given = (BSIM4a0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4agsGiven = (BSIM4ags == `NOT_GIVEN) ? 0 : 1;
            BSIM4a1Given = (BSIM4a1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4a2Given = (BSIM4a2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ketaGiven = (BSIM4keta == `NOT_GIVEN) ? 0 : 1;
            BSIM4nsubGiven = (BSIM4nsub == `NOT_GIVEN) ? 0 : 1;
            BSIM4ndepGiven = (BSIM4ndep == `NOT_GIVEN) ? 0 : 1;
            BSIM4nsdGiven = (BSIM4nsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4phinGiven = (BSIM4phin == `NOT_GIVEN) ? 0 : 1;
            BSIM4ngateGiven = (BSIM4ngate == `NOT_GIVEN) ? 0 : 1;
            BSIM4gamma1Given = (BSIM4gamma1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4gamma2Given = (BSIM4gamma2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4vbxGiven = (BSIM4vbx == `NOT_GIVEN) ? 0 : 1;
            BSIM4vbmGiven = (BSIM4vbm == `NOT_GIVEN) ? 0 : 1;
            BSIM4xtGiven = (BSIM4xt == `NOT_GIVEN) ? 0 : 1;
            BSIM4k1Given = (BSIM4k1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4kt1Given = (BSIM4kt1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4kt1lGiven = (BSIM4kt1l == `NOT_GIVEN) ? 0 : 1;
            BSIM4kt2Given = (BSIM4kt2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4k2Given = (BSIM4k2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4k3Given = (BSIM4k3 == `NOT_GIVEN) ? 0 : 1;
            BSIM4k3bGiven = (BSIM4k3b == `NOT_GIVEN) ? 0 : 1;
            BSIM4w0Given = (BSIM4w0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvtp0Given = (BSIM4dvtp0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvtp1Given = (BSIM4dvtp1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpe0Given = (BSIM4lpe0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpebGiven = (BSIM4lpeb == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvt0Given = (BSIM4dvt0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvt1Given = (BSIM4dvt1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvt2Given = (BSIM4dvt2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvt0wGiven = (BSIM4dvt0w == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvt1wGiven = (BSIM4dvt1w == `NOT_GIVEN) ? 0 : 1;
            BSIM4dvt2wGiven = (BSIM4dvt2w == `NOT_GIVEN) ? 0 : 1;
            BSIM4droutGiven = (BSIM4drout == `NOT_GIVEN) ? 0 : 1;
            BSIM4dsubGiven = (BSIM4dsub == `NOT_GIVEN) ? 0 : 1;
            BSIM4vth0Given = (BSIM4vth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4euGiven = (BSIM4eu == `NOT_GIVEN) ? 0 : 1;
            BSIM4uaGiven = (BSIM4ua == `NOT_GIVEN) ? 0 : 1;
            BSIM4ua1Given = (BSIM4ua1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ubGiven = (BSIM4ub == `NOT_GIVEN) ? 0 : 1;
            BSIM4ub1Given = (BSIM4ub1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ucGiven = (BSIM4uc == `NOT_GIVEN) ? 0 : 1;
            BSIM4uc1Given = (BSIM4uc1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4u0Given = (BSIM4u0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4uteGiven = (BSIM4ute == `NOT_GIVEN) ? 0 : 1;
            BSIM4voffGiven = (BSIM4voff == `NOT_GIVEN) ? 0 : 1;
            BSIM4vofflGiven = (BSIM4voffl == `NOT_GIVEN) ? 0 : 1;
            BSIM4minvGiven = (BSIM4minv == `NOT_GIVEN) ? 0 : 1;
            BSIM4rdswGiven = (BSIM4rdsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4rdswminGiven = (BSIM4rdswmin == `NOT_GIVEN) ? 0 : 1;
            BSIM4rdwminGiven = (BSIM4rdwmin == `NOT_GIVEN) ? 0 : 1;
            BSIM4rswminGiven = (BSIM4rswmin == `NOT_GIVEN) ? 0 : 1;
            BSIM4rswGiven = (BSIM4rsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4rdwGiven = (BSIM4rdw == `NOT_GIVEN) ? 0 : 1;
            BSIM4prwgGiven = (BSIM4prwg == `NOT_GIVEN) ? 0 : 1;
            BSIM4prwbGiven = (BSIM4prwb == `NOT_GIVEN) ? 0 : 1;
            BSIM4prtGiven = (BSIM4prt == `NOT_GIVEN) ? 0 : 1;
            BSIM4eta0Given = (BSIM4eta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4etabGiven = (BSIM4etab == `NOT_GIVEN) ? 0 : 1;
            BSIM4pclmGiven = (BSIM4pclm == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdibl1Given = (BSIM4pdibl1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdibl2Given = (BSIM4pdibl2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdiblbGiven = (BSIM4pdiblb == `NOT_GIVEN) ? 0 : 1;
            BSIM4fproutGiven = (BSIM4fprout == `NOT_GIVEN) ? 0 : 1;
            BSIM4pditsGiven = (BSIM4pdits == `NOT_GIVEN) ? 0 : 1;
            BSIM4pditsdGiven = (BSIM4pditsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4pditslGiven = (BSIM4pditsl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pscbe1Given = (BSIM4pscbe1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pscbe2Given = (BSIM4pscbe2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvagGiven = (BSIM4pvag == `NOT_GIVEN) ? 0 : 1;
            BSIM4deltaGiven = (BSIM4delta == `NOT_GIVEN) ? 0 : 1;
            BSIM4wrGiven = (BSIM4wr == `NOT_GIVEN) ? 0 : 1;
            BSIM4dwgGiven = (BSIM4dwg == `NOT_GIVEN) ? 0 : 1;
            BSIM4dwbGiven = (BSIM4dwb == `NOT_GIVEN) ? 0 : 1;
            BSIM4b0Given = (BSIM4b0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4b1Given = (BSIM4b1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4alpha0Given = (BSIM4alpha0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4alpha1Given = (BSIM4alpha1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4beta0Given = (BSIM4beta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4agidlGiven = (BSIM4agidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4bgidlGiven = (BSIM4bgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4cgidlGiven = (BSIM4cgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4egidlGiven = (BSIM4egidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4aigcGiven = (BSIM4aigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4bigcGiven = (BSIM4bigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4cigcGiven = (BSIM4cigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4aigsdGiven = (BSIM4aigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4bigsdGiven = (BSIM4bigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4cigsdGiven = (BSIM4cigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4aigbaccGiven = (BSIM4aigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4bigbaccGiven = (BSIM4bigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4cigbaccGiven = (BSIM4cigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4aigbinvGiven = (BSIM4aigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4bigbinvGiven = (BSIM4bigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4cigbinvGiven = (BSIM4cigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4nigcGiven = (BSIM4nigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4nigbinvGiven = (BSIM4nigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4nigbaccGiven = (BSIM4nigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4ntoxGiven = (BSIM4ntox == `NOT_GIVEN) ? 0 : 1;
            BSIM4eigbinvGiven = (BSIM4eigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4pigcdGiven = (BSIM4pigcd == `NOT_GIVEN) ? 0 : 1;
            BSIM4poxedgeGiven = (BSIM4poxedge == `NOT_GIVEN) ? 0 : 1;
            BSIM4ijthdfwdGiven = (BSIM4ijthdfwd == `NOT_GIVEN) ? 0 : 1;
            BSIM4ijthsfwdGiven = (BSIM4ijthsfwd == `NOT_GIVEN) ? 0 : 1;
            BSIM4ijthdrevGiven = (BSIM4ijthdrev == `NOT_GIVEN) ? 0 : 1;
            BSIM4ijthsrevGiven = (BSIM4ijthsrev == `NOT_GIVEN) ? 0 : 1;
            BSIM4xjbvdGiven = (BSIM4xjbvd == `NOT_GIVEN) ? 0 : 1;
            BSIM4xjbvsGiven = (BSIM4xjbvs == `NOT_GIVEN) ? 0 : 1;
            BSIM4bvdGiven = (BSIM4bvd == `NOT_GIVEN) ? 0 : 1;
            BSIM4bvsGiven = (BSIM4bvs == `NOT_GIVEN) ? 0 : 1;
            BSIM4vfbGiven = (BSIM4vfb == `NOT_GIVEN) ? 0 : 1;
            BSIM4gbminGiven = (BSIM4gbmin == `NOT_GIVEN) ? 0 : 1;
            BSIM4xrcrg1Given = (BSIM4xrcrg1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4xrcrg2Given = (BSIM4xrcrg2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnoiaGiven = (BSIM4tnoia == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnoibGiven = (BSIM4tnoib == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnoicGiven = (BSIM4tnoic == `NOT_GIVEN) ? 0 : 1;
            BSIM4ntnoiGiven = (BSIM4ntnoi == `NOT_GIVEN) ? 0 : 1;
            BSIM4cgslGiven = (BSIM4cgsl == `NOT_GIVEN) ? 0 : 1;
            BSIM4cgdlGiven = (BSIM4cgdl == `NOT_GIVEN) ? 0 : 1;
            BSIM4ckappasGiven = (BSIM4ckappas == `NOT_GIVEN) ? 0 : 1;
            BSIM4ckappadGiven = (BSIM4ckappad == `NOT_GIVEN) ? 0 : 1;
            BSIM4cfGiven = (BSIM4cf == `NOT_GIVEN) ? 0 : 1;
            BSIM4vfbcvGiven = (BSIM4vfbcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4clcGiven = (BSIM4clc == `NOT_GIVEN) ? 0 : 1;
            BSIM4cleGiven = (BSIM4cle == `NOT_GIVEN) ? 0 : 1;
            BSIM4dwcGiven = (BSIM4dwc == `NOT_GIVEN) ? 0 : 1;
            BSIM4dlcGiven = (BSIM4dlc == `NOT_GIVEN) ? 0 : 1;
            BSIM4xwGiven = (BSIM4xw == `NOT_GIVEN) ? 0 : 1;
            BSIM4xlGiven = (BSIM4xl == `NOT_GIVEN) ? 0 : 1;
            BSIM4dlcigGiven = (BSIM4dlcig == `NOT_GIVEN) ? 0 : 1;
            BSIM4dlcigdGiven = (BSIM4dlcigd == `NOT_GIVEN) ? 0 : 1;
            BSIM4dwjGiven = (BSIM4dwj == `NOT_GIVEN) ? 0 : 1;
            BSIM4noffGiven = (BSIM4noff == `NOT_GIVEN) ? 0 : 1;
            BSIM4voffcvGiven = (BSIM4voffcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4acdeGiven = (BSIM4acde == `NOT_GIVEN) ? 0 : 1;
            BSIM4moinGiven = (BSIM4moin == `NOT_GIVEN) ? 0 : 1;
            BSIM4tcjGiven = (BSIM4tcj == `NOT_GIVEN) ? 0 : 1;
            BSIM4tcjswGiven = (BSIM4tcjsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4tcjswgGiven = (BSIM4tcjswg == `NOT_GIVEN) ? 0 : 1;
            BSIM4tpbGiven = (BSIM4tpb == `NOT_GIVEN) ? 0 : 1;
            BSIM4tpbswGiven = (BSIM4tpbsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4tpbswgGiven = (BSIM4tpbswg == `NOT_GIVEN) ? 0 : 1;
            BSIM4dmcgGiven = (BSIM4dmcg == `NOT_GIVEN) ? 0 : 1;
            BSIM4dmciGiven = (BSIM4dmci == `NOT_GIVEN) ? 0 : 1;
            BSIM4dmdgGiven = (BSIM4dmdg == `NOT_GIVEN) ? 0 : 1;
            BSIM4dmcgtGiven = (BSIM4dmcgt == `NOT_GIVEN) ? 0 : 1;
            BSIM4xgwGiven = (BSIM4xgw == `NOT_GIVEN) ? 0 : 1;
            BSIM4xglGiven = (BSIM4xgl == `NOT_GIVEN) ? 0 : 1;
            BSIM4rshgGiven = (BSIM4rshg == `NOT_GIVEN) ? 0 : 1;
            BSIM4ngconGiven = (BSIM4ngcon == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcdscGiven = (BSIM4lcdsc == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcdscbGiven = (BSIM4lcdscb == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcdscdGiven = (BSIM4lcdscd == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcitGiven = (BSIM4lcit == `NOT_GIVEN) ? 0 : 1;
            BSIM4lnfactorGiven = (BSIM4lnfactor == `NOT_GIVEN) ? 0 : 1;
            BSIM4lxjGiven = (BSIM4lxj == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvsatGiven = (BSIM4lvsat == `NOT_GIVEN) ? 0 : 1;
            BSIM4latGiven = (BSIM4lat == `NOT_GIVEN) ? 0 : 1;
            BSIM4la0Given = (BSIM4la0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lagsGiven = (BSIM4lags == `NOT_GIVEN) ? 0 : 1;
            BSIM4la1Given = (BSIM4la1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4la2Given = (BSIM4la2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lketaGiven = (BSIM4lketa == `NOT_GIVEN) ? 0 : 1;
            BSIM4lnsubGiven = (BSIM4lnsub == `NOT_GIVEN) ? 0 : 1;
            BSIM4lndepGiven = (BSIM4lndep == `NOT_GIVEN) ? 0 : 1;
            BSIM4lnsdGiven = (BSIM4lnsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4lphinGiven = (BSIM4lphin == `NOT_GIVEN) ? 0 : 1;
            BSIM4lngateGiven = (BSIM4lngate == `NOT_GIVEN) ? 0 : 1;
            BSIM4lgamma1Given = (BSIM4lgamma1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lgamma2Given = (BSIM4lgamma2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvbxGiven = (BSIM4lvbx == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvbmGiven = (BSIM4lvbm == `NOT_GIVEN) ? 0 : 1;
            BSIM4lxtGiven = (BSIM4lxt == `NOT_GIVEN) ? 0 : 1;
            BSIM4lk1Given = (BSIM4lk1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lkt1Given = (BSIM4lkt1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lkt1lGiven = (BSIM4lkt1l == `NOT_GIVEN) ? 0 : 1;
            BSIM4lkt2Given = (BSIM4lkt2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lk2Given = (BSIM4lk2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lk3Given = (BSIM4lk3 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lk3bGiven = (BSIM4lk3b == `NOT_GIVEN) ? 0 : 1;
            BSIM4lw0Given = (BSIM4lw0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvtp0Given = (BSIM4ldvtp0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvtp1Given = (BSIM4ldvtp1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4llpe0Given = (BSIM4llpe0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4llpebGiven = (BSIM4llpeb == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvt0Given = (BSIM4ldvt0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvt1Given = (BSIM4ldvt1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvt2Given = (BSIM4ldvt2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvt0wGiven = (BSIM4ldvt0w == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvt1wGiven = (BSIM4ldvt1w == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldvt2wGiven = (BSIM4ldvt2w == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldroutGiven = (BSIM4ldrout == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldsubGiven = (BSIM4ldsub == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvth0Given = (BSIM4lvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4luaGiven = (BSIM4lua == `NOT_GIVEN) ? 0 : 1;
            BSIM4lua1Given = (BSIM4lua1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lubGiven = (BSIM4lub == `NOT_GIVEN) ? 0 : 1;
            BSIM4lub1Given = (BSIM4lub1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lucGiven = (BSIM4luc == `NOT_GIVEN) ? 0 : 1;
            BSIM4luc1Given = (BSIM4luc1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lu0Given = (BSIM4lu0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4leuGiven = (BSIM4leu == `NOT_GIVEN) ? 0 : 1;
            BSIM4luteGiven = (BSIM4lute == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvoffGiven = (BSIM4lvoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4lminvGiven = (BSIM4lminv == `NOT_GIVEN) ? 0 : 1;
            BSIM4lrdswGiven = (BSIM4lrdsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4lrswGiven = (BSIM4lrsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4lrdwGiven = (BSIM4lrdw == `NOT_GIVEN) ? 0 : 1;
            BSIM4lprwgGiven = (BSIM4lprwg == `NOT_GIVEN) ? 0 : 1;
            BSIM4lprwbGiven = (BSIM4lprwb == `NOT_GIVEN) ? 0 : 1;
            BSIM4lprtGiven = (BSIM4lprt == `NOT_GIVEN) ? 0 : 1;
            BSIM4leta0Given = (BSIM4leta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4letabGiven = (BSIM4letab == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpclmGiven = (BSIM4lpclm == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpdibl1Given = (BSIM4lpdibl1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpdibl2Given = (BSIM4lpdibl2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpdiblbGiven = (BSIM4lpdiblb == `NOT_GIVEN) ? 0 : 1;
            BSIM4lfproutGiven = (BSIM4lfprout == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpditsGiven = (BSIM4lpdits == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpditsdGiven = (BSIM4lpditsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpscbe1Given = (BSIM4lpscbe1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpscbe2Given = (BSIM4lpscbe2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpvagGiven = (BSIM4lpvag == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldeltaGiven = (BSIM4ldelta == `NOT_GIVEN) ? 0 : 1;
            BSIM4lwrGiven = (BSIM4lwr == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldwgGiven = (BSIM4ldwg == `NOT_GIVEN) ? 0 : 1;
            BSIM4ldwbGiven = (BSIM4ldwb == `NOT_GIVEN) ? 0 : 1;
            BSIM4lb0Given = (BSIM4lb0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lb1Given = (BSIM4lb1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lalpha0Given = (BSIM4lalpha0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lalpha1Given = (BSIM4lalpha1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lbeta0Given = (BSIM4lbeta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvfbGiven = (BSIM4lvfb == `NOT_GIVEN) ? 0 : 1;
            BSIM4lagidlGiven = (BSIM4lagidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lbgidlGiven = (BSIM4lbgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcgidlGiven = (BSIM4lcgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4legidlGiven = (BSIM4legidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4laigcGiven = (BSIM4laigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4lbigcGiven = (BSIM4lbigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcigcGiven = (BSIM4lcigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4laigsdGiven = (BSIM4laigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4lbigsdGiven = (BSIM4lbigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcigsdGiven = (BSIM4lcigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4laigbaccGiven = (BSIM4laigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4lbigbaccGiven = (BSIM4lbigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcigbaccGiven = (BSIM4lcigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4laigbinvGiven = (BSIM4laigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4lbigbinvGiven = (BSIM4lbigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcigbinvGiven = (BSIM4lcigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4lnigcGiven = (BSIM4lnigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4lnigbinvGiven = (BSIM4lnigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4lnigbaccGiven = (BSIM4lnigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4lntoxGiven = (BSIM4lntox == `NOT_GIVEN) ? 0 : 1;
            BSIM4leigbinvGiven = (BSIM4leigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpigcdGiven = (BSIM4lpigcd == `NOT_GIVEN) ? 0 : 1;
            BSIM4lpoxedgeGiven = (BSIM4lpoxedge == `NOT_GIVEN) ? 0 : 1;
            BSIM4lxrcrg1Given = (BSIM4lxrcrg1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lxrcrg2Given = (BSIM4lxrcrg2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcgslGiven = (BSIM4lcgsl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcgdlGiven = (BSIM4lcgdl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lckappasGiven = (BSIM4lckappas == `NOT_GIVEN) ? 0 : 1;
            BSIM4lckappadGiven = (BSIM4lckappad == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcfGiven = (BSIM4lcf == `NOT_GIVEN) ? 0 : 1;
            BSIM4lclcGiven = (BSIM4lclc == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcleGiven = (BSIM4lcle == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvfbcvGiven = (BSIM4lvfbcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4lnoffGiven = (BSIM4lnoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvoffcvGiven = (BSIM4lvoffcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4lacdeGiven = (BSIM4lacde == `NOT_GIVEN) ? 0 : 1;
            BSIM4lmoinGiven = (BSIM4lmoin == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcdscGiven = (BSIM4wcdsc == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcdscbGiven = (BSIM4wcdscb == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcdscdGiven = (BSIM4wcdscd == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcitGiven = (BSIM4wcit == `NOT_GIVEN) ? 0 : 1;
            BSIM4wnfactorGiven = (BSIM4wnfactor == `NOT_GIVEN) ? 0 : 1;
            BSIM4wxjGiven = (BSIM4wxj == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvsatGiven = (BSIM4wvsat == `NOT_GIVEN) ? 0 : 1;
            BSIM4watGiven = (BSIM4wat == `NOT_GIVEN) ? 0 : 1;
            BSIM4wa0Given = (BSIM4wa0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wagsGiven = (BSIM4wags == `NOT_GIVEN) ? 0 : 1;
            BSIM4wa1Given = (BSIM4wa1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wa2Given = (BSIM4wa2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wketaGiven = (BSIM4wketa == `NOT_GIVEN) ? 0 : 1;
            BSIM4wnsubGiven = (BSIM4wnsub == `NOT_GIVEN) ? 0 : 1;
            BSIM4wndepGiven = (BSIM4wndep == `NOT_GIVEN) ? 0 : 1;
            BSIM4wnsdGiven = (BSIM4wnsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4wphinGiven = (BSIM4wphin == `NOT_GIVEN) ? 0 : 1;
            BSIM4wngateGiven = (BSIM4wngate == `NOT_GIVEN) ? 0 : 1;
            BSIM4wgamma1Given = (BSIM4wgamma1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wgamma2Given = (BSIM4wgamma2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvbxGiven = (BSIM4wvbx == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvbmGiven = (BSIM4wvbm == `NOT_GIVEN) ? 0 : 1;
            BSIM4wxtGiven = (BSIM4wxt == `NOT_GIVEN) ? 0 : 1;
            BSIM4wk1Given = (BSIM4wk1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wkt1Given = (BSIM4wkt1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wkt1lGiven = (BSIM4wkt1l == `NOT_GIVEN) ? 0 : 1;
            BSIM4wkt2Given = (BSIM4wkt2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wk2Given = (BSIM4wk2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wk3Given = (BSIM4wk3 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wk3bGiven = (BSIM4wk3b == `NOT_GIVEN) ? 0 : 1;
            BSIM4ww0Given = (BSIM4ww0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvtp0Given = (BSIM4wdvtp0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvtp1Given = (BSIM4wdvtp1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wlpe0Given = (BSIM4wlpe0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wlpebGiven = (BSIM4wlpeb == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvt0Given = (BSIM4wdvt0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvt1Given = (BSIM4wdvt1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvt2Given = (BSIM4wdvt2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvt0wGiven = (BSIM4wdvt0w == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvt1wGiven = (BSIM4wdvt1w == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdvt2wGiven = (BSIM4wdvt2w == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdroutGiven = (BSIM4wdrout == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdsubGiven = (BSIM4wdsub == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvth0Given = (BSIM4wvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wuaGiven = (BSIM4wua == `NOT_GIVEN) ? 0 : 1;
            BSIM4wua1Given = (BSIM4wua1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wubGiven = (BSIM4wub == `NOT_GIVEN) ? 0 : 1;
            BSIM4wub1Given = (BSIM4wub1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wucGiven = (BSIM4wuc == `NOT_GIVEN) ? 0 : 1;
            BSIM4wuc1Given = (BSIM4wuc1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wu0Given = (BSIM4wu0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4weuGiven = (BSIM4weu == `NOT_GIVEN) ? 0 : 1;
            BSIM4wuteGiven = (BSIM4wute == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvoffGiven = (BSIM4wvoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4wminvGiven = (BSIM4wminv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wrdswGiven = (BSIM4wrdsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4wrswGiven = (BSIM4wrsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4wrdwGiven = (BSIM4wrdw == `NOT_GIVEN) ? 0 : 1;
            BSIM4wprwgGiven = (BSIM4wprwg == `NOT_GIVEN) ? 0 : 1;
            BSIM4wprwbGiven = (BSIM4wprwb == `NOT_GIVEN) ? 0 : 1;
            BSIM4wprtGiven = (BSIM4wprt == `NOT_GIVEN) ? 0 : 1;
            BSIM4weta0Given = (BSIM4weta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wetabGiven = (BSIM4wetab == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpclmGiven = (BSIM4wpclm == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpdibl1Given = (BSIM4wpdibl1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpdibl2Given = (BSIM4wpdibl2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpdiblbGiven = (BSIM4wpdiblb == `NOT_GIVEN) ? 0 : 1;
            BSIM4wfproutGiven = (BSIM4wfprout == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpditsGiven = (BSIM4wpdits == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpditsdGiven = (BSIM4wpditsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpscbe1Given = (BSIM4wpscbe1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpscbe2Given = (BSIM4wpscbe2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpvagGiven = (BSIM4wpvag == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdeltaGiven = (BSIM4wdelta == `NOT_GIVEN) ? 0 : 1;
            BSIM4wwrGiven = (BSIM4wwr == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdwgGiven = (BSIM4wdwg == `NOT_GIVEN) ? 0 : 1;
            BSIM4wdwbGiven = (BSIM4wdwb == `NOT_GIVEN) ? 0 : 1;
            BSIM4wb0Given = (BSIM4wb0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wb1Given = (BSIM4wb1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4walpha0Given = (BSIM4walpha0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4walpha1Given = (BSIM4walpha1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wbeta0Given = (BSIM4wbeta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvfbGiven = (BSIM4wvfb == `NOT_GIVEN) ? 0 : 1;
            BSIM4wagidlGiven = (BSIM4wagidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wbgidlGiven = (BSIM4wbgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcgidlGiven = (BSIM4wcgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wegidlGiven = (BSIM4wegidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4waigcGiven = (BSIM4waigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4wbigcGiven = (BSIM4wbigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcigcGiven = (BSIM4wcigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4waigsdGiven = (BSIM4waigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4wbigsdGiven = (BSIM4wbigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcigsdGiven = (BSIM4wcigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4waigbaccGiven = (BSIM4waigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4wbigbaccGiven = (BSIM4wbigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcigbaccGiven = (BSIM4wcigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4waigbinvGiven = (BSIM4waigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wbigbinvGiven = (BSIM4wbigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcigbinvGiven = (BSIM4wcigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wnigcGiven = (BSIM4wnigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4wnigbinvGiven = (BSIM4wnigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wnigbaccGiven = (BSIM4wnigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4wntoxGiven = (BSIM4wntox == `NOT_GIVEN) ? 0 : 1;
            BSIM4weigbinvGiven = (BSIM4weigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpigcdGiven = (BSIM4wpigcd == `NOT_GIVEN) ? 0 : 1;
            BSIM4wpoxedgeGiven = (BSIM4wpoxedge == `NOT_GIVEN) ? 0 : 1;
            BSIM4wxrcrg1Given = (BSIM4wxrcrg1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wxrcrg2Given = (BSIM4wxrcrg2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcgslGiven = (BSIM4wcgsl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcgdlGiven = (BSIM4wcgdl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wckappasGiven = (BSIM4wckappas == `NOT_GIVEN) ? 0 : 1;
            BSIM4wckappadGiven = (BSIM4wckappad == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcfGiven = (BSIM4wcf == `NOT_GIVEN) ? 0 : 1;
            BSIM4wclcGiven = (BSIM4wclc == `NOT_GIVEN) ? 0 : 1;
            BSIM4wcleGiven = (BSIM4wcle == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvfbcvGiven = (BSIM4wvfbcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wnoffGiven = (BSIM4wnoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvoffcvGiven = (BSIM4wvoffcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4wacdeGiven = (BSIM4wacde == `NOT_GIVEN) ? 0 : 1;
            BSIM4wmoinGiven = (BSIM4wmoin == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcdscGiven = (BSIM4pcdsc == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcdscbGiven = (BSIM4pcdscb == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcdscdGiven = (BSIM4pcdscd == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcitGiven = (BSIM4pcit == `NOT_GIVEN) ? 0 : 1;
            BSIM4pnfactorGiven = (BSIM4pnfactor == `NOT_GIVEN) ? 0 : 1;
            BSIM4pxjGiven = (BSIM4pxj == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvsatGiven = (BSIM4pvsat == `NOT_GIVEN) ? 0 : 1;
            BSIM4patGiven = (BSIM4pat == `NOT_GIVEN) ? 0 : 1;
            BSIM4pa0Given = (BSIM4pa0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pagsGiven = (BSIM4pags == `NOT_GIVEN) ? 0 : 1;
            BSIM4pa1Given = (BSIM4pa1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pa2Given = (BSIM4pa2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pketaGiven = (BSIM4pketa == `NOT_GIVEN) ? 0 : 1;
            BSIM4pnsubGiven = (BSIM4pnsub == `NOT_GIVEN) ? 0 : 1;
            BSIM4pndepGiven = (BSIM4pndep == `NOT_GIVEN) ? 0 : 1;
            BSIM4pnsdGiven = (BSIM4pnsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4pphinGiven = (BSIM4pphin == `NOT_GIVEN) ? 0 : 1;
            BSIM4pngateGiven = (BSIM4pngate == `NOT_GIVEN) ? 0 : 1;
            BSIM4pgamma1Given = (BSIM4pgamma1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pgamma2Given = (BSIM4pgamma2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvbxGiven = (BSIM4pvbx == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvbmGiven = (BSIM4pvbm == `NOT_GIVEN) ? 0 : 1;
            BSIM4pxtGiven = (BSIM4pxt == `NOT_GIVEN) ? 0 : 1;
            BSIM4pk1Given = (BSIM4pk1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pkt1Given = (BSIM4pkt1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pkt1lGiven = (BSIM4pkt1l == `NOT_GIVEN) ? 0 : 1;
            BSIM4pkt2Given = (BSIM4pkt2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pk2Given = (BSIM4pk2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pk3Given = (BSIM4pk3 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pk3bGiven = (BSIM4pk3b == `NOT_GIVEN) ? 0 : 1;
            BSIM4pw0Given = (BSIM4pw0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvtp0Given = (BSIM4pdvtp0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvtp1Given = (BSIM4pdvtp1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4plpe0Given = (BSIM4plpe0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4plpebGiven = (BSIM4plpeb == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvt0Given = (BSIM4pdvt0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvt1Given = (BSIM4pdvt1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvt2Given = (BSIM4pdvt2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvt0wGiven = (BSIM4pdvt0w == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvt1wGiven = (BSIM4pdvt1w == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdvt2wGiven = (BSIM4pdvt2w == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdroutGiven = (BSIM4pdrout == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdsubGiven = (BSIM4pdsub == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvth0Given = (BSIM4pvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4puaGiven = (BSIM4pua == `NOT_GIVEN) ? 0 : 1;
            BSIM4pua1Given = (BSIM4pua1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pubGiven = (BSIM4pub == `NOT_GIVEN) ? 0 : 1;
            BSIM4pub1Given = (BSIM4pub1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pucGiven = (BSIM4puc == `NOT_GIVEN) ? 0 : 1;
            BSIM4puc1Given = (BSIM4puc1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pu0Given = (BSIM4pu0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4peuGiven = (BSIM4peu == `NOT_GIVEN) ? 0 : 1;
            BSIM4puteGiven = (BSIM4pute == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvoffGiven = (BSIM4pvoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4pminvGiven = (BSIM4pminv == `NOT_GIVEN) ? 0 : 1;
            BSIM4prdswGiven = (BSIM4prdsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4prswGiven = (BSIM4prsw == `NOT_GIVEN) ? 0 : 1;
            BSIM4prdwGiven = (BSIM4prdw == `NOT_GIVEN) ? 0 : 1;
            BSIM4pprwgGiven = (BSIM4pprwg == `NOT_GIVEN) ? 0 : 1;
            BSIM4pprwbGiven = (BSIM4pprwb == `NOT_GIVEN) ? 0 : 1;
            BSIM4pprtGiven = (BSIM4pprt == `NOT_GIVEN) ? 0 : 1;
            BSIM4peta0Given = (BSIM4peta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4petabGiven = (BSIM4petab == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppclmGiven = (BSIM4ppclm == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppdibl1Given = (BSIM4ppdibl1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppdibl2Given = (BSIM4ppdibl2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppdiblbGiven = (BSIM4ppdiblb == `NOT_GIVEN) ? 0 : 1;
            BSIM4pfproutGiven = (BSIM4pfprout == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppditsGiven = (BSIM4ppdits == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppditsdGiven = (BSIM4ppditsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppscbe1Given = (BSIM4ppscbe1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppscbe2Given = (BSIM4ppscbe2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppvagGiven = (BSIM4ppvag == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdeltaGiven = (BSIM4pdelta == `NOT_GIVEN) ? 0 : 1;
            BSIM4pwrGiven = (BSIM4pwr == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdwgGiven = (BSIM4pdwg == `NOT_GIVEN) ? 0 : 1;
            BSIM4pdwbGiven = (BSIM4pdwb == `NOT_GIVEN) ? 0 : 1;
            BSIM4pb0Given = (BSIM4pb0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pb1Given = (BSIM4pb1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4palpha0Given = (BSIM4palpha0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4palpha1Given = (BSIM4palpha1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pbeta0Given = (BSIM4pbeta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvfbGiven = (BSIM4pvfb == `NOT_GIVEN) ? 0 : 1;
            BSIM4pagidlGiven = (BSIM4pagidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pbgidlGiven = (BSIM4pbgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcgidlGiven = (BSIM4pcgidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pegidlGiven = (BSIM4pegidl == `NOT_GIVEN) ? 0 : 1;
            BSIM4paigcGiven = (BSIM4paigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4pbigcGiven = (BSIM4pbigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcigcGiven = (BSIM4pcigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4paigsdGiven = (BSIM4paigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4pbigsdGiven = (BSIM4pbigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcigsdGiven = (BSIM4pcigsd == `NOT_GIVEN) ? 0 : 1;
            BSIM4paigbaccGiven = (BSIM4paigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4pbigbaccGiven = (BSIM4pbigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcigbaccGiven = (BSIM4pcigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4paigbinvGiven = (BSIM4paigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4pbigbinvGiven = (BSIM4pbigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcigbinvGiven = (BSIM4pcigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4pnigcGiven = (BSIM4pnigc == `NOT_GIVEN) ? 0 : 1;
            BSIM4pnigbinvGiven = (BSIM4pnigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4pnigbaccGiven = (BSIM4pnigbacc == `NOT_GIVEN) ? 0 : 1;
            BSIM4pntoxGiven = (BSIM4pntox == `NOT_GIVEN) ? 0 : 1;
            BSIM4peigbinvGiven = (BSIM4peigbinv == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppigcdGiven = (BSIM4ppigcd == `NOT_GIVEN) ? 0 : 1;
            BSIM4ppoxedgeGiven = (BSIM4ppoxedge == `NOT_GIVEN) ? 0 : 1;
            BSIM4pxrcrg1Given = (BSIM4pxrcrg1 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pxrcrg2Given = (BSIM4pxrcrg2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcgslGiven = (BSIM4pcgsl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcgdlGiven = (BSIM4pcgdl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pckappasGiven = (BSIM4pckappas == `NOT_GIVEN) ? 0 : 1;
            BSIM4pckappadGiven = (BSIM4pckappad == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcfGiven = (BSIM4pcf == `NOT_GIVEN) ? 0 : 1;
            BSIM4pclcGiven = (BSIM4pclc == `NOT_GIVEN) ? 0 : 1;
            BSIM4pcleGiven = (BSIM4pcle == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvfbcvGiven = (BSIM4pvfbcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4pnoffGiven = (BSIM4pnoff == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvoffcvGiven = (BSIM4pvoffcv == `NOT_GIVEN) ? 0 : 1;
            BSIM4pacdeGiven = (BSIM4pacde == `NOT_GIVEN) ? 0 : 1;
            BSIM4pmoinGiven = (BSIM4pmoin == `NOT_GIVEN) ? 0 : 1;
            BSIM4tnomGiven = (BSIM4tnom == `NOT_GIVEN) ? 0 : 1;
            BSIM4cgsoGiven = (BSIM4cgso == `NOT_GIVEN) ? 0 : 1;
            BSIM4cgdoGiven = (BSIM4cgdo == `NOT_GIVEN) ? 0 : 1;
            BSIM4cgboGiven = (BSIM4cgbo == `NOT_GIVEN) ? 0 : 1;
            BSIM4xpartGiven = (BSIM4xpart == `NOT_GIVEN) ? 0 : 1;
            BSIM4sheetResistanceGiven = (BSIM4sheetResistance == `NOT_GIVEN) ? 0 : 1;
            BSIM4SjctSatCurDensityGiven = 
                (BSIM4SjctSatCurDensity == `NOT_GIVEN) ? 0 : 1;
            BSIM4SjctSidewallSatCurDensityGiven = 
                (BSIM4SjctSidewallSatCurDensity == `NOT_GIVEN) ? 0 : 1;
            BSIM4SjctGateSidewallSatCurDensityGiven = 
                (BSIM4SjctGateSidewallSatCurDensity == `NOT_GIVEN) ? 0 : 1;
            BSIM4SbulkJctPotentialGiven = (
                BSIM4SbulkJctPotential == `NOT_GIVEN) ? 0 : 1;
            BSIM4SbulkJctBotGradingCoeffGiven = 
                (BSIM4SbulkJctBotGradingCoeff == `NOT_GIVEN) ? 0 : 1;
            BSIM4SsidewallJctPotentialGiven = 
                (BSIM4SsidewallJctPotential == `NOT_GIVEN) ? 0 : 1;
            BSIM4SGatesidewallJctPotentialGiven = 
                (BSIM4SGatesidewallJctPotential == `NOT_GIVEN) ? 0 : 1;
            BSIM4SbulkJctSideGradingCoeffGiven = 
                (BSIM4SbulkJctSideGradingCoeff == `NOT_GIVEN) ? 0 : 1;
            BSIM4SunitAreaJctCapGiven = (BSIM4SunitAreaJctCap == `NOT_GIVEN) ? 0 : 1;
            BSIM4SunitLengthSidewallJctCapGiven = 
                (BSIM4SunitLengthSidewallJctCap == `NOT_GIVEN) ? 0 : 1;
            BSIM4SbulkJctGateSideGradingCoeffGiven = 
                (BSIM4SbulkJctGateSideGradingCoeff == `NOT_GIVEN) ? 0 : 1;
            BSIM4SunitLengthGateSidewallJctCapGiven = 
                (BSIM4SunitLengthGateSidewallJctCap == `NOT_GIVEN) ? 0 : 1;
            BSIM4SjctEmissionCoeffGiven = 
                (BSIM4SjctEmissionCoeff == `NOT_GIVEN) ? 0 : 1;
            BSIM4SjctTempExponentGiven = 
                (BSIM4SjctTempExponent == `NOT_GIVEN) ? 0 : 1;
            BSIM4DjctSatCurDensityGiven = 
                (BSIM4DjctSatCurDensity == `NOT_GIVEN) ? 0 : 1;
            BSIM4DjctSidewallSatCurDensityGiven = 
                (BSIM4DjctSidewallSatCurDensity == `NOT_GIVEN) ? 0 : 1;
            BSIM4DjctGateSidewallSatCurDensityGiven = 
                (BSIM4DjctGateSidewallSatCurDensity == `NOT_GIVEN) ? 0 : 1;
            BSIM4DbulkJctPotentialGiven = 
                (BSIM4DbulkJctPotential == `NOT_GIVEN) ? 0 : 1;
            BSIM4DbulkJctBotGradingCoeffGiven = 
                (BSIM4DbulkJctBotGradingCoeff == `NOT_GIVEN) ? 0 : 1;
            BSIM4DsidewallJctPotentialGiven = 
                (BSIM4DsidewallJctPotential == `NOT_GIVEN) ? 0 : 1;
            BSIM4DGatesidewallJctPotentialGiven = 
                (BSIM4DGatesidewallJctPotential == `NOT_GIVEN) ? 0 : 1;
            BSIM4DbulkJctSideGradingCoeffGiven = 
                (BSIM4DbulkJctSideGradingCoeff == `NOT_GIVEN) ? 0 : 1;
            BSIM4DunitAreaJctCapGiven = (BSIM4DunitAreaJctCap == `NOT_GIVEN) ? 0 : 1;
            BSIM4DunitLengthSidewallJctCapGiven = 
                (BSIM4DunitLengthSidewallJctCap == `NOT_GIVEN) ? 0 : 1;
            BSIM4DbulkJctGateSideGradingCoeffGiven = 
                (BSIM4DbulkJctGateSideGradingCoeff == `NOT_GIVEN) ? 0 : 1;
            BSIM4DunitLengthGateSidewallJctCapGiven = 
                (BSIM4DunitLengthGateSidewallJctCap == `NOT_GIVEN) ? 0 : 1;
            BSIM4DjctEmissionCoeffGiven = 
                (BSIM4DjctEmissionCoeff == `NOT_GIVEN) ? 0 : 1;
            BSIM4DjctTempExponentGiven = 
                (BSIM4DjctTempExponent == `NOT_GIVEN) ? 0 : 1;
            BSIM4oxideTrapDensityAGiven = 
                (BSIM4oxideTrapDensityA == `NOT_GIVEN) ? 0 : 1;
            BSIM4oxideTrapDensityBGiven = 
                (BSIM4oxideTrapDensityB == `NOT_GIVEN) ? 0 : 1;
            BSIM4oxideTrapDensityCGiven = 
                (BSIM4oxideTrapDensityC == `NOT_GIVEN) ? 0 : 1;
            BSIM4emGiven = (BSIM4em == `NOT_GIVEN) ? 0 : 1;
            BSIM4efGiven = (BSIM4ef == `NOT_GIVEN) ? 0 : 1;
            BSIM4afGiven = (BSIM4af == `NOT_GIVEN) ? 0 : 1;
            BSIM4kfGiven = (BSIM4kf == `NOT_GIVEN) ? 0 : 1;
            BSIM4LintGiven = (BSIM4Lint == `NOT_GIVEN) ? 0 : 1;
            BSIM4LlGiven = (BSIM4Ll == `NOT_GIVEN) ? 0 : 1;
            BSIM4LlcGiven = (BSIM4Llc == `NOT_GIVEN) ? 0 : 1;
            BSIM4LlnGiven = (BSIM4Lln == `NOT_GIVEN) ? 0 : 1;
            BSIM4LwGiven = (BSIM4Lw == `NOT_GIVEN) ? 0 : 1;
            BSIM4LwcGiven = (BSIM4Lwc == `NOT_GIVEN) ? 0 : 1;
            BSIM4LwnGiven = (BSIM4Lwn == `NOT_GIVEN) ? 0 : 1;
            BSIM4LwlGiven = (BSIM4Lwl == `NOT_GIVEN) ? 0 : 1;
            BSIM4LwlcGiven = (BSIM4Lwlc == `NOT_GIVEN) ? 0 : 1;
            BSIM4LminGiven = (BSIM4Lmin == `NOT_GIVEN) ? 0 : 1;
            BSIM4LmaxGiven = (BSIM4Lmax == `NOT_GIVEN) ? 0 : 1;
            BSIM4WintGiven = (BSIM4Wint == `NOT_GIVEN) ? 0 : 1;
            BSIM4WlGiven = (BSIM4Wl == `NOT_GIVEN) ? 0 : 1;
            BSIM4WlcGiven = (BSIM4Wlc == `NOT_GIVEN) ? 0 : 1;
            BSIM4WlnGiven = (BSIM4Wln == `NOT_GIVEN) ? 0 : 1;
            BSIM4WwGiven = (BSIM4Ww == `NOT_GIVEN) ? 0 : 1;
            BSIM4WwcGiven = (BSIM4Wwc == `NOT_GIVEN) ? 0 : 1;
            BSIM4WwnGiven = (BSIM4Wwn == `NOT_GIVEN) ? 0 : 1;
            BSIM4WwlGiven = (BSIM4Wwl == `NOT_GIVEN) ? 0 : 1;
            BSIM4WwlcGiven = (BSIM4Wwlc == `NOT_GIVEN) ? 0 : 1;
            BSIM4WminGiven = (BSIM4Wmin == `NOT_GIVEN) ? 0 : 1;
            BSIM4WmaxGiven = (BSIM4Wmax == `NOT_GIVEN) ? 0 : 1;
    
            // BSIM4.3
            BSIM4tempModGiven = (BSIM4tempMod == `INT_NOT_GIVEN) ? 0 : 1;
            BSIM4xnGiven = (BSIM4xn == `NOT_GIVEN) ? 0 : 1;
            BSIM4lxnGiven = (BSIM4lxn == `NOT_GIVEN) ? 0 : 1;
            BSIM4wxnGiven = (BSIM4wxn == `NOT_GIVEN) ? 0 : 1;
            BSIM4pxnGiven = (BSIM4pxn == `NOT_GIVEN) ? 0 : 1;
            
            BSIM4rnoiaGiven = (BSIM4rnoia == `NOT_GIVEN) ? 0 : 1;
            BSIM4rnoibGiven = (BSIM4rnoib == `NOT_GIVEN) ? 0 : 1;
            BSIM4rnoicGiven = (BSIM4rnoic == `NOT_GIVEN) ? 0 : 1;
            
            BSIM4lambdaGiven = (BSIM4lambda == `NOT_GIVEN) ? 0 : 1;
            BSIM4llambdaGiven = (BSIM4llambda == `NOT_GIVEN) ? 0 : 1;
            BSIM4wlambdaGiven = (BSIM4wlambda == `NOT_GIVEN) ? 0 : 1;
            BSIM4plambdaGiven = (BSIM4plambda == `NOT_GIVEN) ? 0 : 1;
            BSIM4vtlGiven = (BSIM4vtl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lvtlGiven = (BSIM4lvtl == `NOT_GIVEN) ? 0 : 1;
            BSIM4wvtlGiven = (BSIM4wvtl == `NOT_GIVEN) ? 0 : 1;
            BSIM4pvtlGiven = (BSIM4pvtl == `NOT_GIVEN) ? 0 : 1;
            BSIM4lcGiven = (BSIM4lc == `NOT_GIVEN) ? 0 : 1;
            BSIM4saGiven = (BSIM4sa == `NOT_GIVEN) ? 0 : 1; 
            BSIM4sbGiven = (BSIM4sb == `NOT_GIVEN) ? 0 : 1; 
            BSIM4sdGiven = (BSIM4sd == `NOT_GIVEN) ? 0 : 1; 
            BSIM4sarefGiven = (BSIM4saref == `NOT_GIVEN) ? 0 : 1;
            BSIM4sbrefGiven = (BSIM4sbref == `NOT_GIVEN) ? 0 : 1;
            BSIM4wlodGiven = (BSIM4wlod == `NOT_GIVEN) ? 0 : 1;
            BSIM4ku0Given = (BSIM4ku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4kvsatGiven = (BSIM4kvsat == `NOT_GIVEN) ? 0 : 1;
            BSIM4tku0Given = (BSIM4tku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lku0Given = (BSIM4lku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wku0Given = (BSIM4wku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pku0Given = (BSIM4pku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4llodku0Given = (BSIM4llodku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wlodku0Given = (BSIM4wlodku0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4kvth0Given = (BSIM4kvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lkvth0Given = (BSIM4lkvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4wkvth0Given = (BSIM4wkvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4pkvth0Given = (BSIM4pkvth0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4llodvthGiven = (BSIM4llodvth == `NOT_GIVEN) ? 0 : 1;
            BSIM4wlodvthGiven = (BSIM4wlodvth == `NOT_GIVEN) ? 0 : 1;
            BSIM4stk2Given = (BSIM4stk2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lodk2Given = (BSIM4lodk2 == `NOT_GIVEN) ? 0 : 1;
            BSIM4steta0Given = (BSIM4steta0 == `NOT_GIVEN) ? 0 : 1;
            BSIM4lodeta0Given = (BSIM4lodeta0 == `NOT_GIVEN) ? 0 : 1;
            
            /* process defaults of model parameters */
            if (!BSIM4typeGiven)
                BSIM4type = `NMOS;     
            
            if (!BSIM4mobModGiven) 
                BSIM4mobMod = 0;
            else if ((BSIM4mobMod != 0) && (BSIM4mobMod != 1)
               && (BSIM4mobMod != 2) && (BSIM4mobMod != 3) && (BSIM4mobMod != 4)
               && (BSIM4mobMod != 5) && (BSIM4mobMod != 6) ) begin
                BSIM4mobMod = 0;
                $strobe("Warning: (instance X*) mobMod has been set to its default value: 0.\n");
            end 
    
            if (!BSIM4binUnitGiven) 
                BSIM4binUnit = 1;
            if (!BSIM4paramChkGiven) 
                BSIM4paramChk = 1;
    
            if (!BSIM4dioModGiven)
                BSIM4dioMod = 1;
            else if ((BSIM4dioMod != 0) && (BSIM4dioMod != 1)
               && (BSIM4dioMod != 2)) begin
                BSIM4dioMod = 1;
                $strobe("Warning: (instance X*) dioMod has been set to its default value: 1.\n");
            end 
    
            if (!BSIM4capModGiven) 
                BSIM4capMod = 2;
            else if ((BSIM4capMod != 0) && (BSIM4capMod != 1)
               && (BSIM4capMod != 2)) begin
                BSIM4capMod = 2;
                $strobe("Warning: (instance X*) capMod has been set to its default value: 2.\n");
            end 
    
            if (!BSIM4rdsModGiven)
                BSIM4rdsMod = 0;
            else if ((BSIM4rdsMod != 0) && (BSIM4rdsMod != 1)) begin
                BSIM4rdsMod = 0;
                $strobe("Warning: (instance X*) rdsMod has been set to its default value: 0.\n");
            end 
            if (!BSIM4rbodyModGiven)
                BSIM4rbodyMod = 0;
            else if ((BSIM4rbodyMod != 0) && (BSIM4rbodyMod != 1) && (BSIM4rbodyMod != 2)) begin
                BSIM4rbodyMod = 0;
                $strobe("Warning: (instance X*) rbodyMod has been set to its default value: 0.\n");
            end 
    
            if (!BSIM4rgateModGiven)
                BSIM4rgateMod = 0;
            else if ((BSIM4rgateMod != 0) && (BSIM4rgateMod != 1)
               && (BSIM4rgateMod != 2) && (BSIM4rgateMod != 3)) begin
                BSIM4rgateMod = 0;
                $strobe("Warning: (instance X*) rgateMod has been set to its default value: 0.\n");
            end 
    
            if (!BSIM4perModGiven)
                BSIM4perMod = 1;
            else if ((BSIM4perMod != 0) && (BSIM4perMod != 1)) begin
                BSIM4perMod = 1;
                $strobe("Warning: (instance X*) perMod has been set to its default value: 1.\n");
            end 
    
            if (!BSIM4geoModGiven)
                BSIM4geoMod = 0;
            if (!BSIM4rgeoModGiven)
                BSIM4rgeoMod = 0;
    
            if (!BSIM4fnoiModGiven) 
                BSIM4fnoiMod = 1;
            else if ((BSIM4fnoiMod != 0) && (BSIM4fnoiMod != 1)) begin
                BSIM4fnoiMod = 1;
                $strobe("Warning: (instance X*) fnoiMod has been set to its default value: 1.\n");
            end 
            if (!BSIM4tnoiModGiven)
                BSIM4tnoiMod = 0; /* WDLiu: tnoiMod=1 needs to set int S/D nodes */
            else if ((BSIM4tnoiMod != 0) && (BSIM4tnoiMod != 1)) begin
                BSIM4tnoiMod = 0;
                $strobe("Warning: (instance X*) tnoiMod has been set to its default value: 0.\n");
            end 
    
            if (!BSIM4trnqsModGiven)
                BSIM4trnqsMod = 0; 
            else if ((BSIM4trnqsMod != 0) && (BSIM4trnqsMod != 1)) begin
                BSIM4trnqsMod = 0;
                $strobe("Warning: (instance X*) trnqsMod has been set to its default value: 0.\n");
            end 
            if (!BSIM4acnqsModGiven)
                BSIM4acnqsMod = 0;
            else if ((BSIM4acnqsMod != 0) && (BSIM4acnqsMod != 1)) begin
                BSIM4acnqsMod = 0;
                $strobe("Warning: (instance X*) acnqsMod has been set to its default value: 0.\n");
            end 
    
            if (!BSIM4igcModGiven) begin
                BSIM4igcMod = 0;
                $strobe("\nRESET igcMod to 0");
            end
            else if ((BSIM4igcMod != 0) && (BSIM4igcMod != 1) && (BSIM4igcMod != 2)) begin
                BSIM4igcMod = 0;
                $strobe("Warning: (instance X*) igcMod has been set to its default value: 0.\n");
            end 
            if (!BSIM4igbModGiven)
                BSIM4igbMod = 0;
            else if ((BSIM4igbMod != 0) && (BSIM4igbMod != 1)) begin
                BSIM4igbMod = 0;
                $strobe("Warning: (instance X*) igbMod has been set to its default value: 0.\n");
            end 
    
            if (!BSIM4versionGiven) 
                BSIM4version = 4.8;
            if (!BSIM4toxrefGiven)
                BSIM4toxref = 30.0e-10;
            if (!BSIM4toxeGiven)
                BSIM4toxe = 30.0e-10;
            if (!BSIM4toxpGiven)
                BSIM4toxp = BSIM4toxe;
            if (!BSIM4toxmGiven)
                BSIM4toxm = BSIM4toxe;
            if (!BSIM4dtoxGiven)
                BSIM4dtox = 0.0;
            if (!BSIM4epsroxGiven)
                BSIM4epsrox = 3.9;
            if (!BSIM4cdscGiven)
                BSIM4cdsc = 2.4e-4; /* unit Q/V/m^2  */
            if (!BSIM4cdscbGiven)
                BSIM4cdscb = 0.0;   /* unit Q/V/m^2  */    
            if (!BSIM4cdscdGiven)
                BSIM4cdscd = 0.0;   /* unit Q/V/m^2  */
            if (!BSIM4citGiven)
                BSIM4cit = 0.0;     /* unit Q/V/m^2  */
            if (!BSIM4nfactorGiven)
                BSIM4nfactor = 1.0;
            if (!BSIM4xjGiven)
                BSIM4xj = 0.15e-6;
            if (!BSIM4vsatGiven)
                BSIM4vsat = 8.0e4;  /* unit m/s */ 
            if (!BSIM4atGiven)
                BSIM4at = 3.3e4;    /* unit m/s */ 
            if (!BSIM4a0Given)
                BSIM4a0 = 1.0;  
            if (!BSIM4agsGiven)
                BSIM4ags = 0.0;
            if (!BSIM4a1Given)
                BSIM4a1 = 0.0;
            if (!BSIM4a2Given)
                BSIM4a2 = 1.0;
            if (!BSIM4ketaGiven)
                BSIM4keta = -0.047;    /* unit  / V */
            if (!BSIM4nsubGiven)
                BSIM4nsub = 6.0e16;    /* unit 1/cm3 */
            if (!BSIM4ndepGiven)
                BSIM4ndep = 1.7e17;    /* unit 1/cm3 */
            if (!BSIM4nsdGiven)
                BSIM4nsd = 1.0e20;     /* unit 1/cm3 */
            if (!BSIM4phinGiven)
                BSIM4phin = 0.0;       /* unit V */
            if (!BSIM4ngateGiven)
                BSIM4ngate = 0;        /* unit 1/cm3 */
            if (!BSIM4vbmGiven)
                BSIM4vbm = -3.0;
            if (!BSIM4xtGiven)
                BSIM4xt = 1.55e-7;
            if (!BSIM4kt1Given)
                BSIM4kt1 = -0.11;      /* unit V */
            if (!BSIM4kt1lGiven)
                BSIM4kt1l = 0.0;       /* unit V*m */
            if (!BSIM4kt2Given)
                BSIM4kt2 = 0.022;      /* No unit */
            if (!BSIM4k3Given)
                BSIM4k3 = 80.0;      
            if (!BSIM4k3bGiven)
                BSIM4k3b = 0.0;      
            if (!BSIM4w0Given)
                BSIM4w0 = 2.5e-6;    
            if (!BSIM4lpe0Given)
                BSIM4lpe0 = 1.74e-7;     
            if (!BSIM4lpebGiven)
                BSIM4lpeb = 0.0;
            if (!BSIM4dvtp0Given)
                BSIM4dvtp0 = 0.0;
            if (!BSIM4dvtp1Given)
                BSIM4dvtp1 = 0.0;
            if (!BSIM4dvt0Given)
                BSIM4dvt0 = 2.2;    
            if (!BSIM4dvt1Given)
                BSIM4dvt1 = 0.53;      
            if (!BSIM4dvt2Given)
                BSIM4dvt2 = -0.032;     /* unit 1 / V */     
            if (!BSIM4dvt0wGiven)
                BSIM4dvt0w = 0.0;    
            if (!BSIM4dvt1wGiven)
                BSIM4dvt1w = 5.3e6;    
            if (!BSIM4dvt2wGiven)
                BSIM4dvt2w = -0.032;   
            if (!BSIM4droutGiven)
                BSIM4drout = 0.56;     
            if (!BSIM4dsubGiven)
                BSIM4dsub = BSIM4drout;     
            if (!BSIM4vth0Given)
                BSIM4vth0 = (BSIM4type == `NMOS) ? 0.7 : -0.7;
	    if (!BSIM4vfbGiven)
		BSIM4vfb = -1.0;
            if (!BSIM4euGiven)
                BSIM4eu = (BSIM4type == `NMOS) ? 1.67 : 1.0;
            if (!BSIM4uaGiven)
                BSIM4ua = (BSIM4mobMod == 2) ? 1.0e-15 : 1.0e-9; /* unit m/V */
            if (!BSIM4ua1Given)
                BSIM4ua1 = 1.0e-9;       /* unit m/V */
            if (!BSIM4ubGiven)
                BSIM4ub = 1.0e-19;       /* unit (m/V)**2 */
            if (!BSIM4ub1Given)
                BSIM4ub1 = -1.0e-18;     /* unit (m/V)**2 */
            if (!BSIM4ucGiven)
                BSIM4uc = (BSIM4mobMod == 1) ? -0.0465 : -0.0465e-9;   
            if (!BSIM4uc1Given)
                BSIM4uc1 = (BSIM4mobMod == 1) ? -0.056 : -0.056e-9;   
            if (!BSIM4u0Given)
                BSIM4u0 = (BSIM4type == `NMOS) ? 0.067 : 0.025;
            if (!BSIM4uteGiven)
                BSIM4ute = -1.5;   
            if (!BSIM4voffGiven)
                BSIM4voff = -0.08;
            if (!BSIM4vofflGiven)
                BSIM4voffl = 0.0;
            if (!BSIM4minvGiven)
                BSIM4minv = 0.0;
            if (!BSIM4fproutGiven)
                BSIM4fprout = 0.0;
            if (!BSIM4pditsGiven)
                BSIM4pdits = 0.0;
            if (!BSIM4pditsdGiven)
                BSIM4pditsd = 0.0;
            if (!BSIM4pditslGiven)
                BSIM4pditsl = 0.0;
            if (!BSIM4deltaGiven)  
                BSIM4delta = 0.01;
            if (!BSIM4rdswminGiven)
                BSIM4rdswmin = 0.0;
            if (!BSIM4rdwminGiven)
                BSIM4rdwmin = 0.0;
            if (!BSIM4rswminGiven)
                BSIM4rswmin = 0.0;
            if (!BSIM4rdswGiven)
                BSIM4rdsw = 200.0; /* in ohm*um */     
            if (!BSIM4rdwGiven)
                BSIM4rdw = 100.0;
            if (!BSIM4rswGiven)
                BSIM4rsw = 100.0;
            if (!BSIM4prwgGiven)
                BSIM4prwg = 1.0;   /* in 1/V */
            if (!BSIM4prwbGiven)
                BSIM4prwb = 0.0;      
            if (!BSIM4prtGiven)
                BSIM4prt = 0.0;      
            if (!BSIM4eta0Given)
                BSIM4eta0 = 0.08;      /* no unit  */ 
            if (!BSIM4etabGiven)
                BSIM4etab = -0.07;     /* unit  1/V */ 
            if (!BSIM4pclmGiven)
                BSIM4pclm = 1.3;       /* no unit  */ 
            if (!BSIM4pdibl1Given)
                BSIM4pdibl1 = 0.39;    /* no unit  */
            if (!BSIM4pdibl2Given)
                BSIM4pdibl2 = 0.0086;  /* no unit  */ 
            if (!BSIM4pdiblbGiven)
                BSIM4pdiblb = 0.0;     /* 1/V  */ 
            if (!BSIM4pscbe1Given)
                BSIM4pscbe1 = 4.24e8;     
            if (!BSIM4pscbe2Given)
                BSIM4pscbe2 = 1.0e-5;    
            if (!BSIM4pvagGiven)
                BSIM4pvag = 0.0;     
            if (!BSIM4wrGiven)  
                BSIM4wr = 1.0;
            if (!BSIM4dwgGiven)  
                BSIM4dwg = 0.0;
            if (!BSIM4dwbGiven)  
                BSIM4dwb = 0.0;
            if (!BSIM4b0Given)
                BSIM4b0 = 0.0;
            if (!BSIM4b1Given)  
                BSIM4b1 = 0.0;
            if (!BSIM4alpha0Given)  
                BSIM4alpha0 = 0.0;
            if (!BSIM4alpha1Given)
                BSIM4alpha1 = 0.0;
            if (!BSIM4beta0Given)  
                BSIM4beta0 = 0.0;
            if (!BSIM4agidlGiven)
                BSIM4agidl = 0.0;
            if (!BSIM4bgidlGiven)
                BSIM4bgidl = 2.3e9; /* V/m */
            if (!BSIM4cgidlGiven)
                BSIM4cgidl = 0.5;   /* V^3 */
            if (!BSIM4egidlGiven)
                BSIM4egidl = 0.8;   /* V */
            if (!BSIM4aigcGiven)
                BSIM4aigc = (BSIM4type == `NMOS) ? 1.36e-2 : 9.80e-3;
            if (!BSIM4bigcGiven)
                BSIM4bigc = (BSIM4type == `NMOS) ? 1.71e-3 : 7.59e-4;
            if (!BSIM4cigcGiven)
                BSIM4cigc = (BSIM4type == `NMOS) ? 0.075 : 0.03;
            if (BSIM4aigsdGiven) begin
              BSIM4aigs = BSIM4aigsd;
              BSIM4aigd = BSIM4aigsd;
            end
            else begin
                BSIM4aigsd = (BSIM4type == `NMOS) ? 1.36e-2 : 9.80e-3;
                if (!BSIM4aigsGiven)
                  BSIM4aigs = (BSIM4type == `NMOS) ? 1.36e-2 : 9.80e-3;
                if (!BSIM4aigdGiven)
                  BSIM4aigd = (BSIM4type == `NMOS) ? 1.36e-2 : 9.80e-3;
            end
            if (BSIM4bigsdGiven) begin
              BSIM4bigs = BSIM4bigsd;
              BSIM4bigd = BSIM4bigsd;
            end
            else begin
                BSIM4bigsd = (BSIM4type == `NMOS) ? 1.71e-3 : 7.59e-4; 
                if (!BSIM4bigsGiven)
                  BSIM4bigs = (BSIM4type == `NMOS) ? 1.71e-3 : 7.59e-4;
                if (!BSIM4bigdGiven)
                  BSIM4bigd = (BSIM4type == `NMOS) ? 1.71e-3 : 7.59e-4;
            end
            if (BSIM4cigsdGiven) begin
                BSIM4cigs =BSIM4cigsd;
                BSIM4cigd = BSIM4cigsd;
            end
            else begin
               BSIM4cigsd = (BSIM4type == `NMOS) ? 0.075 : 0.03;
               if (!BSIM4cigsGiven)
                    BSIM4cigs = (BSIM4type == `NMOS) ? 0.075 : 0.03;
               if (!BSIM4cigdGiven)
                    BSIM4cigd = (BSIM4type == `NMOS) ? 0.075 : 0.03;
            end
            
            if (!BSIM4aigbaccGiven)
                BSIM4aigbacc = 1.36e-2;
            if (!BSIM4bigbaccGiven)
                BSIM4bigbacc = 1.71e-3;
            if (!BSIM4cigbaccGiven)
                BSIM4cigbacc = 0.075;
            if (!BSIM4aigbinvGiven)
                BSIM4aigbinv = 1.11e-2;
            if (!BSIM4bigbinvGiven)
                BSIM4bigbinv = 9.49e-4;
            if (!BSIM4cigbinvGiven)
                BSIM4cigbinv = 0.006;
            if (!BSIM4nigcGiven)
                BSIM4nigc = 1.0;
            if (!BSIM4nigbinvGiven)
                BSIM4nigbinv = 3.0;
            if (!BSIM4nigbaccGiven)
                BSIM4nigbacc = 1.0;
            if (!BSIM4ntoxGiven)
                BSIM4ntox = 1.0;
            if (!BSIM4eigbinvGiven)
                BSIM4eigbinv = 1.1;
            if (!BSIM4pigcdGiven)
                BSIM4pigcd = 1.0;
            if (!BSIM4poxedgeGiven)
                BSIM4poxedge = 1.0;
            if (!BSIM4xrcrg1Given)
                BSIM4xrcrg1 = 12.0;
            if (!BSIM4xrcrg2Given)
                BSIM4xrcrg2 = 1.0;
            if (!BSIM4ijthsfwdGiven)
                BSIM4ijthsfwd = 0.1; /* unit A */
            if (!BSIM4ijthdfwdGiven)
                BSIM4ijthdfwd = BSIM4ijthsfwd;
            if (!BSIM4ijthsrevGiven)
                BSIM4ijthsrev = 0.1; /* unit A */
            if (!BSIM4ijthdrevGiven)
                BSIM4ijthdrev = BSIM4ijthsrev;
            if (!BSIM4tnoiaGiven)
                BSIM4tnoia = 1.5;
            if (!BSIM4tnoibGiven)
                BSIM4tnoib = 3.5;
            if (!BSIM4tnoicGiven)
                BSIM4tnoic = 0.0;
            if (!BSIM4ntnoiGiven)
                BSIM4ntnoi = 1.0;
            if (!BSIM4xjbvsGiven)
                BSIM4xjbvs = 1.0;       /* no unit */
            if (!BSIM4xjbvdGiven)
                BSIM4xjbvd = BSIM4xjbvs;
            if (!BSIM4bvsGiven)
                BSIM4bvs = 10.0;        /* V */
            if (!BSIM4bvdGiven)
                BSIM4bvd = BSIM4bvs;
            if (!BSIM4gbminGiven)
                BSIM4gbmin = 1.0e-12;   /* in mho */
            if (!BSIM4rbdbGiven)
                BSIM4rbdb = 50.0;       /* in ohm */
            if (!BSIM4rbpbGiven)
                BSIM4rbpb = 50.0;
            if (!BSIM4rbsbGiven)
                BSIM4rbsb = 50.0;
            if (!BSIM4rbpsGiven)
                BSIM4rbps = 50.0;
            if (!BSIM4rbpdGiven)
                BSIM4rbpd = 50.0;
            if (!BSIM4cgslGiven)  
                BSIM4cgsl = 0.0;
            if (!BSIM4cgdlGiven)  
                BSIM4cgdl = 0.0;
            if (!BSIM4ckappasGiven)  
                BSIM4ckappas = 0.6;
            if (!BSIM4ckappadGiven)
                BSIM4ckappad = BSIM4ckappas;
            if (!BSIM4clcGiven)  
                BSIM4clc = 0.1e-6;
            if (!BSIM4cleGiven)  
                BSIM4cle = 0.6;
            if (!BSIM4vfbcvGiven)  
                BSIM4vfbcv = -1.0;
            if (!BSIM4acdeGiven)
                BSIM4acde = 1.0;
            if (!BSIM4moinGiven)
                BSIM4moin = 15.0;
            if (!BSIM4noffGiven)
                BSIM4noff = 1.0;
            if (!BSIM4voffcvGiven)
                BSIM4voffcv = 0.0;
            if (!BSIM4dmcgGiven)
                BSIM4dmcg = 0.0;
            if (!BSIM4dmciGiven)
                BSIM4dmci = BSIM4dmcg;
            if (!BSIM4dmdgGiven)
                BSIM4dmdg = 0.0;
            if (!BSIM4dmcgtGiven)
                BSIM4dmcgt = 0.0;
            if (!BSIM4xgwGiven)
                BSIM4xgw = 0.0;
            if (!BSIM4xglGiven)
                BSIM4xgl = 0.0;
            if (!BSIM4rshgGiven)
                BSIM4rshg = 0.1;
            if (!BSIM4ngconGiven)
                BSIM4ngcon = 1.0;
            if (!BSIM4tcjGiven)
                BSIM4tcj = 0.0;
            if (!BSIM4tpbGiven)
                BSIM4tpb = 0.0;
            if (!BSIM4tcjswGiven)
                BSIM4tcjsw = 0.0;
            if (!BSIM4tpbswGiven)
                BSIM4tpbsw = 0.0;
            if (!BSIM4tcjswgGiven)
                BSIM4tcjswg = 0.0;
            if (!BSIM4tpbswgGiven)
                BSIM4tpbswg = 0.0;
    
            /* Length dependence */
            if (!BSIM4lcdscGiven)
                BSIM4lcdsc = 0.0;
            if (!BSIM4lcdscbGiven)
                BSIM4lcdscb = 0.0;
            if (!BSIM4lcdscdGiven) 
                BSIM4lcdscd = 0.0;
            if (!BSIM4lcitGiven)
                BSIM4lcit = 0.0;
            if (!BSIM4lnfactorGiven)
                BSIM4lnfactor = 0.0;
            if (!BSIM4lxjGiven)
                BSIM4lxj = 0.0;
            if (!BSIM4lvsatGiven)
                BSIM4lvsat = 0.0;
            if (!BSIM4latGiven)
                BSIM4lat = 0.0;
            if (!BSIM4la0Given)
                BSIM4la0 = 0.0; 
            if (!BSIM4lagsGiven)
                BSIM4lags = 0.0;
            if (!BSIM4la1Given)
                BSIM4la1 = 0.0;
            if (!BSIM4la2Given)
                BSIM4la2 = 0.0;
            if (!BSIM4lketaGiven)
                BSIM4lketa = 0.0;
            if (!BSIM4lnsubGiven)
                BSIM4lnsub = 0.0;
            if (!BSIM4lndepGiven)
                BSIM4lndep = 0.0;
            if (!BSIM4lnsdGiven)
                BSIM4lnsd = 0.0;
            if (!BSIM4lphinGiven)
                BSIM4lphin = 0.0;
            if (!BSIM4lngateGiven)
                BSIM4lngate = 0.0;
            if (!BSIM4lvbmGiven)
                BSIM4lvbm = 0.0;
            if (!BSIM4lxtGiven)
                BSIM4lxt = 0.0;
            if (!BSIM4lkt1Given)
                BSIM4lkt1 = 0.0; 
            if (!BSIM4lkt1lGiven)
                BSIM4lkt1l = 0.0;
            if (!BSIM4lkt2Given)
                BSIM4lkt2 = 0.0;
            if (!BSIM4lk3Given)
                BSIM4lk3 = 0.0;      
            if (!BSIM4lk3bGiven)
                BSIM4lk3b = 0.0;      
            if (!BSIM4lw0Given)
                BSIM4lw0 = 0.0;    
            if (!BSIM4llpe0Given)
                BSIM4llpe0 = 0.0;
            if (!BSIM4llpebGiven)
                BSIM4llpeb = 0.0;
            if (!BSIM4ldvtp0Given)
                BSIM4ldvtp0 = 0.0;
            if (!BSIM4ldvtp1Given)
                BSIM4ldvtp1 = 0.0;
            if (!BSIM4ldvt0Given)
                BSIM4ldvt0 = 0.0;    
            if (!BSIM4ldvt1Given)
                BSIM4ldvt1 = 0.0;      
            if (!BSIM4ldvt2Given)
                BSIM4ldvt2 = 0.0;
            if (!BSIM4ldvt0wGiven)
                BSIM4ldvt0w = 0.0;    
            if (!BSIM4ldvt1wGiven)
                BSIM4ldvt1w = 0.0;      
            if (!BSIM4ldvt2wGiven)
                BSIM4ldvt2w = 0.0;
            if (!BSIM4ldroutGiven)
                BSIM4ldrout = 0.0;     
            if (!BSIM4ldsubGiven)
                BSIM4ldsub = 0.0;
            if (!BSIM4lvth0Given)
                BSIM4lvth0 = 0.0;
            if (!BSIM4luaGiven)
                BSIM4lua = 0.0;
            if (!BSIM4lua1Given)
                BSIM4lua1 = 0.0;
            if (!BSIM4lubGiven)
                BSIM4lub = 0.0;
            if (!BSIM4lub1Given)
                BSIM4lub1 = 0.0;
            if (!BSIM4lucGiven)
                BSIM4luc = 0.0;
            if (!BSIM4luc1Given)
                BSIM4luc1 = 0.0;
            if (!BSIM4lu0Given)
                BSIM4lu0 = 0.0;
            if (!BSIM4luteGiven)
                BSIM4lute = 0.0;    
            if (!BSIM4lvoffGiven)
                BSIM4lvoff = 0.0;
            if (!BSIM4lminvGiven)
                BSIM4lminv = 0.0;
            if (!BSIM4lfproutGiven)
                BSIM4lfprout = 0.0;
            if (!BSIM4lpditsGiven)
                BSIM4lpdits = 0.0;
            if (!BSIM4lpditsdGiven)
                BSIM4lpditsd = 0.0;
            if (!BSIM4ldeltaGiven)  
                BSIM4ldelta = 0.0;
            if (!BSIM4lrdswGiven)
                BSIM4lrdsw = 0.0;
            if (!BSIM4lrdwGiven)
                BSIM4lrdw = 0.0;
            if (!BSIM4lrswGiven)
                BSIM4lrsw = 0.0;
            if (!BSIM4lprwbGiven)
                BSIM4lprwb = 0.0;
            if (!BSIM4lprwgGiven)
                BSIM4lprwg = 0.0;
            if (!BSIM4lprtGiven)
                BSIM4lprt = 0.0;
            if (!BSIM4leta0Given)
                BSIM4leta0 = 0.0;
            if (!BSIM4letabGiven)
                BSIM4letab = -0.0;
            if (!BSIM4lpclmGiven)
                BSIM4lpclm = 0.0; 
            if (!BSIM4lpdibl1Given)
                BSIM4lpdibl1 = 0.0;
            if (!BSIM4lpdibl2Given)
                BSIM4lpdibl2 = 0.0;
            if (!BSIM4lpdiblbGiven)
                BSIM4lpdiblb = 0.0;
            if (!BSIM4lpscbe1Given)
                BSIM4lpscbe1 = 0.0;
            if (!BSIM4lpscbe2Given)
                BSIM4lpscbe2 = 0.0;
            if (!BSIM4lpvagGiven)
                BSIM4lpvag = 0.0;     
            if (!BSIM4lwrGiven)  
                BSIM4lwr = 0.0;
            if (!BSIM4ldwgGiven)  
                BSIM4ldwg = 0.0;
            if (!BSIM4ldwbGiven)  
                BSIM4ldwb = 0.0;
            if (!BSIM4lb0Given)
                BSIM4lb0 = 0.0;
            if (!BSIM4lb1Given)  
                BSIM4lb1 = 0.0;
            if (!BSIM4lalpha0Given)  
                BSIM4lalpha0 = 0.0;
            if (!BSIM4lalpha1Given)
                BSIM4lalpha1 = 0.0;
            if (!BSIM4lbeta0Given)  
                BSIM4lbeta0 = 0.0;
            if (!BSIM4lagidlGiven)
                BSIM4lagidl = 0.0;
            if (!BSIM4lbgidlGiven)
                BSIM4lbgidl = 0.0;
            if (!BSIM4lcgidlGiven)
                BSIM4lcgidl = 0.0;
            if (!BSIM4legidlGiven)
                BSIM4legidl = 0.0;
            if (!BSIM4laigcGiven)
                BSIM4laigc = 0.0;
            if (!BSIM4lbigcGiven)
                BSIM4lbigc = 0.0;
            if (!BSIM4lcigcGiven)
                BSIM4lcigc = 0.0;
            if (!BSIM4laigsdGiven)
                BSIM4laigsd = 0.0;
            if (!BSIM4lbigsdGiven)
                BSIM4lbigsd = 0.0;
            if (!BSIM4lcigsdGiven)
                BSIM4lcigsd = 0.0;
            if (!BSIM4laigbaccGiven)
                BSIM4laigbacc = 0.0;
            if (!BSIM4lbigbaccGiven)
                BSIM4lbigbacc = 0.0;
            if (!BSIM4lcigbaccGiven)
                BSIM4lcigbacc = 0.0;
            if (!BSIM4laigbinvGiven)
                BSIM4laigbinv = 0.0;
            if (!BSIM4lbigbinvGiven)
                BSIM4lbigbinv = 0.0;
            if (!BSIM4lcigbinvGiven)
                BSIM4lcigbinv = 0.0;
            if (!BSIM4lnigcGiven)
                BSIM4lnigc = 0.0;
            if (!BSIM4lnigbinvGiven)
                BSIM4lnigbinv = 0.0;
            if (!BSIM4lnigbaccGiven)
                BSIM4lnigbacc = 0.0;
            if (!BSIM4lntoxGiven)
                BSIM4lntox = 0.0;
            if (!BSIM4leigbinvGiven)
                BSIM4leigbinv = 0.0;
            if (!BSIM4lpigcdGiven)
                BSIM4lpigcd = 0.0;
            if (!BSIM4lpoxedgeGiven)
                BSIM4lpoxedge = 0.0;
            if (!BSIM4lxrcrg1Given)
                BSIM4lxrcrg1 = 0.0;
            if (!BSIM4lxrcrg2Given)
                BSIM4lxrcrg2 = 0.0;
            if (!BSIM4leuGiven)
                BSIM4leu = 0.0;
            if (!BSIM4lvfbGiven)
                BSIM4lvfb = 0.0;
            if (!BSIM4lcgslGiven)  
                BSIM4lcgsl = 0.0;
            if (!BSIM4lcgdlGiven)  
                BSIM4lcgdl = 0.0;
            if (!BSIM4lckappasGiven)  
                BSIM4lckappas = 0.0;
            if (!BSIM4lckappadGiven)
                BSIM4lckappad = 0.0;
            if (!BSIM4lclcGiven)  
                BSIM4lclc = 0.0;
            if (!BSIM4lcleGiven)  
                BSIM4lcle = 0.0;
            if (!BSIM4lcfGiven)  
                BSIM4lcf = 0.0;
            if (!BSIM4lvfbcvGiven)  
                BSIM4lvfbcv = 0.0;
            if (!BSIM4lacdeGiven)
                BSIM4lacde = 0.0;
            if (!BSIM4lmoinGiven)
                BSIM4lmoin = 0.0;
            if (!BSIM4lnoffGiven)
                BSIM4lnoff = 0.0;
            if (!BSIM4lvoffcvGiven)
                BSIM4lvoffcv = 0.0;
            if (!BSIM4lgamma1Given)
                 BSIM4lgamma1 = 0.0;
            if (!BSIM4lgamma2Given)
                 BSIM4lgamma2 = 0.0;
            if (!BSIM4lvbxGiven)
                 BSIM4lvbx = 0.0;
            if (!BSIM4lk1Given)
                 BSIM4lk1 = 0.0;
            if (!BSIM4lk2Given)
                 BSIM4lk2 = 0.0;

            /* Width dependence */
            if (!BSIM4wcdscGiven)
                BSIM4wcdsc = 0.0;
            if (!BSIM4wcdscbGiven)
                BSIM4wcdscb = 0.0;  
            if (!BSIM4wcdscdGiven)
                BSIM4wcdscd = 0.0;
            if (!BSIM4wcitGiven)
                BSIM4wcit = 0.0;
            if (!BSIM4wnfactorGiven)
                BSIM4wnfactor = 0.0;
            if (!BSIM4wxjGiven)
                BSIM4wxj = 0.0;
            if (!BSIM4wvsatGiven)
                BSIM4wvsat = 0.0;
            if (!BSIM4watGiven)
                BSIM4wat = 0.0;
            if (!BSIM4wa0Given)
                BSIM4wa0 = 0.0; 
            if (!BSIM4wagsGiven)
                BSIM4wags = 0.0;
            if (!BSIM4wa1Given)
                BSIM4wa1 = 0.0;
            if (!BSIM4wa2Given)
                BSIM4wa2 = 0.0;
            if (!BSIM4wketaGiven)
                BSIM4wketa = 0.0;
            if (!BSIM4wnsubGiven)
                BSIM4wnsub = 0.0;
            if (!BSIM4wndepGiven)
                BSIM4wndep = 0.0;
            if (!BSIM4wnsdGiven)
                BSIM4wnsd = 0.0;
            if (!BSIM4wphinGiven)
                BSIM4wphin = 0.0;
            if (!BSIM4wngateGiven)
                BSIM4wngate = 0.0;
            if (!BSIM4wvbmGiven)
                BSIM4wvbm = 0.0;
            if (!BSIM4wxtGiven)
                BSIM4wxt = 0.0;
            if (!BSIM4wkt1Given)
                BSIM4wkt1 = 0.0; 
            if (!BSIM4wkt1lGiven)
                BSIM4wkt1l = 0.0;
            if (!BSIM4wkt2Given)
                BSIM4wkt2 = 0.0;
            if (!BSIM4wk3Given)
                BSIM4wk3 = 0.0;      
            if (!BSIM4wk3bGiven)
                BSIM4wk3b = 0.0;      
            if (!BSIM4ww0Given)
                BSIM4ww0 = 0.0;    
            if (!BSIM4wlpe0Given)
                BSIM4wlpe0 = 0.0;
            if (!BSIM4wlpebGiven)
                BSIM4wlpeb = BSIM4wlpe0;
            if (!BSIM4wdvtp0Given)
                BSIM4wdvtp0 = 0.0;
            if (!BSIM4wdvtp1Given)
                BSIM4wdvtp1 = 0.0;
            if (!BSIM4wdvt0Given)
                BSIM4wdvt0 = 0.0;    
            if (!BSIM4wdvt1Given)
                BSIM4wdvt1 = 0.0;      
            if (!BSIM4wdvt2Given)
                BSIM4wdvt2 = 0.0;
            if (!BSIM4wdvt0wGiven)
                BSIM4wdvt0w = 0.0;    
            if (!BSIM4wdvt1wGiven)
                BSIM4wdvt1w = 0.0;      
            if (!BSIM4wdvt2wGiven)
                BSIM4wdvt2w = 0.0;
            if (!BSIM4wdroutGiven)
                BSIM4wdrout = 0.0;     
            if (!BSIM4wdsubGiven)
                BSIM4wdsub = 0.0;
            if (!BSIM4wvth0Given)
                BSIM4wvth0 = 0.0;
            if (!BSIM4wuaGiven)
                BSIM4wua = 0.0;
            if (!BSIM4wua1Given)
                BSIM4wua1 = 0.0;
            if (!BSIM4wubGiven)
                BSIM4wub = 0.0;
            if (!BSIM4wub1Given)
                BSIM4wub1 = 0.0;
            if (!BSIM4wucGiven)
                BSIM4wuc = 0.0;
            if (!BSIM4wuc1Given)
                BSIM4wuc1 = 0.0;
            if (!BSIM4wu0Given)
                BSIM4wu0 = 0.0;
            if (!BSIM4wuteGiven)
                BSIM4wute = 0.0;    
            if (!BSIM4wvoffGiven)
                BSIM4wvoff = 0.0;
            if (!BSIM4wminvGiven)
                BSIM4wminv = 0.0;
            if (!BSIM4wfproutGiven)
                BSIM4wfprout = 0.0;
            if (!BSIM4wpditsGiven)
                BSIM4wpdits = 0.0;
            if (!BSIM4wpditsdGiven)
                BSIM4wpditsd = 0.0;
            if (!BSIM4wdeltaGiven)  
                BSIM4wdelta = 0.0;
            if (!BSIM4wrdswGiven)
                BSIM4wrdsw = 0.0;
            if (!BSIM4wrdwGiven)
                BSIM4wrdw = 0.0;
            if (!BSIM4wrswGiven)
                BSIM4wrsw = 0.0;
            if (!BSIM4wprwbGiven)
                BSIM4wprwb = 0.0;
            if (!BSIM4wprwgGiven)
                BSIM4wprwg = 0.0;
            if (!BSIM4wprtGiven)
                BSIM4wprt = 0.0;
            if (!BSIM4weta0Given)
                BSIM4weta0 = 0.0;
            if (!BSIM4wetabGiven)
                BSIM4wetab = 0.0;
            if (!BSIM4wpclmGiven)
                BSIM4wpclm = 0.0; 
            if (!BSIM4wpdibl1Given)
                BSIM4wpdibl1 = 0.0;
            if (!BSIM4wpdibl2Given)
                BSIM4wpdibl2 = 0.0;
            if (!BSIM4wpdiblbGiven)
                BSIM4wpdiblb = 0.0;
            if (!BSIM4wpscbe1Given)
                BSIM4wpscbe1 = 0.0;
            if (!BSIM4wpscbe2Given)
                BSIM4wpscbe2 = 0.0;
            if (!BSIM4wpvagGiven)
                BSIM4wpvag = 0.0;     
            if (!BSIM4wwrGiven)  
                BSIM4wwr = 0.0;
            if (!BSIM4wdwgGiven)  
                BSIM4wdwg = 0.0;
            if (!BSIM4wdwbGiven)  
                BSIM4wdwb = 0.0;
            if (!BSIM4wb0Given)
                BSIM4wb0 = 0.0;
            if (!BSIM4wb1Given)  
                BSIM4wb1 = 0.0;
            if (!BSIM4walpha0Given)  
                BSIM4walpha0 = 0.0;
            if (!BSIM4walpha1Given)
                BSIM4walpha1 = 0.0;
            if (!BSIM4wbeta0Given)  
                BSIM4wbeta0 = 0.0;
            if (!BSIM4wagidlGiven)
                BSIM4wagidl = 0.0;
            if (!BSIM4wbgidlGiven)
                BSIM4wbgidl = 0.0;
            if (!BSIM4wcgidlGiven)
                BSIM4wcgidl = 0.0;
            if (!BSIM4wegidlGiven)
                BSIM4wegidl = 0.0;
            if (!BSIM4waigcGiven)
                BSIM4waigc = 0.0;
            if (!BSIM4wbigcGiven)
                BSIM4wbigc = 0.0;
            if (!BSIM4wcigcGiven)
                BSIM4wcigc = 0.0;
            if (!BSIM4waigsdGiven)
                BSIM4waigsd = 0.0;
            if (!BSIM4wbigsdGiven)
                BSIM4wbigsd = 0.0;
            if (!BSIM4wcigsdGiven)
                BSIM4wcigsd = 0.0;
            if (!BSIM4waigbaccGiven)
                BSIM4waigbacc = 0.0;
            if (!BSIM4wbigbaccGiven)
                BSIM4wbigbacc = 0.0;
            if (!BSIM4wcigbaccGiven)
                BSIM4wcigbacc = 0.0;
            if (!BSIM4waigbinvGiven)
                BSIM4waigbinv = 0.0;
            if (!BSIM4wbigbinvGiven)
                BSIM4wbigbinv = 0.0;
            if (!BSIM4wcigbinvGiven)
                BSIM4wcigbinv = 0.0;
            if (!BSIM4wnigcGiven)
                BSIM4wnigc = 0.0;
            if (!BSIM4wnigbinvGiven)
                BSIM4wnigbinv = 0.0;
            if (!BSIM4wnigbaccGiven)
                BSIM4wnigbacc = 0.0;
            if (!BSIM4wntoxGiven)
                BSIM4wntox = 0.0;
            if (!BSIM4weigbinvGiven)
                BSIM4weigbinv = 0.0;
            if (!BSIM4wpigcdGiven)
                BSIM4wpigcd = 0.0;
            if (!BSIM4wpoxedgeGiven)
                BSIM4wpoxedge = 0.0;
            if (!BSIM4wxrcrg1Given)
                BSIM4wxrcrg1 = 0.0;
            if (!BSIM4wxrcrg2Given)
                BSIM4wxrcrg2 = 0.0;
            if (!BSIM4weuGiven)
                BSIM4weu = 0.0;
            if (!BSIM4wvfbGiven)
                BSIM4wvfb = 0.0;
            if (!BSIM4wcgslGiven)  
                BSIM4wcgsl = 0.0;
            if (!BSIM4wcgdlGiven)  
                BSIM4wcgdl = 0.0;
            if (!BSIM4wckappasGiven)  
                BSIM4wckappas = 0.0;
            if (!BSIM4wckappadGiven)
                BSIM4wckappad = 0.0;
            if (!BSIM4wcfGiven)  
                BSIM4wcf = 0.0;
            if (!BSIM4wclcGiven)  
                BSIM4wclc = 0.0;
            if (!BSIM4wcleGiven)  
                BSIM4wcle = 0.0;
            if (!BSIM4wvfbcvGiven)  
                BSIM4wvfbcv = 0.0;
            if (!BSIM4wacdeGiven)
                BSIM4wacde = 0.0;
            if (!BSIM4wmoinGiven)
                BSIM4wmoin = 0.0;
            if (!BSIM4wnoffGiven)
                BSIM4wnoff = 0.0;
            if (!BSIM4wvoffcvGiven)
                BSIM4wvoffcv = 0.0;
            if (!BSIM4wgamma2Given)
                 BSIM4wgamma2 = 0.0;
            if (!BSIM4wvbxGiven)
                 BSIM4wvbx = 0.0;
            if (!BSIM4wk1Given)
                 BSIM4wk1 = 0.0;
            if (!BSIM4wk1Given)
                 BSIM4wk1 = 0.0;
    
            /* Cross-term dependence */
            if (!BSIM4pcdscGiven)
                BSIM4pcdsc = 0.0;
            if (!BSIM4pcdscbGiven)
                BSIM4pcdscb = 0.0;   
            if (!BSIM4pcdscdGiven)
                BSIM4pcdscd = 0.0;
            if (!BSIM4pcitGiven)
                BSIM4pcit = 0.0;
            if (!BSIM4pnfactorGiven)
                BSIM4pnfactor = 0.0;
            if (!BSIM4pxjGiven)
                BSIM4pxj = 0.0;
            if (!BSIM4pvsatGiven)
                BSIM4pvsat = 0.0;
            if (!BSIM4patGiven)
                BSIM4pat = 0.0;
            if (!BSIM4pa0Given)
                BSIM4pa0 = 0.0; 
            if (!BSIM4pagsGiven)
                BSIM4pags = 0.0;
            if (!BSIM4pa1Given)
                BSIM4pa1 = 0.0;
            if (!BSIM4pa2Given)
                BSIM4pa2 = 0.0;
            if (!BSIM4pketaGiven)
                BSIM4pketa = 0.0;
            if (!BSIM4pnsubGiven)
                BSIM4pnsub = 0.0;
            if (!BSIM4pndepGiven)
                BSIM4pndep = 0.0;
            if (!BSIM4pnsdGiven)
                BSIM4pnsd = 0.0;
            if (!BSIM4pphinGiven)
                BSIM4pphin = 0.0;
            if (!BSIM4pngateGiven)
                BSIM4pngate = 0.0;
            if (!BSIM4pvbmGiven)
                BSIM4pvbm = 0.0;
            if (!BSIM4pxtGiven)
                BSIM4pxt = 0.0;
            if (!BSIM4pkt1Given)
                BSIM4pkt1 = 0.0; 
            if (!BSIM4pkt1lGiven)
                BSIM4pkt1l = 0.0;
            if (!BSIM4pkt2Given)
                BSIM4pkt2 = 0.0;
            if (!BSIM4pk3Given)
                BSIM4pk3 = 0.0;      
            if (!BSIM4pk3bGiven)
                BSIM4pk3b = 0.0;      
            if (!BSIM4pw0Given)
                BSIM4pw0 = 0.0;    
            if (!BSIM4plpe0Given)
                BSIM4plpe0 = 0.0;
            if (!BSIM4plpebGiven)
                BSIM4plpeb = BSIM4plpe0;
            if (!BSIM4pdvtp0Given)
                BSIM4pdvtp0 = 0.0;
            if (!BSIM4pdvtp1Given)
                BSIM4pdvtp1 = 0.0;
            if (!BSIM4pdvt0Given)
                BSIM4pdvt0 = 0.0;    
            if (!BSIM4pdvt1Given)
                BSIM4pdvt1 = 0.0;      
            if (!BSIM4pdvt2Given)
                BSIM4pdvt2 = 0.0;
            if (!BSIM4pdvt0wGiven)
                BSIM4pdvt0w = 0.0;    
            if (!BSIM4pdvt1wGiven)
                BSIM4pdvt1w = 0.0;      
            if (!BSIM4pdvt2wGiven)
                BSIM4pdvt2w = 0.0;
            if (!BSIM4pdroutGiven)
                BSIM4pdrout = 0.0;     
            if (!BSIM4pdsubGiven)
                BSIM4pdsub = 0.0;
            if (!BSIM4pvth0Given)
                BSIM4pvth0 = 0.0;
            if (!BSIM4puaGiven)
                BSIM4pua = 0.0;
            if (!BSIM4pua1Given)
                BSIM4pua1 = 0.0;
            if (!BSIM4pubGiven)
                BSIM4pub = 0.0;
            if (!BSIM4pub1Given)
                BSIM4pub1 = 0.0;
            if (!BSIM4pucGiven)
                BSIM4puc = 0.0;
            if (!BSIM4puc1Given)
                BSIM4puc1 = 0.0;
            if (!BSIM4pu0Given)
                BSIM4pu0 = 0.0;
            if (!BSIM4puteGiven)
                BSIM4pute = 0.0;    
            if (!BSIM4pvoffGiven)
                BSIM4pvoff = 0.0;
            if (!BSIM4pminvGiven)
                BSIM4pminv = 0.0;
            if (!BSIM4pfproutGiven)
                BSIM4pfprout = 0.0;
            if (!BSIM4ppditsGiven)
                BSIM4ppdits = 0.0;
            if (!BSIM4ppditsdGiven)
                BSIM4ppditsd = 0.0;
            if (!BSIM4pdeltaGiven)  
                BSIM4pdelta = 0.0;
            if (!BSIM4prdswGiven)
                BSIM4prdsw = 0.0;
            if (!BSIM4prdwGiven)
                BSIM4prdw = 0.0;
            if (!BSIM4prswGiven)
                BSIM4prsw = 0.0;
            if (!BSIM4pprwbGiven)
                BSIM4pprwb = 0.0;
            if (!BSIM4pprwgGiven)
                BSIM4pprwg = 0.0;
            if (!BSIM4pprtGiven)
                BSIM4pprt = 0.0;
            if (!BSIM4peta0Given)
                BSIM4peta0 = 0.0;
            if (!BSIM4petabGiven)
                BSIM4petab = 0.0;
            if (!BSIM4ppclmGiven)
                BSIM4ppclm = 0.0; 
            if (!BSIM4ppdibl1Given)
                BSIM4ppdibl1 = 0.0;
            if (!BSIM4ppdibl2Given)
                BSIM4ppdibl2 = 0.0;
            if (!BSIM4ppdiblbGiven)
                BSIM4ppdiblb = 0.0;
            if (!BSIM4ppscbe1Given)
                BSIM4ppscbe1 = 0.0;
            if (!BSIM4ppscbe2Given)
                BSIM4ppscbe2 = 0.0;
            if (!BSIM4ppvagGiven)
                BSIM4ppvag = 0.0;     
            if (!BSIM4pwrGiven)  
                BSIM4pwr = 0.0;
            if (!BSIM4pdwgGiven)  
                BSIM4pdwg = 0.0;
            if (!BSIM4pdwbGiven)  
                BSIM4pdwb = 0.0;
            if (!BSIM4pb0Given)
                BSIM4pb0 = 0.0;
            if (!BSIM4pb1Given)  
                BSIM4pb1 = 0.0;
            if (!BSIM4palpha0Given)  
                BSIM4palpha0 = 0.0;
            if (!BSIM4palpha1Given)
                BSIM4palpha1 = 0.0;
            if (!BSIM4pbeta0Given)  
                BSIM4pbeta0 = 0.0;
            if (!BSIM4pagidlGiven)
                BSIM4pagidl = 0.0;
            if (!BSIM4pbgidlGiven)
                BSIM4pbgidl = 0.0;
            if (!BSIM4pcgidlGiven)
                BSIM4pcgidl = 0.0;
            if (!BSIM4pegidlGiven)
                BSIM4pegidl = 0.0;
            if (!BSIM4paigcGiven)
                BSIM4paigc = 0.0;
            if (!BSIM4pbigcGiven)
                BSIM4pbigc = 0.0;
            if (!BSIM4pcigcGiven)
                BSIM4pcigc = 0.0;
            if (!BSIM4paigsdGiven)
                BSIM4paigsd = 0.0;
            if (!BSIM4pbigsdGiven)
                BSIM4pbigsd = 0.0;
            if (!BSIM4pcigsdGiven)
                BSIM4pcigsd = 0.0;
            if (!BSIM4paigbaccGiven)
                BSIM4paigbacc = 0.0;
            if (!BSIM4pbigbaccGiven)
                BSIM4pbigbacc = 0.0;
            if (!BSIM4pcigbaccGiven)
                BSIM4pcigbacc = 0.0;
            if (!BSIM4paigbinvGiven)
                BSIM4paigbinv = 0.0;
            if (!BSIM4pbigbinvGiven)
                BSIM4pbigbinv = 0.0;
            if (!BSIM4pcigbinvGiven)
                BSIM4pcigbinv = 0.0;
            if (!BSIM4pnigcGiven)
                BSIM4pnigc = 0.0;
            if (!BSIM4pnigbinvGiven)
                BSIM4pnigbinv = 0.0;
            if (!BSIM4pnigbaccGiven)
                BSIM4pnigbacc = 0.0;
            if (!BSIM4pntoxGiven)
                BSIM4pntox = 0.0;
            if (!BSIM4peigbinvGiven)
                BSIM4peigbinv = 0.0;
            if (!BSIM4ppigcdGiven)
                BSIM4ppigcd = 0.0;
            if (!BSIM4ppoxedgeGiven)
                BSIM4ppoxedge = 0.0;
            if (!BSIM4pxrcrg1Given)
                BSIM4pxrcrg1 = 0.0;
            if (!BSIM4pxrcrg2Given)
                BSIM4pxrcrg2 = 0.0;
            if (!BSIM4peuGiven)
                BSIM4peu = 0.0;
            if (!BSIM4pvfbGiven)
                BSIM4pvfb = 0.0;
            if (!BSIM4pcgslGiven)  
                BSIM4pcgsl = 0.0;
            if (!BSIM4pcgdlGiven)  
                BSIM4pcgdl = 0.0;
            if (!BSIM4pckappasGiven)  
                BSIM4pckappas = 0.0;
            if (!BSIM4pckappadGiven)
                BSIM4pckappad = 0.0;
            if (!BSIM4pcfGiven)  
                BSIM4pcf = 0.0;
            if (!BSIM4pclcGiven)  
                BSIM4pclc = 0.0;
            if (!BSIM4pcleGiven)  
                BSIM4pcle = 0.0;
            if (!BSIM4pvfbcvGiven)  
                BSIM4pvfbcv = 0.0;
            if (!BSIM4pacdeGiven)
                BSIM4pacde = 0.0;
            if (!BSIM4pmoinGiven)
                BSIM4pmoin = 0.0;
            if (!BSIM4pnoffGiven)
                BSIM4pnoff = 0.0;
            if (!BSIM4pvoffcvGiven)
                BSIM4pvoffcv = 0.0;
            if (!BSIM4pphinGiven)
                BSIM4pphin = 0.0;
            if (!BSIM4pgamma1Given)
                BSIM4pgamma1 = 0.0;
            if (!BSIM4pgamma2Given)
                BSIM4pgamma2 = 0.0;
            if (!BSIM4pvbxGiven)
                BSIM4pvbx = 0.0;
            if (!BSIM4pvbxGiven)
                BSIM4pvbx = 0.0;
            if (!BSIM4pk1Given)
                BSIM4pk1 = 0.0;
            if (!BSIM4pk2Given)
                BSIM4pk2 = 0.0;


    
            /* NOTE: Verilog-A does not support access to the modelcard
             * default Tnom value */
            if (BSIM4tnom == `NOT_GIVEN)  
                BSIM4tnom = `DEFAULT_TNOM + `P_CELSIUS0;  
            else  // Shift from C to K:
                BSIM4tnom = BSIM4tnom + `P_CELSIUS0;
            if (!BSIM4LintGiven)  
                BSIM4Lint = 0.0;
            if (!BSIM4LlGiven)  
                BSIM4Ll = 0.0;
            if (!BSIM4LlcGiven)
                BSIM4Llc = BSIM4Ll;
            if (!BSIM4LlnGiven)  
                BSIM4Lln = 1.0;
            if (!BSIM4LwGiven)  
                BSIM4Lw = 0.0;
            if (!BSIM4LwcGiven)
                BSIM4Lwc = BSIM4Lw;
            if (!BSIM4LwnGiven)  
                BSIM4Lwn = 1.0;
            if (!BSIM4LwlGiven)  
                BSIM4Lwl = 0.0;
            if (!BSIM4LwlcGiven)
                BSIM4Lwlc = BSIM4Lwl;
            if (!BSIM4LminGiven)  
                BSIM4Lmin = 0.0;
            if (!BSIM4LmaxGiven)  
                BSIM4Lmax = 1.0;
            if (!BSIM4WintGiven)  
                BSIM4Wint = 0.0;
            if (!BSIM4WlGiven)  
                BSIM4Wl = 0.0;
            if (!BSIM4WlcGiven)
                BSIM4Wlc = BSIM4Wl;
            if (!BSIM4WlnGiven)  
                BSIM4Wln = 1.0;
            if (!BSIM4WwGiven)  
                BSIM4Ww = 0.0;
            if (!BSIM4WwcGiven)
                BSIM4Wwc = BSIM4Ww;
            if (!BSIM4WwnGiven)  
                BSIM4Wwn = 1.0;
            if (!BSIM4WwlGiven)  
                BSIM4Wwl = 0.0;
            if (!BSIM4WwlcGiven)
                BSIM4Wwlc = BSIM4Wwl;
            if (!BSIM4WminGiven)  
                BSIM4Wmin = 0.0;
            if (!BSIM4WmaxGiven)  
                BSIM4Wmax = 1.0;
            if (!BSIM4dwcGiven)  
                BSIM4dwc = BSIM4Wint;
            if (!BSIM4dlcGiven)  
                BSIM4dlc = BSIM4Lint;
            if (!BSIM4xlGiven)  
                BSIM4xl = 0.0;
            if (!BSIM4xwGiven)  
                BSIM4xw = 0.0;
            if (!BSIM4dlcigGiven)
                BSIM4dlcig = BSIM4Lint;
            if (!BSIM4dlcigdGiven)
                BSIM4dlcigd = BSIM4Lint;
            if (!BSIM4dwjGiven)
                BSIM4dwj = BSIM4dwc;
            if (!BSIM4cfGiven)
                BSIM4cf = 2.0 * BSIM4epsrox * `P_EPS0 / `M_PI
               * ln(1.0 + 0.4e-6 / BSIM4toxe);
            if (!BSIM4xpartGiven)
                BSIM4xpart = 0.0;
            if (!BSIM4sheetResistanceGiven)
                BSIM4sheetResistance = 0.0;
            if (!BSIM4SunitAreaJctCapGiven)
                BSIM4SunitAreaJctCap = 5.0E-4;
            if (!BSIM4DunitAreaJctCapGiven)
                BSIM4DunitAreaJctCap = BSIM4SunitAreaJctCap;
            if (!BSIM4SunitLengthSidewallJctCapGiven)
                BSIM4SunitLengthSidewallJctCap = 5.0E-10;
            if (!BSIM4DunitLengthSidewallJctCapGiven)
                BSIM4DunitLengthSidewallJctCap = BSIM4SunitLengthSidewallJctCap;
            if (!BSIM4SunitLengthGateSidewallJctCapGiven)
                BSIM4SunitLengthGateSidewallJctCap = BSIM4SunitLengthSidewallJctCap;
            if (!BSIM4DunitLengthGateSidewallJctCapGiven)
                BSIM4DunitLengthGateSidewallJctCap = BSIM4SunitLengthGateSidewallJctCap;
            if (!BSIM4SjctSatCurDensityGiven)
                BSIM4SjctSatCurDensity = 1.0E-4;
            if (!BSIM4DjctSatCurDensityGiven)
                BSIM4DjctSatCurDensity = BSIM4SjctSatCurDensity;
            if (!BSIM4SjctSidewallSatCurDensityGiven)
                BSIM4SjctSidewallSatCurDensity = 0.0;
            if (!BSIM4DjctSidewallSatCurDensityGiven)
                BSIM4DjctSidewallSatCurDensity = BSIM4SjctSidewallSatCurDensity;
            if (!BSIM4SjctGateSidewallSatCurDensityGiven)
                BSIM4SjctGateSidewallSatCurDensity = 0.0;
            if (!BSIM4DjctGateSidewallSatCurDensityGiven)
                BSIM4DjctGateSidewallSatCurDensity = BSIM4SjctGateSidewallSatCurDensity;
            if (!BSIM4SbulkJctPotentialGiven)
                BSIM4SbulkJctPotential = 1.0;
            if (!BSIM4DbulkJctPotentialGiven)
                BSIM4DbulkJctPotential = BSIM4SbulkJctPotential;
            if (!BSIM4SsidewallJctPotentialGiven)
                BSIM4SsidewallJctPotential = 1.0;
            if (!BSIM4DsidewallJctPotentialGiven)
                BSIM4DsidewallJctPotential = BSIM4SsidewallJctPotential;
            if (!BSIM4SGatesidewallJctPotentialGiven)
                BSIM4SGatesidewallJctPotential = BSIM4SsidewallJctPotential;
            if (!BSIM4DGatesidewallJctPotentialGiven)
                BSIM4DGatesidewallJctPotential = BSIM4SGatesidewallJctPotential;
            if (!BSIM4SbulkJctBotGradingCoeffGiven)
                BSIM4SbulkJctBotGradingCoeff = 0.5;
            if (!BSIM4DbulkJctBotGradingCoeffGiven)
                BSIM4DbulkJctBotGradingCoeff = BSIM4SbulkJctBotGradingCoeff;
            if (!BSIM4SbulkJctSideGradingCoeffGiven)
                BSIM4SbulkJctSideGradingCoeff = 0.33;
            if (!BSIM4DbulkJctSideGradingCoeffGiven)
                BSIM4DbulkJctSideGradingCoeff = BSIM4SbulkJctSideGradingCoeff;
            if (!BSIM4SbulkJctGateSideGradingCoeffGiven)
                BSIM4SbulkJctGateSideGradingCoeff = BSIM4SbulkJctSideGradingCoeff;
            if (!BSIM4DbulkJctGateSideGradingCoeffGiven)
                BSIM4DbulkJctGateSideGradingCoeff = BSIM4SbulkJctGateSideGradingCoeff;
            if (!BSIM4SjctEmissionCoeffGiven)
                BSIM4SjctEmissionCoeff = 1.0;
            if (!BSIM4DjctEmissionCoeffGiven)
                BSIM4DjctEmissionCoeff = BSIM4SjctEmissionCoeff;
            if (!BSIM4SjctTempExponentGiven)
                BSIM4SjctTempExponent = 3.0;
            if (!BSIM4DjctTempExponentGiven)
                BSIM4DjctTempExponent = BSIM4SjctTempExponent;
    
            if (!BSIM4oxideTrapDensityAGiven) begin
                if (BSIM4type == `NMOS)
                   BSIM4oxideTrapDensityA = 6.25e41;
                else
                   BSIM4oxideTrapDensityA= 6.188e40;
            end 
            if (!BSIM4oxideTrapDensityBGiven) begin
                if (BSIM4type == `NMOS)
                   BSIM4oxideTrapDensityB = 3.125e26;
                else
                   BSIM4oxideTrapDensityB = 1.5e25;
            end 
            if (!BSIM4oxideTrapDensityCGiven)
                BSIM4oxideTrapDensityC = 8.75e9;
            if (!BSIM4emGiven)
                BSIM4em = 4.1e7; /* V/m */
            if (!BSIM4efGiven)
                BSIM4ef = 1.0;
            if (!BSIM4afGiven)
                BSIM4af = 1.0;
            if (!BSIM4kfGiven)
                BSIM4kf = 0.0;
    
            DMCGeff = BSIM4dmcg - BSIM4dmcgt;
            DMCIeff = BSIM4dmci;
            DMDGeff = BSIM4dmdg - BSIM4dmcgt;
    
            if (!BSIM4lGiven)
                BSIM4l = 5.0e-6;
            if (!BSIM4wGiven)
                BSIM4w = 5.0e-6;
            if (!BSIM4nfGiven)
                BSIM4nf = 1;
            if (!BSIM4minGiven)
                BSIM4min = 0; 
            if (!BSIM4icVDSGiven)
                BSIM4icVDS = 0.0;
            if (!BSIM4icVGSGiven)
                BSIM4icVGS = 0.0;
            if (!BSIM4icVBSGiven)
                BSIM4icVBS = 0.0;
            if (!BSIM4drainAreaGiven)
                BSIM4drainArea = 0.0;
            if (!BSIM4drainPerimeterGiven)
                BSIM4drainPerimeter = 0.0;
            if (!BSIM4drainSquaresGiven)
                BSIM4drainSquares = 1.0;
            if (!BSIM4sourceAreaGiven)
                BSIM4sourceArea = 0.0;
            if (!BSIM4sourcePerimeterGiven)
                BSIM4sourcePerimeter = 0.0;
            if (!BSIM4sourceSquaresGiven)
                BSIM4sourceSquares = 1.0;
    
            //        BSIM4.3
            if (!BSIM4lambdaGiven)
                BSIM4lambda = 0.0;
            if(!BSIM4llambdaGiven)
                BSIM4llambda = 0.0;
            if(!BSIM4wlambdaGiven)
                BSIM4wlambda = 0.0;
            if(!BSIM4plambdaGiven)
                BSIM4plambda = 0.0;
            if (!BSIM4vtlGiven)
                BSIM4vtl = 2.0e5;
            if (!BSIM4lvtlGiven)
                 BSIM4lvtl = 0.0;
            if (!BSIM4wvtlGiven)
                 BSIM4wvtl = 0.0;
            if (!BSIM4pvtlGiven)
                 BSIM4pvtl = 0.0;
            if (!BSIM4lcGiven)
                BSIM4lc = 5.0e-9;
            if (!BSIM4xnGiven)
                BSIM4xn = 3.0; 
            if (!BSIM4lxnGiven)
                BSIM4lxn = 0.4; 
            if (!BSIM4wxnGiven)
                BSIM4wxn = 0.0; 
            if (!BSIM4pxnGiven)
                BSIM4pxn = 0.0; 
            if (!BSIM4tempModGiven)
                BSIM4tempMod = 0;      
            if (!BSIM4saGiven)
                BSIM4sa = 0.0;
            if (!BSIM4sbGiven)
                BSIM4sb = 0.0;
            if (!BSIM4sdGiven)
                BSIM4sd = 2 * BSIM4dmcg;      
            if (!BSIM4sarefGiven)
                BSIM4saref = 1.0e-6;
            if (!BSIM4sbrefGiven)
                BSIM4sbref = 1.0e-6;      
            if (!BSIM4wlodGiven)
                BSIM4wlod = 0.0;      
            if (!BSIM4ku0Given)
                BSIM4ku0 = 0.0;
            if (!BSIM4lku0Given)
                 BSIM4lku0 = 0.0;
            if (!BSIM4kvsatGiven)
                BSIM4kvsat = 0.0;
            if (!BSIM4tku0Given)
                BSIM4tku0 = 0.0;  
            if (!BSIM4wku0Given)
                BSIM4wku0 = 0.0;
            if (!BSIM4pku0Given)
                BSIM4pku0 = 0.0;      
            if (!BSIM4llodku0Given)
                BSIM4llodku0 = 0.0;      
            if (!BSIM4wlodku0Given)
                BSIM4wlodku0 = 0.0;
            if (!BSIM4kvth0Given)
                BSIM4kvth0 = 0.0;
            if (!BSIM4lkvth0Given)
                BSIM4lkvth0 = 0.0;  
            if (!BSIM4wkvth0Given)
                BSIM4wkvth0 = 0.0;
            if (!BSIM4pkvth0Given)
                BSIM4pkvth0 = 0.0;      
            if (!BSIM4llodvthGiven)
                BSIM4llodvth = 0.0;      
            if (!BSIM4wlodvthGiven)
                BSIM4wlodvth = 0.0;
            if (!BSIM4stk2Given)
                BSIM4stk2 = 0.0;
            if (!BSIM4lodk2Given)
                BSIM4lodk2 = 1.0;
            if (!BSIM4steta0Given)
                BSIM4steta0 = 0.0;
            if (!BSIM4lodeta0Given)
                BSIM4lodeta0 = 1.0;      
            if (!BSIM4rnoiaGiven)
                BSIM4rnoia = 0.577; 
            if (!BSIM4rnoibGiven)
                BSIM4rnoib = 0.5164; 
            if (!BSIM4rnoicGiven)
                BSIM4rnoic = 0.395;
                 
            //New model version > 4.3 (mobmod, trap-assisted junction, wpemod) set default parms
            if(!BSIM4scGiven)
            	BSIM4sc = 0.0;                
            if(!BSIM4tvoffcvGiven)
            	BSIM4tvoffcv = 0.0;
            if(!BSIM4wtvoffcvGiven)
            	BSIM4wtvoffcv = 0.0;
            if(!BSIM4ltvoffcvGiven)
            	BSIM4ltvoffcv = 0.0;
            if(!BSIM4ptvoffcvGiven)
            	BSIM4ptvoffcv = 0.0;
            if(!BSIM4teta0Given)
            	BSIM4teta0 = 0.0;
            if(!BSIM4wteta0Given)
            	BSIM4wteta0 = 0.0;
            if(!BSIM4lteta0Given)
            	BSIM4lteta0 = 0.0;
            if(!BSIM4pteta0Given)
            	BSIM4pteta0 = 0.0;
                
            if(!BSIM4rbpdlGiven)
            	BSIM4rbpdl = 0.0;
            if(!BSIM4rbpdnfGiven)
            	BSIM4rbpdnf = 0.0;
            if(!BSIM4voffcvlGiven)
            	BSIM4voffcvl = 0.0;
                
            if(!BSIM4tnfactorGiven)
            	BSIM4tnfactor = 0.0;
            if(!BSIM4wtnfactorGiven)
            	BSIM4wtnfactor = 0.0;
            if(!BSIM4ltnfactorGiven)
            	BSIM4ltnfactor = 0.0;
            if(!BSIM4ptnfactorGiven)
            	BSIM4ptnfactor = 0.0;
            if(!BSIM4minvcvGiven)
            	BSIM4minvcv = 0.0;
            if(!BSIM4wminvcvGiven)
            	BSIM4wminvcv = 0.0;
            if(!BSIM4lminvcvGiven)
            	BSIM4lminvcv = 0.0;
            if(!BSIM4pminvcvGiven)
            	BSIM4pminvcv = 0.0;
            if(!BSIM4tvfbsdoffGiven)
            	BSIM4tvfbsdoff = 0.0;
            if(!BSIM4wtvfbsdoffGiven)
            	BSIM4wtvfbsdoff = 0.0;
            if(!BSIM4ltvfbsdoffGiven)
            	BSIM4ltvfbsdoff = 0.0;
            if(!BSIM4ptvfbsdoffGiven)
            	BSIM4ptvfbsdoff = 0.0;
                
            if(!BSIM4gidlModGiven)
            	BSIM4gidlMod = 0.0;
            //if(!BSIM4aigsGiven)
            //	BSIM4aigs = 0.0;
	    if (!BSIM4aigsdGiven && (BSIM4aigsGiven || BSIM4aigdGiven)) begin
	    if (!BSIM4laigsGiven)
                BSIM4laigs = 0.0;
            if (!BSIM4laigdGiven)
                BSIM4laigd = 0.0;
            end
            else begin
	    	if (!BSIM4laigsdGiven)
	    	    BSIM4laigsd = 0.0;
	    	BSIM4laigs = BSIM4laigsd;
	    	BSIM4laigd = BSIM4laigsd;
            end
                
            //if(!BSIM4bigsGiven)
            //	BSIM4bigs = 0.0;
            if(!BSIM4wbigsGiven)
            	BSIM4wbigs = 0.0;
            if(!BSIM4pbigsGiven)
            	BSIM4pbigs = 0.0;
            //if(!BSIM4cigsGiven)
            //	BSIM4cigs = 0.0;
            if(!BSIM4wcigsGiven)
            	BSIM4wcigs = 0.0;
            if(!BSIM4pcigsGiven)
            	BSIM4pcigs = 0.0;
            //if(!BSIM4aigdGiven)
            //	BSIM4aigd = 0.0;
	    if (!BSIM4aigsdGiven && (BSIM4aigsGiven || BSIM4aigdGiven)) begin
              if (!BSIM4waigsGiven)
                  BSIM4waigs = 0.0;
              if (!BSIM4waigdGiven)
                  BSIM4waigd = 0.0;
            end
            else begin
	      if (!BSIM4waigsdGiven)
	      	BSIM4waigsd = 0.0;
	      BSIM4waigs = BSIM4waigsd;
	      BSIM4waigd = BSIM4waigsd;
            end
	    if (!BSIM4bigsdGiven && (BSIM4bigsGiven || BSIM4bigdGiven)) begin
                if (!BSIM4wbigsGiven)
                    BSIM4wbigs = 0.0;
                if (!BSIM4wbigdGiven)
                    BSIM4wbigd = 0.0;
            end
            else begin
	    	if (!BSIM4wbigsdGiven)
	    	  BSIM4wbigsd = 0.0;
	    	BSIM4wbigs = BSIM4wbigsd;
	    	BSIM4wbigd = BSIM4wbigsd;
            end
	    if (!BSIM4cigsdGiven && (BSIM4cigsGiven || BSIM4cigdGiven)) begin
                if (!BSIM4wcigsGiven)
                    BSIM4wcigs = 0.0;
                if (!BSIM4wcigdGiven)
                    BSIM4wcigd = 0.0;
            end
            else begin
	      if (!BSIM4wcigsdGiven)
		  BSIM4wcigsd = 0.0;
	      BSIM4wcigs = BSIM4wcigsd;
	      BSIM4wcigd = BSIM4wcigsd;
            end
                
            //if(!BSIM4bigdGiven)
            //	BSIM4bigd = 0.0;
            if(!BSIM4wbigdGiven)
            	BSIM4wbigd = 0.0;
	    if (!BSIM4bigsdGiven && (BSIM4bigsGiven || BSIM4bigdGiven)) begin
            if (!BSIM4lbigsGiven)
                BSIM4lbigs = 0.0;
            if (!BSIM4lbigdGiven)
                BSIM4lbigd = 0.0;
        end
        else begin
	  if (!BSIM4lbigsdGiven)
		BSIM4lbigsd = 0.0;
	  BSIM4lbigs = BSIM4lbigsd;
	  BSIM4lbigd = BSIM4lbigsd;
        end
                
            if(!BSIM4pbigdGiven)
            	BSIM4pbigd = 0.0;
            //if(!BSIM4cigdGiven)
            //	BSIM4cigd = 0.0;
            if(!BSIM4wcigdGiven)
            	BSIM4wcigd = 0.0;
            if(!BSIM4pcigdGiven)
            	BSIM4pcigd = 0.0;
	    if (!BSIM4cigsdGiven && (BSIM4cigsGiven || BSIM4cigdGiven)) begin
            if (!BSIM4lcigsGiven)
                BSIM4lcigs = 0.0;
            if (!BSIM4lcigdGiven)
                BSIM4lcigd = 0.0;
            end
            else begin
	      if (!BSIM4lcigsdGiven)
	      	BSIM4lcigsd = 0.0;
	      BSIM4lcigs = BSIM4lcigsd;
	      BSIM4lcigd = BSIM4lcigsd;
            end
	    if (!BSIM4aigsdGiven && (BSIM4aigsGiven || BSIM4aigdGiven)) begin
                if (!BSIM4paigsGiven)
                    BSIM4paigs = 0.0;
                if (!BSIM4paigdGiven)
                    BSIM4paigd = 0.0;
            end
            else begin
	    	if (!BSIM4paigsdGiven)
	    	  BSIM4paigsd = 0.0;
	    	BSIM4paigs = BSIM4paigsd;
	    	BSIM4paigd = BSIM4paigsd;
            end
	    	if (!BSIM4bigsdGiven && (BSIM4bigsGiven || BSIM4bigdGiven)) begin
                if (!BSIM4pbigsGiven)
                    BSIM4pbigs = 0.0;
                if (!BSIM4pbigdGiven)
                    BSIM4pbigd = 0.0;
            end
            else begin
	    	if (!BSIM4pbigsdGiven)
	    		BSIM4pbigsd = 0.0;
	    	BSIM4pbigs = BSIM4pbigsd;
	    	BSIM4pbigd = BSIM4pbigsd;
            end
	    if (!BSIM4cigsdGiven && (BSIM4cigsGiven || BSIM4cigdGiven)) begin
                if (!BSIM4pcigsGiven)
                    BSIM4pcigs = 0.0;
                if (!BSIM4pcigdGiven)
                    BSIM4pcigd = 0.0;
            end
            else begin
	    	if (!BSIM4pcigsdGiven)
	    		BSIM4pcigsd = 0.0;
	    	BSIM4pcigs = BSIM4pcigsd;
	    	BSIM4pcigd = BSIM4pcigsd;
            end
            
            if(!BSIM4delvtoGiven)
            	BSIM4delvto = 0.0;
            if(!BSIM4adosGiven)
            	BSIM4ados = 1.0;
            if(!BSIM4bdosGiven)
            	BSIM4bdos = 1.0;

            if(!BSIM4rgidlGiven)
            	BSIM4rgidl = 1.0;
            if(!BSIM4wrgidlGiven)
            	BSIM4wrgidl = 0.0;
            if(!BSIM4lrgidlGiven)
            	BSIM4lrgidl = 0.0;
            if(!BSIM4prgidlGiven)
            	BSIM4prgidl = 0.0;
            if(!BSIM4kgidlGiven)
            	BSIM4kgidl = 0.0;
            if(!BSIM4wkgidlGiven)
            	BSIM4wkgidl = 0.0;
            if(!BSIM4lkgidlGiven)
            	BSIM4lkgidl = 0.0;
            if(!BSIM4pkgidlGiven)
            	BSIM4pkgidl = 0.0;
            if(!BSIM4fgidlGiven)
            	BSIM4fgidl = 1.0;
            if(!BSIM4wfgidlGiven)
            	BSIM4wfgidl = 0.0;
            if(!BSIM4lfgidlGiven)
            	BSIM4lfgidl = 0.0;
            if(!BSIM4pfgidlGiven)
            	BSIM4pfgidl = 0.0;
               
            if(!BSIM4agislGiven)
            	BSIM4agisl = BSIM4agidl;
            if(!BSIM4wagislGiven)
            	BSIM4wagisl = BSIM4wagidl;
            if(!BSIM4lagislGiven)
            	BSIM4lagisl = BSIM4lagidl;
            if(!BSIM4pagislGiven)
            	BSIM4pagisl = BSIM4pagidl;
            if(!BSIM4bgislGiven)
            	BSIM4bgisl = BSIM4bgidl;
            if(!BSIM4wbgislGiven)
            	BSIM4wbgisl = BSIM4wbgidl;
            if(!BSIM4lbgislGiven)
            	BSIM4lbgisl = BSIM4lbgidl;
            if(!BSIM4pbgislGiven)
            	BSIM4pbgisl = BSIM4pbgidl;
            if(!BSIM4cgislGiven)
            	BSIM4cgisl = BSIM4cgidl;
            if(!BSIM4wcgislGiven)
            	BSIM4wcgisl = BSIM4wcgidl;
            if(!BSIM4lcgislGiven)
            	BSIM4lcgisl = BSIM4lcgidl;
            if(!BSIM4pcgislGiven)
            	BSIM4pcgisl = BSIM4pcgidl;
            if(!BSIM4egislGiven)
            	BSIM4egisl = BSIM4egidl;
            if(!BSIM4wegislGiven)
            	BSIM4wegisl = BSIM4wegidl;
            if(!BSIM4legislGiven)
            	BSIM4legisl = BSIM4legidl;
            if(!BSIM4pegislGiven)
            	BSIM4pegisl = BSIM4pegidl;
            if(!BSIM4rgislGiven)
            	BSIM4rgisl = BSIM4rgidl;
            if(!BSIM4wrgislGiven)
            	BSIM4wrgisl = BSIM4wrgidl;
            if(!BSIM4lrgislGiven)
            	BSIM4lrgisl = BSIM4lrgidl;
            if(!BSIM4prgislGiven)
            	BSIM4prgisl = BSIM4prgidl;
            if(!BSIM4kgislGiven)
            	BSIM4kgisl = BSIM4kgidl;
            if(!BSIM4wkgislGiven)
            	BSIM4wkgisl = BSIM4wkgidl;
            if(!BSIM4lkgislGiven)
            	BSIM4lkgisl = BSIM4lkgidl;
            if(!BSIM4pkgislGiven)
            	BSIM4pkgisl = BSIM4pkgidl;
            if(!BSIM4fgislGiven)
            	BSIM4fgisl = BSIM4fgidl;
            if(!BSIM4wfgislGiven)
            	BSIM4wfgisl = BSIM4wfgidl;
            if(!BSIM4lfgislGiven)
            	BSIM4lfgisl = BSIM4lfgidl;
            if(!BSIM4pfgislGiven)
            	BSIM4pfgisl = BSIM4pfgidl;
                
            if(!BSIM4cvchargeModGiven)
            	BSIM4cvchargeMod = 0.0;
            if(!BSIM4dvtp2Given)
            	BSIM4dvtp2 = 0.0;
            if(!BSIM4wdvtp2Given)
            	BSIM4wdvtp2 = 0.0;
            if(!BSIM4ldvtp2Given)
            	BSIM4ldvtp2 = 0.0;
            if(!BSIM4pdvtp2Given)
            	BSIM4pdvtp2 = 0.0;
            if(!BSIM4dvtp3Given)
            	BSIM4dvtp3 = 0.0;
            if(!BSIM4wdvtp3Given)
            	BSIM4wdvtp3 = 0.0;
            if(!BSIM4ldvtp3Given)
            	BSIM4ldvtp3 = 0.0;
            if(!BSIM4pdvtp3Given)
            	BSIM4pdvtp3 = 0.0;
            if(!BSIM4dvtp4Given)
            	BSIM4dvtp4 = 0.0;
            if(!BSIM4wdvtp4Given)
            	BSIM4wdvtp4 = 0.0;
            if(!BSIM4ldvtp4Given)
            	BSIM4ldvtp4 = 0.0;
            if(!BSIM4pdvtp4Given)
            	BSIM4pdvtp4 = 0.0;
            if(!BSIM4dvtp5Given)
            	BSIM4dvtp5 = 0.0;
            if(!BSIM4wdvtp5Given)
            	BSIM4wdvtp5 = 0.0;
            if(!BSIM4ldvtp5Given)
            	BSIM4ldvtp5 = 0.0;
            if(!BSIM4pdvtp5Given)
            	BSIM4pdvtp5 = 0.0;
                
            if(!BSIM4ni0subGiven)
            	BSIM4ni0sub = 1.45e10;
            if(!BSIM4bg0subGiven)
            	BSIM4bg0sub = 1.16;
            if(!BSIM4tbgasubGiven)
            	BSIM4tbgasub = 7.02e-4;
            if(!BSIM4tbgbsubGiven)
            	BSIM4tbgbsub = 1108.0;
            if(!BSIM4tempeotGiven)
            	BSIM4tempeot = 300.15;
            if(!BSIM4leffeotGiven)
            	BSIM4leffeot = 1.0;
            if(!BSIM4weffeotGiven)
            	BSIM4weffeot = 10.0;
            if(!BSIM4vddeotGiven)
            	BSIM4vddeot = (BSIM4type == `NMOS) ? 1.5 : -1.5;
            if(!BSIM4eotGiven)
            	BSIM4eot = 15.0e-10;
            if(!BSIM4epsrgateGiven)
            	BSIM4epsrgate = 11.7;
                
            if(!BSIM4epsrsubGiven)
            	BSIM4epsrsub = 11.7;
            if(!BSIM4phigGiven)
            	BSIM4phig = 4.05;
            if(!BSIM4easubGiven)
            	BSIM4easub = 4.05;
            if (!BSIM4mtrlmodGiven)   
                BSIM4mtrlmod = 0;
	    else if((BSIM4mtrlmod != 0) && (BSIM4mtrlmod != 1)) begin
	        BSIM4mtrlmod = 0;
	        $strobe("Warning: mtrlMod has been set to its default value: 0.\n");
	    end
            if (!BSIM4mtrlcompatmodGiven)   
                BSIM4mtrlcompatmod = 0;
	    else if((BSIM4mtrlcompatmod != 0) && (BSIM4mtrlcompatmod != 1)) begin
	        BSIM4mtrlcompatmod = 0;
	        $strobe("Warning: mtrlCompatMod has been set to its default value: 0.\n");
	    end               
            if(!BSIM4udGiven)
            	BSIM4ud = 0.0;
            if(!BSIM4wudGiven)
            	BSIM4wud = 0.0;
            if(!BSIM4ludGiven)
            	BSIM4lud = 0.0;
            if(!BSIM4pudGiven)
            	BSIM4pud = 0.0;
            if(!BSIM4ud1Given)
            	BSIM4ud1 = 0.0;
            if(!BSIM4wud1Given)
            	BSIM4wud1 = 0.0;
            if(!BSIM4lud1Given)
            	BSIM4lud1 = 0.0;
            if(!BSIM4pud1Given)
            	BSIM4pud1 = 0.0;
            if(!BSIM4upGiven)
            	BSIM4up = 0.0;
            if(!BSIM4wupGiven)
            	BSIM4wup = 0.0;
            if(!BSIM4lupGiven)
            	BSIM4lup = 0.0;
            if(!BSIM4pupGiven)
            	BSIM4pup = 0.0;
            if(!BSIM4lpGiven)
            	BSIM4lp = 1.0e-8;
            if(!BSIM4wlpGiven)
            	BSIM4wlp = 0.0;
            if(!BSIM4llpGiven)
            	BSIM4llp = 0.0;
            if(!BSIM4plpGiven)
            	BSIM4plp = 0.0;
            if(!BSIM4ucsGiven)
                BSIM4ucs = (BSIM4type == `NMOS) ? 1.67 : 1.0;
            if(!BSIM4wucsGiven)
            	BSIM4wucs = 0.0;
            if(!BSIM4lucsGiven)
            	BSIM4lucs = 0.0;
            if(!BSIM4pucsGiven)
            	BSIM4pucs = 0.0;
            if(!BSIM4ucsteGiven)
                BSIM4ucste = -4.775e-3;
            if(!BSIM4wucsteGiven)
            	BSIM4wucste = 0.0;
            if(!BSIM4lucsteGiven)
            	BSIM4lucste = 0.0;
            if(!BSIM4pucsteGiven)
            	BSIM4pucste = 0.0;
            if(!BSIM4kvth0weGiven)
            	BSIM4kvth0we = 0.0;
            if(!BSIM4wkvth0weGiven)
            	BSIM4wkvth0we = 0.0;
            if(!BSIM4lkvth0weGiven)
            	BSIM4lkvth0we = 0.0;
            if(!BSIM4pkvth0weGiven)
            	BSIM4pkvth0we = 0.0;
            if(!BSIM4k2weGiven)
            	BSIM4k2we = 0.0;
            if(!BSIM4wk2weGiven)
            	BSIM4wk2we = 0.0;
            if(!BSIM4lk2weGiven)
            	BSIM4lk2we = 0.0;
            if(!BSIM4pk2weGiven)
            	BSIM4pk2we = 0.0;
            if(!BSIM4ku0weGiven)
            	BSIM4ku0we = 0.0;
            if(!BSIM4wku0weGiven)
            	BSIM4wku0we = 0.0;
            if(!BSIM4lku0weGiven)
            	BSIM4lku0we = 0.0;
            if(!BSIM4pku0weGiven)
            	BSIM4pku0we = 0.0;
            if(!BSIM4vfbsdoffGiven)
            	BSIM4vfbsdoff = 0.0;
            if(!BSIM4wvfbsdoffGiven)
            	BSIM4wvfbsdoff = 0.0;
            if(!BSIM4lvfbsdoffGiven)
            	BSIM4lvfbsdoff = 0.0;
            if(!BSIM4pvfbsdoffGiven)
            	BSIM4pvfbsdoff = 0.0;
            if(!BSIM4tvoffGiven)
            	BSIM4tvoff = 0.0;
            if(!BSIM4wtvoffGiven)
            	BSIM4wtvoff = 0.0;
            if(!BSIM4ltvoffGiven)
            	BSIM4ltvoff = 0.0;
            if(!BSIM4ptvoffGiven)
            	BSIM4ptvoff = 0.0;
            if(!BSIM4wpemodGiven)
            	BSIM4wpemod = 0.0;
            else if ((BSIM4wpemod != 0) && (BSIM4wpemod != 1)) begin
              BSIM4wpemod = 0;
              $strobe("Warning: wpemod has been set to its default value: 0.\n");
            end
                
            if(!BSIM4scaGiven)
            	BSIM4sca = 0.0;
            if(!BSIM4scbGiven)
            	BSIM4scb = 0.0;
            if(!BSIM4sccGiven)
            	BSIM4scc = 0.0;
            if(!BSIM4webGiven)
            	BSIM4web = 0.0;
            if(!BSIM4wecGiven)
            	BSIM4wec = 0.0;
            if(!BSIM4screfGiven)
            	BSIM4scref = 1.0E-6;
            if(!BSIM4rbps0Given)
            	BSIM4rbps0 = 50.0;
            if(!BSIM4rbpslGiven)
            	BSIM4rbpsl = 0.0;
            if(!BSIM4rbpswGiven)
            	BSIM4rbpsw = 0.0;
            if(!BSIM4rbpsnfGiven)
            	BSIM4rbpsnf = 0.0;
            if(!BSIM4rbpd0Given)
            	BSIM4rbpd0 = 50.0;
            if(!BSIM4rbpdwGiven)
            	BSIM4rbpdw = 0.0;
            if(!BSIM4rbpbx0Given)
            	BSIM4rbpbx0 = 100.0;
            if(!BSIM4rbpbxlGiven)
            	BSIM4rbpbxl = 0.0;
            if(!BSIM4rbpbxwGiven)
            	BSIM4rbpbxw = 0.0;
            if(!BSIM4rbpbxnfGiven)
            	BSIM4rbpbxnf = 0.0;
            if(!BSIM4rbpby0Given)
            	BSIM4rbpby0 = 100.0;
            if(!BSIM4rbpbylGiven)
            	BSIM4rbpbyl = 0.0;
            if(!BSIM4rbpbywGiven)
            	BSIM4rbpbyw = 0.0;
            if(!BSIM4rbpbynfGiven)
            	BSIM4rbpbynf = 0.0;
            if(!BSIM4rbsbx0Given)
            	BSIM4rbsbx0 = 100.0;
            if(!BSIM4rbsby0Given)
            	BSIM4rbsby0 = 100.0;
            if(!BSIM4rbdbx0Given)
            	BSIM4rbdbx0 = 100.0;
            if(!BSIM4rbdby0Given)
            	BSIM4rbdby0 = 100.0;
            if(!BSIM4rbsdbxlGiven)
            	BSIM4rbsdbxl = 0.0;
            if(!BSIM4rbsdbxwGiven)
            	BSIM4rbsdbxw = 0.0;
            if(!BSIM4rbsdbxnfGiven)
            	BSIM4rbsdbxnf = 0.0;
            if(!BSIM4rbsdbylGiven)
            	BSIM4rbsdbyl = 0.0;
            if(!BSIM4rbsdbywGiven)
            	BSIM4rbsdbyw = 0.0;
            if(!BSIM4rbsdbynfGiven)
            	BSIM4rbsdbynf = 0.0;
            if(!BSIM4jtssGiven)
            	BSIM4jtss = 0.0;
            if(!BSIM4jtsswsGiven)
            	BSIM4jtssws = 0.0;
            if(!BSIM4jtsswgsGiven)
            	BSIM4jtsswgs = 0.0;
            if(!BSIM4jtweffGiven)
            	BSIM4jtweff = 0.0;
            if(!BSIM4njtsGiven)
            	BSIM4njts = 20.0;
            if(!BSIM4njtsswGiven)
            	BSIM4njtssw = 20.0;
            if(!BSIM4njtsswgGiven)
            	BSIM4njtsswg = 20.0;
            if(!BSIM4xtssGiven)
            	BSIM4xtss = 0.02;
            if(!BSIM4xtsswsGiven)
            	BSIM4xtssws = 0.02;
            if(!BSIM4xtsswgsGiven)
            	BSIM4xtsswgs = 0.02;
            if(!BSIM4vtssGiven)
            	BSIM4vtss = 10.0;
            if(!BSIM4vtsswsGiven)
            	BSIM4vtssws = 10.0;
            if(!BSIM4vtsswgsGiven)
            	BSIM4vtsswgs = 10.0;
            if(!BSIM4tnjtsGiven)
            	BSIM4tnjts = 0.0;
            if(!BSIM4tnjtsswGiven)
            	BSIM4tnjtssw = 0.0;
            if(!BSIM4tnjtsswgGiven)
            	BSIM4tnjtsswg = 0.0;
            if(!BSIM4jtsdGiven)
            	BSIM4jtsd = BSIM4jtss;
            if(!BSIM4jtsswdGiven)
            	BSIM4jtsswd = BSIM4jtssws;
            if(!BSIM4jtsswgdGiven)
            	BSIM4jtsswgd = BSIM4jtsswgs;
            if(!BSIM4njtsdGiven) begin
	      if (BSIM4njtsGiven)
                BSIM4njtsd =  BSIM4njts;
	      else
		BSIM4njtsd = 20.0;
            end
            if(!BSIM4njtsswdGiven) begin
	      if (BSIM4njtsswGiven)
		BSIM4njtsswd =  BSIM4njtssw;
	      else
		BSIM4njtsswd = 20.0;
            end
            if(!BSIM4njtsswgdGiven) begin
	      if (BSIM4njtsswgGiven)
		  BSIM4njtsswgd =  BSIM4njtsswg;
	      else
		  BSIM4njtsswgd = 20.0;
            end
            if(!BSIM4xtsdGiven)
            	BSIM4xtsd = BSIM4xtss;
            if(!BSIM4xtsswdGiven)
            	BSIM4xtsswd = BSIM4xtssws;
            if(!BSIM4xtsswgdGiven)
            	BSIM4xtsswgd = BSIM4xtsswgs;
            if(!BSIM4vtsdGiven)
            	BSIM4vtsd = BSIM4vtss;
            if(!BSIM4vtsswdGiven)
            	BSIM4vtsswd = BSIM4vtssws;
            if(!BSIM4vtsswgdGiven)
            	BSIM4vtsswgd = BSIM4vtsswgs;
            if(!BSIM4tnjtsdGiven) begin
	      if (BSIM4tnjtsGiven)
		BSIM4tnjtsd =  BSIM4tnjts;
	      else
		BSIM4tnjtsd = 0.0;            
            end
            if(!BSIM4tnjtsswdGiven) begin
	      if (BSIM4tnjtsswGiven)
		BSIM4tnjtsswd =  BSIM4tnjtssw;
	      else
		BSIM4tnjtsswd = 0.0;            
            end
            if(!BSIM4tnjtsswgdGiven) begin
              if (BSIM4tnjtsswgGiven)
		BSIM4tnjtsswgd =  BSIM4tnjtsswg;
	      else
		BSIM4tnjtsswgd = 0.0;
            end

            /* process drain series resistance - removed useless code*/
            //if (BSIM4sheetResistance > 0) begin
            //    if (!BSIM4drainSquaresGiven && (BSIM4rgeoMod != 0)) 
            //      `BSIM4RdseffGeo(BSIM4nf, BSIM4geoMod, BSIM4rgeoMod, BSIM4min,
            //        BSIM4w, BSIM4sheetResistance, DMCGeff, DMCIeff, DMDGeff, 0, Rtot)
            //end 
    
            ///* process source series resistance */
            //if (BSIM4sheetResistance > 0) begin
            //    if (!BSIM4sourceSquaresGiven && (BSIM4rgeoMod != 0)) 
            //       `BSIM4RdseffGeo(BSIM4nf, BSIM4geoMod, BSIM4rgeoMod, BSIM4min,
            //         BSIM4w, BSIM4sheetResistance, DMCGeff, DMCIeff, DMDGeff, 1, Rtot)
            //end
                  
            if (BSIM4SbulkJctPotential < 0.1)  begin
                BSIM4SbulkJctPotential = 0.1;
                $strobe("Given pbs is less than 0.1. Pbs is set to 0.1.\n");
            end 
            if (BSIM4SsidewallJctPotential < 0.1) begin
                BSIM4SsidewallJctPotential = 0.1;
                $strobe("Given pbsws is less than 0.1. Pbsws is set to 0.1.\n");
            end 
            if (BSIM4SGatesidewallJctPotential < 0.1) begin
                BSIM4SGatesidewallJctPotential = 0.1;
                $strobe("Given pbswgs is less than 0.1. Pbswgs is set to 0.1.\n");
            end 
    
            if (BSIM4DbulkJctPotential < 0.1) begin
                BSIM4DbulkJctPotential = 0.1;
                $strobe("Given pbd is less than 0.1. Pbd is set to 0.1.\n");
            end 
            if (BSIM4DsidewallJctPotential < 0.1) begin
                BSIM4DsidewallJctPotential = 0.1;
                $strobe("Given pbswd is less than 0.1. Pbswd is set to 0.1.\n");
            end 
    
            if (BSIM4DGatesidewallJctPotential < 0.1) begin
                BSIM4DGatesidewallJctPotential = 0.1;
                $strobe("Given pbswgd is less than 0.1. Pbswgd is set to 0.1.\n");
            end 
    
            //New model version > 4.3
	    if(BSIM4mtrlmod == 0) begin
	        if ((BSIM4toxeGiven) && (BSIM4toxpGiven) && (BSIM4dtoxGiven)
	            && (BSIM4toxe != (BSIM4toxp + BSIM4dtox))) begin
                    if (BSIM4toxe == 0.0)
         	      $strobe("Warning: toxe, toxp and dtox all given and toxe != toxp + dtox; dtox ignored.");
                    else if (abs((BSIM4toxe - (BSIM4toxp + BSIM4dtox)) / BSIM4toxe) >= 1e-15)
         	      $strobe("Warning: toxe, toxp and dtox all given and toxe != toxp + dtox; dtox ignored.");
                end                    
	        else if ((BSIM4toxeGiven) && (!BSIM4toxpGiven))
	          BSIM4toxp = BSIM4toxe - BSIM4dtox;
	        else if ((!BSIM4toxeGiven) && (BSIM4toxpGiven)) begin
	          BSIM4toxe = BSIM4toxp + BSIM4dtox;
	            if (!BSIM4toxmGiven)			/* v4.7 */
	                BSIM4toxm = BSIM4toxe;		
	        end
	    end
	    else if(BSIM4mtrlcompatmod != 0) /* v4.7 */
	    begin
	        T0 = BSIM4epsrox / 3.9;
	        if ((BSIM4eotGiven) && (BSIM4toxpGiven) && (BSIM4dtoxGiven)
	            && (abs(BSIM4eot * T0 - (BSIM4toxp + BSIM4dtox)) > 1.0e-20))
	            $strobe("Warning: eot, toxp and dtox all given and eot * EPSROX / 3.9 != toxp + dtox; dtox ignored.\n");
	        else if ((BSIM4eotGiven) && (!BSIM4toxpGiven))
	          BSIM4toxp = T0 * BSIM4eot - BSIM4dtox;
	        else if ((!BSIM4eotGiven) && (BSIM4toxpGiven)) begin
	          BSIM4eot = (BSIM4toxp + BSIM4dtox) / T0;
	            if (!BSIM4toxmGiven)
	                BSIM4toxm = BSIM4eot;
	        end
	    end

	    if(BSIM4mtrlmod)
	      begin
	        epsroxl = 3.9;
	        toxel = BSIM4eot;
	        epssubl = `EPS0 * BSIM4epsrsub;
	      end
	    else
	      begin
	        epsroxl = BSIM4epsrox;
	        toxel = BSIM4toxe;
	        epssubl = `EPSSI;
	      end

            BSIM4coxe = epsroxl * `EPS0 / toxel;
	    if(BSIM4mtrlmod == 0 || BSIM4mtrlcompatmod != 0)
	      BSIM4coxp = BSIM4epsrox * `EPS0 / BSIM4toxp;

            if (!BSIM4cgdoGiven) begin
                if (BSIM4dlcGiven && (BSIM4dlc > 0.0))
                    BSIM4cgdo = BSIM4dlc * BSIM4coxe - BSIM4cgdl;
                else
                    BSIM4cgdo = 0.6 * BSIM4xj * BSIM4coxe;
            end 
    
            if (!BSIM4cgsoGiven) begin
                if (BSIM4dlcGiven && (BSIM4dlc > 0.0))
                    BSIM4cgso = BSIM4dlc * BSIM4coxe - BSIM4cgsl;
                else
                    BSIM4cgso = 0.6 * BSIM4xj * BSIM4coxe;
            end 
    
            if (!BSIM4cgboGiven)
                BSIM4cgbo = 2.0 * BSIM4dwc * BSIM4coxe;
    
            Tnom = BSIM4tnom;
            TRatio = T / Tnom;
            //remove dead code
            //BSIM4vcrit = CONSTvt0 * ln(CONSTvt0 / (CONSTroot2 * 1.0e-14));
            BSIM4factor1 = sqrt(epssubl / (epsroxl * `EPS0)* toxel);
    
            Vtm0 = `KboQ * Tnom;
            if(BSIM4mtrlmod==0) begin
              Eg0 = 1.16 - 7.02e-4 * Tnom * Tnom / (Tnom + 1108.0);
              ni = 1.45e10 * (Tnom / 300.15) * sqrt(Tnom / 300.15) 
                  * exp(21.5565981 - Eg0 / (2.0 * Vtm0));
            end
            else begin
	      Eg0 = BSIM4bg0sub - BSIM4tbgasub * Tnom * Tnom 
                                         / (Tnom + BSIM4tbgbsub);
	      T0 =  BSIM4bg0sub - BSIM4tbgasub * 90090.0225  
                                         / (300.15 + BSIM4tbgbsub);
	      ni = BSIM4ni0sub * (Tnom / 300.15) * sqrt(Tnom / 300.15) 
                    * exp((T0 - Eg0) / (2.0 * Vtm0));
            end
   
            BSIM4Eg0 = Eg0;
            BSIM4vtm = `KboQ * T;
            if (BSIM4mtrlmod == 0)
              Eg = 1.16 - 7.02e-4 * T * T / (T + 1108.0);
	    else
	      Eg = BSIM4bg0sub - BSIM4tbgasub * T * T 
                                      / (T + BSIM4tbgbsub);    
            if (T != Tnom) begin
                T0 = Eg0 / Vtm0 - Eg / BSIM4vtm;
                T1 = ln(T / Tnom);
                T2 = T0 + BSIM4SjctTempExponent * T1;
                T3 = exp(T2 / BSIM4SjctEmissionCoeff);
                BSIM4SjctTempSatCurDensity = BSIM4SjctSatCurDensity * T3;
                BSIM4SjctSidewallTempSatCurDensity
                  = BSIM4SjctSidewallSatCurDensity * T3;
                BSIM4SjctGateSidewallTempSatCurDensity
                  = BSIM4SjctGateSidewallSatCurDensity * T3;
    
                T2 = T0 + BSIM4DjctTempExponent * T1;
                T3 = exp(T2 / BSIM4DjctEmissionCoeff);
                BSIM4DjctTempSatCurDensity = BSIM4DjctSatCurDensity * T3;
                BSIM4DjctSidewallTempSatCurDensity
                  = BSIM4DjctSidewallSatCurDensity * T3;
                BSIM4DjctGateSidewallTempSatCurDensity
                  = BSIM4DjctGateSidewallSatCurDensity * T3;
            end 
            else begin
                BSIM4SjctTempSatCurDensity = BSIM4SjctSatCurDensity;
                BSIM4SjctSidewallTempSatCurDensity
                  = BSIM4SjctSidewallSatCurDensity;
                BSIM4SjctGateSidewallTempSatCurDensity
                  = BSIM4SjctGateSidewallSatCurDensity;
                BSIM4DjctTempSatCurDensity = BSIM4DjctSatCurDensity;
                BSIM4DjctSidewallTempSatCurDensity
                  = BSIM4DjctSidewallSatCurDensity;
                BSIM4DjctGateSidewallTempSatCurDensity 
                  = BSIM4DjctGateSidewallSatCurDensity;
            end
    
            if (BSIM4SjctTempSatCurDensity < 0.0)
                BSIM4SjctTempSatCurDensity = 0.0;
            if (BSIM4SjctSidewallTempSatCurDensity < 0.0)
                BSIM4SjctSidewallTempSatCurDensity = 0.0;
            if (BSIM4SjctGateSidewallTempSatCurDensity < 0.0)
                BSIM4SjctGateSidewallTempSatCurDensity = 0.0;
    
            if (BSIM4DjctTempSatCurDensity < 0.0)
                BSIM4DjctTempSatCurDensity = 0.0;
            if (BSIM4DjctSidewallTempSatCurDensity < 0.0)
                BSIM4DjctSidewallTempSatCurDensity = 0.0;
            if (BSIM4DjctGateSidewallTempSatCurDensity < 0.0)
                BSIM4DjctGateSidewallTempSatCurDensity = 0.0;
    
            /* Temperature dependence of D/B and S/B diode capacitance begins */
            delTemp = T - Tnom; // - BSIM4tnom;
            
            T0 = BSIM4tcj * delTemp;
            if (T0 >= -1.0) begin
                BSIM4SunitAreaTempJctCap = BSIM4SunitAreaJctCap *(1.0 + T0); 
                BSIM4DunitAreaTempJctCap = BSIM4DunitAreaJctCap *(1.0 + T0);
            end 
            else begin
                if (BSIM4SunitAreaJctCap > 0.0) begin
                    BSIM4SunitAreaTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjs to be negative. \
                             Cjs is clamped to zero.\n");
                end 
                if (BSIM4DunitAreaJctCap > 0.0) begin
                    BSIM4DunitAreaTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjd to be negative. \
                             Cjd is clamped to zero.\n");
                end 
            end 
            T0 = BSIM4tcjsw * delTemp;
    
            if (T0 >= -1.0) begin
                BSIM4SunitLengthSidewallTempJctCap = BSIM4SunitLengthSidewallJctCap 
                                                      * (1.0 + T0);
                BSIM4DunitLengthSidewallTempJctCap = BSIM4DunitLengthSidewallJctCap 
                                                      * (1.0 + T0);
            end 
            else begin
                if (BSIM4SunitLengthSidewallJctCap > 0.0) begin
                    BSIM4SunitLengthSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjsws to be negative. \
                             Cjsws is clamped to zero.\n");
                end
    
                if (BSIM4DunitLengthSidewallJctCap > 0.0) begin
                    BSIM4DunitLengthSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjswd to be negative. \
                             Cjswd is clamped to zero.\n");
                end     
            end 
                
            T0 = BSIM4tcjswg * delTemp;
            if (T0 >= -1.0) begin
                BSIM4SunitLengthGateSidewallTempJctCap = 
                    BSIM4SunitLengthGateSidewallJctCap *(1.0 + T0);
                BSIM4DunitLengthGateSidewallTempJctCap = 
                    BSIM4DunitLengthGateSidewallJctCap *(1.0 + T0);
            end 
            else begin
                if (BSIM4SunitLengthGateSidewallJctCap > 0.0) begin
                    BSIM4SunitLengthGateSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjswgs to be negative. \
                             Cjswgs is clamped to zero.\n");
                end 
                if (BSIM4DunitLengthGateSidewallJctCap > 0.0) begin
                    BSIM4DunitLengthGateSidewallTempJctCap = 0.0;
                    $strobe("Temperature effect has caused cjswgd to be negative. \
                             Cjswgd is clamped to zero.\n");
                end 
            end
    
            BSIM4PhiBS = BSIM4SbulkJctPotential - BSIM4tpb * delTemp;
            if (BSIM4PhiBS < 0.01) begin
                BSIM4PhiBS = 0.01;
                $strobe("Temperature effect has caused pbs to be less than 0.01. \
                         Pbs is clamped to 0.01.\n");
            end 
            BSIM4PhiBD = BSIM4DbulkJctPotential - BSIM4tpb * delTemp;
            if (BSIM4PhiBD < 0.01) begin
                BSIM4PhiBD = 0.01;
                $strobe("Temperature effect has caused pbd to be less than 0.01. \
                         Pbd is clamped to 0.01.\n");
            end
    
            BSIM4PhiBSWS = BSIM4SsidewallJctPotential - BSIM4tpbsw * delTemp;
            if (BSIM4PhiBSWS <= 0.01) begin
                BSIM4PhiBSWS = 0.01;
                $strobe("Temperature effect has caused pbsws to be less than 0.01. \
                         Pbsws is clamped to 0.01.\n");
            end 
            BSIM4PhiBSWD = BSIM4DsidewallJctPotential - BSIM4tpbsw * delTemp;
            if (BSIM4PhiBSWD <= 0.01) begin
                BSIM4PhiBSWD = 0.01;
                $strobe("Temperature effect has caused pbswd to be less than 0.01. \
                         Pbswd is clamped to 0.01.\n");
            end
    
            BSIM4PhiBSWGS = BSIM4SGatesidewallJctPotential - BSIM4tpbswg * delTemp;
            if (BSIM4PhiBSWGS <= 0.01) begin
                BSIM4PhiBSWGS = 0.01;
                $strobe("Temperature effect has caused pbswgs to be less than 0.01. \
                         Pbswgs is clamped to 0.01.\n");
            end 
            BSIM4PhiBSWGD = BSIM4DGatesidewallJctPotential - BSIM4tpbswg * delTemp;
            if (BSIM4PhiBSWGD <= 0.01) begin
                BSIM4PhiBSWGD = 0.01;
                $strobe("Temperature effect has caused pbswgd to be less than 0.01. \
                         Pbswgd is clamped to 0.01.\n");
            end  /* End of junction capacitance */
    
            if (BSIM4ijthdfwd <= 0.0) begin
                BSIM4ijthdfwd = 0.0;  //0.1->0 for version > 4.6.1
                $strobe("Ijthdfwd reset to %g.\n", BSIM4ijthdfwd);
            end 
            if (BSIM4ijthsfwd <= 0.0) begin
                BSIM4ijthsfwd = 0.0;  //0.1->0 for version > 4.6.1
                $strobe("Ijthsfwd reset to %g.\n", BSIM4ijthsfwd);
            end 
            if (BSIM4ijthdrev <= 0.0) begin
                BSIM4ijthdrev = 0.0;  //0.1->0 for version > 4.6.1
                $strobe("Ijthdrev reset to %g.\n", BSIM4ijthdrev);
            end 
            if (BSIM4ijthsrev <= 0.0) begin
                BSIM4ijthsrev = 0.0; //0.1->0 for version > 4.6.1
                $strobe("Ijthsrev reset to %g.\n", BSIM4ijthsrev);
            end 
    
            if ((BSIM4xjbvd <= 0.0) && (BSIM4dioMod == 2)) begin
                BSIM4xjbvd = 0.0;    //1.0->0 for version > 4.6.1
                $strobe("Xjbvd reset to %g.\n", BSIM4xjbvd);
            end 
            else if ((BSIM4xjbvd < 0.0) && (BSIM4dioMod == 0)) begin
                BSIM4xjbvd = 0.0;    //1.0->0 for version > 4.6.1
                $strobe("Xjbvd reset to %g.\n", BSIM4xjbvd);
            end 
    
            if (BSIM4bvd <= 0.0) begin
                BSIM4bvd = 0.0; //10.0->0 for version > 4.6.1
                $strobe("BVD reset to %g.\n", BSIM4bvd);
            end 
    
            if ((BSIM4xjbvs <= 0.0) && (BSIM4dioMod == 2)) begin
                BSIM4xjbvs =0.0; //1.0->0 for version > 4.6.1
                $strobe("Xjbvs reset to %g.\n", BSIM4xjbvs);
            end 
            else if ((BSIM4xjbvs < 0.0) && (BSIM4dioMod == 0)) begin
                BSIM4xjbvs = 0.0;//1.0->0 for version > 4.6.1
                $strobe("Xjbvs reset to %g.\n", BSIM4xjbvs);
            end 
    
            if (BSIM4bvs <= 0.0) begin
                BSIM4bvs = 0.0; //10.0->0 for version > 4.6.1
                $strobe("BVS reset to %g.\n", BSIM4bvs);
            end 

	    /* stress effect */
	    Ldrn = BSIM4l;
	    Wdrn = BSIM4w / BSIM4nf;

            Lnew = BSIM4l + BSIM4xl;
            Wnew = BSIM4w / BSIM4nf + BSIM4xw;
            
            T0 = pow(Lnew, BSIM4Lln);
            T1 = pow(Wnew, BSIM4Lwn);
            tmp1 = BSIM4Ll / T0 + BSIM4Lw / T1
                   + BSIM4Lwl / (T0 * T1);
            
            BSIM4dl = BSIM4Lint + tmp1;
            tmp2 = BSIM4Llc / T0 + BSIM4Lwc / T1
                   + BSIM4Lwlc / (T0 * T1);
            BSIM4dlc = BSIM4dlc + tmp2;
            //BSIM4dlcig = BSIM4dlcig + tmp2;  // version > 4.3 should be removed 
    
            T2 = pow(Lnew, BSIM4Wln);
            T3 = pow(Wnew, BSIM4Wwn);
            tmp1 = BSIM4Wl / T2 + BSIM4Ww / T3
                   + BSIM4Wwl / (T2 * T3);
            BSIM4dw = BSIM4Wint + tmp1;
            tmp2 = BSIM4Wlc / T2 + BSIM4Wwc / T3
                   + BSIM4Wwlc / (T2 * T3); 
            BSIM4dwc = BSIM4dwc + tmp2;
            BSIM4dwj = BSIM4dwj + tmp2;
    
            BSIM4leff = Lnew - 2.0 * BSIM4dl;
            if (BSIM4leff <= 0.0)
                $strobe("\nFATAL Error: leff <= 0.");
    
            BSIM4weff = Wnew - 2.0 * BSIM4dw;
            if (BSIM4weff <= 0.0)
                $strobe("\nFATAL Error: weff <= 0.");
    
            BSIM4leffCV = Lnew - 2.0 * BSIM4dlc;
            if (BSIM4leffCV <= 0.0)
                $strobe("\nFATAL Error: leffCV <= 0.");
    
            BSIM4weffCV = Wnew - 2.0 * BSIM4dwc;
            if (BSIM4weffCV <= 0.0)
                $strobe("\nFATAL Error: weffCV <= 0.");
    
            BSIM4weffCJ = Wnew - 2.0 * BSIM4dwj;
    
            if (BSIM4binUnit == 1) begin
                Inv_L = 1.0e-6 / BSIM4leff;
                Inv_W = 1.0e-6 / BSIM4weff;
                Inv_LW = 1.0e-12 / (BSIM4leff * BSIM4weff);
            end 
            else begin
                Inv_L = 1.0 / BSIM4leff;
                Inv_W = 1.0 / BSIM4weff;
                Inv_LW = 1.0 / (BSIM4leff * BSIM4weff);
            end 
    
            BSIM4cdsc = BSIM4cdsc
              + BSIM4lcdsc * Inv_L
              + BSIM4wcdsc * Inv_W
              + BSIM4pcdsc * Inv_LW;
            BSIM4cdscb = BSIM4cdscb
              + BSIM4lcdscb * Inv_L
              + BSIM4wcdscb * Inv_W
              + BSIM4pcdscb * Inv_LW; 
            BSIM4cdscd = BSIM4cdscd
              + BSIM4lcdscd * Inv_L
              + BSIM4wcdscd * Inv_W
              + BSIM4pcdscd * Inv_LW; 
            BSIM4cit = BSIM4cit
              + BSIM4lcit * Inv_L
              + BSIM4wcit * Inv_W
              + BSIM4pcit * Inv_LW;
            BSIM4nfactor = BSIM4nfactor
              + BSIM4lnfactor * Inv_L
              + BSIM4wnfactor * Inv_W
              + BSIM4pnfactor * Inv_LW;
            BSIM4xj = BSIM4xj
              + BSIM4lxj * Inv_L
              + BSIM4wxj * Inv_W
              + BSIM4pxj * Inv_LW;
            BSIM4vsat = BSIM4vsat
              + BSIM4lvsat * Inv_L
              + BSIM4wvsat * Inv_W
              + BSIM4pvsat * Inv_LW;
            BSIM4at = BSIM4at
              + BSIM4lat * Inv_L
              + BSIM4wat * Inv_W
              + BSIM4pat * Inv_LW;
            BSIM4a0 = BSIM4a0
              + BSIM4la0 * Inv_L
              + BSIM4wa0 * Inv_W
              + BSIM4pa0 * Inv_LW; 
            BSIM4ags = BSIM4ags
              + BSIM4lags * Inv_L
              + BSIM4wags * Inv_W
              + BSIM4pags * Inv_LW;
            BSIM4a1 = BSIM4a1
              + BSIM4la1 * Inv_L
              + BSIM4wa1 * Inv_W
              + BSIM4pa1 * Inv_LW;
            BSIM4a2 = BSIM4a2
              + BSIM4la2 * Inv_L
              + BSIM4wa2 * Inv_W
              + BSIM4pa2 * Inv_LW;
            BSIM4keta = BSIM4keta
              + BSIM4lketa * Inv_L
              + BSIM4wketa * Inv_W
              + BSIM4pketa * Inv_LW;
            BSIM4nsub = BSIM4nsub
              + BSIM4lnsub * Inv_L
              + BSIM4wnsub * Inv_W
              + BSIM4pnsub * Inv_LW;
            BSIM4ndep = BSIM4ndep
              + BSIM4lndep * Inv_L
              + BSIM4wndep * Inv_W
              + BSIM4pndep * Inv_LW;
            BSIM4nsd = BSIM4nsd
              + BSIM4lnsd * Inv_L
              + BSIM4wnsd * Inv_W
              + BSIM4pnsd * Inv_LW;
            BSIM4phin = BSIM4phin
              + BSIM4lphin * Inv_L
              + BSIM4wphin * Inv_W
              + BSIM4pphin * Inv_LW;
            BSIM4ngate = BSIM4ngate
              + BSIM4lngate * Inv_L
              + BSIM4wngate * Inv_W
              + BSIM4pngate * Inv_LW;
            BSIM4gamma1 = BSIM4gamma1
              + BSIM4lgamma1 * Inv_L
              + BSIM4wgamma1 * Inv_W
              + BSIM4pgamma1 * Inv_LW;
            BSIM4gamma2 = BSIM4gamma2
              + BSIM4lgamma2 * Inv_L
              + BSIM4wgamma2 * Inv_W
              + BSIM4pgamma2 * Inv_LW;
            BSIM4vbx = BSIM4vbx
              + BSIM4lvbx * Inv_L
              + BSIM4wvbx * Inv_W
              + BSIM4pvbx * Inv_LW;
            BSIM4vbm = BSIM4vbm
              + BSIM4lvbm * Inv_L
              + BSIM4wvbm * Inv_W
              + BSIM4pvbm * Inv_LW;
            BSIM4xt = BSIM4xt
              + BSIM4lxt * Inv_L
              + BSIM4wxt * Inv_W
              + BSIM4pxt * Inv_LW;
            BSIM4vfb = BSIM4vfb
              + BSIM4lvfb * Inv_L
              + BSIM4wvfb * Inv_W
              + BSIM4pvfb * Inv_LW;
            BSIM4k1 = BSIM4k1
              + BSIM4lk1 * Inv_L
              + BSIM4wk1 * Inv_W
              + BSIM4pk1 * Inv_LW;
            BSIM4kt1 = BSIM4kt1
              + BSIM4lkt1 * Inv_L
              + BSIM4wkt1 * Inv_W
              + BSIM4pkt1 * Inv_LW;
            BSIM4kt1l = BSIM4kt1l
              + BSIM4lkt1l * Inv_L
              + BSIM4wkt1l * Inv_W
              + BSIM4pkt1l * Inv_LW;
            BSIM4k2 = BSIM4k2
              + BSIM4lk2 * Inv_L
              + BSIM4wk2 * Inv_W
              + BSIM4pk2 * Inv_LW;
            BSIM4kt2 = BSIM4kt2
              + BSIM4lkt2 * Inv_L
              + BSIM4wkt2 * Inv_W
              + BSIM4pkt2 * Inv_LW;
            BSIM4k3 = BSIM4k3
              + BSIM4lk3 * Inv_L
              + BSIM4wk3 * Inv_W
              + BSIM4pk3 * Inv_LW;
            BSIM4k3b = BSIM4k3b
              + BSIM4lk3b * Inv_L
              + BSIM4wk3b * Inv_W
              + BSIM4pk3b * Inv_LW;
            BSIM4w0 = BSIM4w0
              + BSIM4lw0 * Inv_L
              + BSIM4ww0 * Inv_W
              + BSIM4pw0 * Inv_LW;
            BSIM4lpe0 = BSIM4lpe0
              + BSIM4llpe0 * Inv_L
              + BSIM4wlpe0 * Inv_W
              + BSIM4plpe0 * Inv_LW;
            BSIM4lpeb = BSIM4lpeb
              + BSIM4llpeb * Inv_L
              + BSIM4wlpeb * Inv_W
              + BSIM4plpeb * Inv_LW;
            BSIM4dvtp0 = BSIM4dvtp0
              + BSIM4ldvtp0 * Inv_L
              + BSIM4wdvtp0 * Inv_W
              + BSIM4pdvtp0 * Inv_LW;
            BSIM4dvtp1 = BSIM4dvtp1
              + BSIM4ldvtp1 * Inv_L
              + BSIM4wdvtp1 * Inv_W
              + BSIM4pdvtp1 * Inv_LW;
            BSIM4dvt0 = BSIM4dvt0
              + BSIM4ldvt0 * Inv_L
              + BSIM4wdvt0 * Inv_W
              + BSIM4pdvt0 * Inv_LW;
            BSIM4dvt1 = BSIM4dvt1
              + BSIM4ldvt1 * Inv_L
              + BSIM4wdvt1 * Inv_W
              + BSIM4pdvt1 * Inv_LW;
            BSIM4dvt2 = BSIM4dvt2
              + BSIM4ldvt2 * Inv_L
              + BSIM4wdvt2 * Inv_W
              + BSIM4pdvt2 * Inv_LW;
            BSIM4dvt0w = BSIM4dvt0w
              + BSIM4ldvt0w * Inv_L
              + BSIM4wdvt0w * Inv_W
              + BSIM4pdvt0w * Inv_LW;
            BSIM4dvt1w = BSIM4dvt1w
              + BSIM4ldvt1w * Inv_L
              + BSIM4wdvt1w * Inv_W
              + BSIM4pdvt1w * Inv_LW;
            BSIM4dvt2w = BSIM4dvt2w
              + BSIM4ldvt2w * Inv_L
              + BSIM4wdvt2w * Inv_W
              + BSIM4pdvt2w * Inv_LW;
            BSIM4drout = BSIM4drout
              + BSIM4ldrout * Inv_L
              + BSIM4wdrout * Inv_W
              + BSIM4pdrout * Inv_LW;
            BSIM4dsub = BSIM4dsub
              + BSIM4ldsub * Inv_L
              + BSIM4wdsub * Inv_W
              + BSIM4pdsub * Inv_LW;
            BSIM4vth0 = BSIM4vth0
              + BSIM4lvth0 * Inv_L
              + BSIM4wvth0 * Inv_W
              + BSIM4pvth0 * Inv_LW;
            BSIM4ua = BSIM4ua
              + BSIM4lua * Inv_L
              + BSIM4wua * Inv_W
              + BSIM4pua * Inv_LW;
            BSIM4ua1 = BSIM4ua1
              + BSIM4lua1 * Inv_L
              + BSIM4wua1 * Inv_W
              + BSIM4pua1 * Inv_LW;
            BSIM4ub = BSIM4ub
              + BSIM4lub * Inv_L
              + BSIM4wub * Inv_W
              + BSIM4pub * Inv_LW;
            BSIM4ub1 = BSIM4ub1
              + BSIM4lub1 * Inv_L
              + BSIM4wub1 * Inv_W
              + BSIM4pub1 * Inv_LW;
            BSIM4uc = BSIM4uc
              + BSIM4luc * Inv_L
              + BSIM4wuc * Inv_W
              + BSIM4puc * Inv_LW;
            BSIM4uc1 = BSIM4uc1
              + BSIM4luc1 * Inv_L
              + BSIM4wuc1 * Inv_W
              + BSIM4puc1 * Inv_LW;
            BSIM4eu = BSIM4eu
              + BSIM4leu * Inv_L
              + BSIM4weu * Inv_W
              + BSIM4peu * Inv_LW;
            BSIM4u0 = BSIM4u0
              + BSIM4lu0 * Inv_L
              + BSIM4wu0 * Inv_W
              + BSIM4pu0 * Inv_LW;
            BSIM4ute = BSIM4ute
              + BSIM4lute * Inv_L
              + BSIM4wute * Inv_W
              + BSIM4pute * Inv_LW;

            //New model version > 4.3
            BSIM4tvoffcv = BSIM4tvoffcv
              + BSIM4ltvoffcv * Inv_L
              + BSIM4wtvoffcv * Inv_W
              + BSIM4ptvoffcv * Inv_LW;

            BSIM4teta0 = BSIM4teta0
              + BSIM4lteta0 * Inv_L
              + BSIM4wteta0 * Inv_W
              + BSIM4pteta0 * Inv_LW;
              
            BSIM4tnfactor = BSIM4tnfactor
              + BSIM4ltnfactor * Inv_L
              + BSIM4wtnfactor * Inv_W
              + BSIM4ptnfactor * Inv_LW;

            BSIM4minvcv = BSIM4minvcv
              + BSIM4lminvcv * Inv_L
              + BSIM4wminvcv * Inv_W
              + BSIM4pminvcv * Inv_LW;

            BSIM4tvfbsdoff = BSIM4tvfbsdoff
              + BSIM4ltvfbsdoff * Inv_L
              + BSIM4wtvfbsdoff * Inv_W
              + BSIM4ptvfbsdoff * Inv_LW;

            BSIM4aigs = BSIM4aigs
              + BSIM4laigs * Inv_L
              + BSIM4waigs * Inv_W
              + BSIM4paigs * Inv_LW;

            BSIM4bigs = BSIM4bigs
              + BSIM4lbigs * Inv_L
              + BSIM4wbigs * Inv_W
              + BSIM4pbigs * Inv_LW;

            BSIM4cigs = BSIM4cigs
              + BSIM4lcigs * Inv_L
              + BSIM4wcigs * Inv_W
              + BSIM4pcigs * Inv_LW;

            BSIM4aigd = BSIM4aigd
              + BSIM4laigd * Inv_L
              + BSIM4waigd * Inv_W
              + BSIM4paigd * Inv_LW;

            BSIM4bigd = BSIM4bigd
              + BSIM4lbigd * Inv_L
              + BSIM4wbigd * Inv_W
              + BSIM4pbigd * Inv_LW;

            BSIM4cigd = BSIM4cigd
              + BSIM4lcigd * Inv_L
              + BSIM4wcigd * Inv_W
              + BSIM4pcigd * Inv_LW;

            BSIM4agisl = BSIM4agisl
              + BSIM4lagisl * Inv_L
              + BSIM4wagisl * Inv_W
              + BSIM4pagisl * Inv_LW;

            BSIM4bgisl = BSIM4bgisl
              + BSIM4lbgisl * Inv_L
              + BSIM4wbgisl * Inv_W
              + BSIM4pbgisl * Inv_LW;

            BSIM4cgisl = BSIM4cgisl
              + BSIM4lcgisl * Inv_L
              + BSIM4wcgisl * Inv_W
              + BSIM4pcgisl * Inv_LW;

            BSIM4egisl = BSIM4egisl
              + BSIM4legisl * Inv_L
              + BSIM4wegisl * Inv_W
              + BSIM4pegisl * Inv_LW;

            BSIM4rgisl = BSIM4rgisl
              + BSIM4lrgisl * Inv_L
              + BSIM4wrgisl * Inv_W
              + BSIM4prgisl * Inv_LW;

            BSIM4kgisl = BSIM4kgisl
              + BSIM4lkgisl * Inv_L
              + BSIM4wkgisl * Inv_W
              + BSIM4pkgisl * Inv_LW;

            BSIM4fgisl = BSIM4fgisl
              + BSIM4lfgisl * Inv_L
              + BSIM4wfgisl * Inv_W
              + BSIM4pfgisl * Inv_LW;

            BSIM4rgidl = BSIM4rgidl
              + BSIM4lrgidl * Inv_L
              + BSIM4wrgidl * Inv_W
              + BSIM4prgidl * Inv_LW;

            BSIM4kgidl = BSIM4kgidl
              + BSIM4lkgidl * Inv_L
              + BSIM4wkgidl * Inv_W
              + BSIM4pkgidl * Inv_LW;

            BSIM4fgidl = BSIM4fgidl
              + BSIM4lfgidl * Inv_L
              + BSIM4wfgidl * Inv_W
              + BSIM4pfgidl * Inv_LW;

            BSIM4ud = BSIM4ud
              + BSIM4lud * Inv_L
              + BSIM4wud * Inv_W
              + BSIM4pud * Inv_LW;

            BSIM4ud1 = BSIM4ud1
              + BSIM4lud1 * Inv_L
              + BSIM4wud1 * Inv_W
              + BSIM4pud1 * Inv_LW;

            BSIM4up = BSIM4up
              + BSIM4lup * Inv_L
              + BSIM4wup * Inv_W
              + BSIM4pup * Inv_LW;

            BSIM4lp = BSIM4lp
              + BSIM4llp * Inv_L
              + BSIM4wlp * Inv_W
              + BSIM4plp * Inv_LW;

            BSIM4ucs = BSIM4ucs
              + BSIM4lucs * Inv_L
              + BSIM4wucs * Inv_W
              + BSIM4pucs * Inv_LW;

            BSIM4ucste = BSIM4ucste
              + BSIM4lucste * Inv_L
              + BSIM4wucste * Inv_W
              + BSIM4pucste * Inv_LW;

            BSIM4kvth0we = BSIM4kvth0we
              + BSIM4lkvth0we * Inv_L
              + BSIM4wkvth0we * Inv_W
              + BSIM4pkvth0we * Inv_LW;

            BSIM4k2we = BSIM4k2we
              + BSIM4lk2we * Inv_L
              + BSIM4wk2we * Inv_W
              + BSIM4pk2we * Inv_LW;

            BSIM4ku0we = BSIM4ku0we
              + BSIM4lku0we * Inv_L
              + BSIM4wku0we * Inv_W
              + BSIM4pku0we * Inv_LW;

            BSIM4vfbsdoff = BSIM4vfbsdoff
              + BSIM4lvfbsdoff * Inv_L
              + BSIM4wvfbsdoff * Inv_W
              + BSIM4pvfbsdoff * Inv_LW;

            BSIM4tvoff = BSIM4tvoff
              + BSIM4ltvoff * Inv_L
              + BSIM4wtvoff * Inv_W
              + BSIM4ptvoff * Inv_LW;
            BSIM4dvtp2 = BSIM4dvtp2
              + BSIM4ldvtp2 * Inv_L
              + BSIM4wdvtp2 * Inv_W
              + BSIM4pdvtp2 * Inv_LW;

            BSIM4dvtp3 = BSIM4dvtp3
              + BSIM4ldvtp3 * Inv_L
              + BSIM4wdvtp3 * Inv_W
              + BSIM4pdvtp3 * Inv_LW;

            BSIM4dvtp4 = BSIM4dvtp4
              + BSIM4ldvtp4 * Inv_L
              + BSIM4wdvtp4 * Inv_W
              + BSIM4pdvtp4 * Inv_LW;

            BSIM4dvtp5 = BSIM4dvtp5
              + BSIM4ldvtp5 * Inv_L
              + BSIM4wdvtp5 * Inv_W
              + BSIM4pdvtp5 * Inv_LW;

            BSIM4voff = BSIM4voff
              + BSIM4lvoff * Inv_L
              + BSIM4wvoff * Inv_W
              + BSIM4pvoff * Inv_LW;
            BSIM4minv = BSIM4minv
              + BSIM4lminv * Inv_L
              + BSIM4wminv * Inv_W
              + BSIM4pminv * Inv_LW;
            BSIM4fprout = BSIM4fprout
              + BSIM4lfprout * Inv_L
              + BSIM4wfprout * Inv_W
              + BSIM4pfprout * Inv_LW;
            BSIM4pdits = BSIM4pdits
              + BSIM4lpdits * Inv_L
              + BSIM4wpdits * Inv_W
              + BSIM4ppdits * Inv_LW;
            BSIM4pditsd = BSIM4pditsd
              + BSIM4lpditsd * Inv_L
              + BSIM4wpditsd * Inv_W
              + BSIM4ppditsd * Inv_LW;
            BSIM4delta = BSIM4delta
              + BSIM4ldelta * Inv_L
              + BSIM4wdelta * Inv_W
              + BSIM4pdelta * Inv_LW;
            BSIM4rdsw = BSIM4rdsw
              + BSIM4lrdsw * Inv_L
              + BSIM4wrdsw * Inv_W
              + BSIM4prdsw * Inv_LW;
            BSIM4rdw = BSIM4rdw
              + BSIM4lrdw * Inv_L
              + BSIM4wrdw * Inv_W
              + BSIM4prdw * Inv_LW;
            BSIM4rsw = BSIM4rsw
              + BSIM4lrsw * Inv_L
              + BSIM4wrsw * Inv_W
              + BSIM4prsw * Inv_LW;
            BSIM4prwg = BSIM4prwg
              + BSIM4lprwg * Inv_L
              + BSIM4wprwg * Inv_W
              + BSIM4pprwg * Inv_LW;
            BSIM4prwb = BSIM4prwb
              + BSIM4lprwb * Inv_L
              + BSIM4wprwb * Inv_W
              + BSIM4pprwb * Inv_LW;
            BSIM4prt = BSIM4prt
              + BSIM4lprt * Inv_L
              + BSIM4wprt * Inv_W
              + BSIM4pprt * Inv_LW;
            BSIM4eta0 = BSIM4eta0
              + BSIM4leta0 * Inv_L
              + BSIM4weta0 * Inv_W
              + BSIM4peta0 * Inv_LW;
            BSIM4etab = BSIM4etab
              + BSIM4letab * Inv_L
              + BSIM4wetab * Inv_W
              + BSIM4petab * Inv_LW;
            BSIM4pclm = BSIM4pclm
              + BSIM4lpclm * Inv_L
              + BSIM4wpclm * Inv_W
              + BSIM4ppclm * Inv_LW;
            BSIM4pdibl1 = BSIM4pdibl1
              + BSIM4lpdibl1 * Inv_L
              + BSIM4wpdibl1 * Inv_W
              + BSIM4ppdibl1 * Inv_LW;
            BSIM4pdibl2 = BSIM4pdibl2
              + BSIM4lpdibl2 * Inv_L
              + BSIM4wpdibl2 * Inv_W
              + BSIM4ppdibl2 * Inv_LW;
            BSIM4pdiblb = BSIM4pdiblb
              + BSIM4lpdiblb * Inv_L
              + BSIM4wpdiblb * Inv_W
              + BSIM4ppdiblb * Inv_LW;
            BSIM4pscbe1 = BSIM4pscbe1
              + BSIM4lpscbe1 * Inv_L
              + BSIM4wpscbe1 * Inv_W
              + BSIM4ppscbe1 * Inv_LW;
            BSIM4pscbe2 = BSIM4pscbe2
              + BSIM4lpscbe2 * Inv_L
              + BSIM4wpscbe2 * Inv_W
              + BSIM4ppscbe2 * Inv_LW;
            BSIM4pvag = BSIM4pvag
              + BSIM4lpvag * Inv_L
              + BSIM4wpvag * Inv_W
              + BSIM4ppvag * Inv_LW;
            BSIM4wr = BSIM4wr
              + BSIM4lwr * Inv_L
              + BSIM4wwr * Inv_W
              + BSIM4pwr * Inv_LW;
            BSIM4dwg = BSIM4dwg
              + BSIM4ldwg * Inv_L
              + BSIM4wdwg * Inv_W
              + BSIM4pdwg * Inv_LW;
            BSIM4dwb = BSIM4dwb
              + BSIM4ldwb * Inv_L
              + BSIM4wdwb * Inv_W
              + BSIM4pdwb * Inv_LW;
            BSIM4b0 = BSIM4b0
              + BSIM4lb0 * Inv_L
              + BSIM4wb0 * Inv_W
              + BSIM4pb0 * Inv_LW;
            BSIM4b1 = BSIM4b1
              + BSIM4lb1 * Inv_L
              + BSIM4wb1 * Inv_W
              + BSIM4pb1 * Inv_LW;
            BSIM4alpha0 = BSIM4alpha0
              + BSIM4lalpha0 * Inv_L
              + BSIM4walpha0 * Inv_W
              + BSIM4palpha0 * Inv_LW;
            BSIM4alpha1 = BSIM4alpha1
              + BSIM4lalpha1 * Inv_L
              + BSIM4walpha1 * Inv_W
              + BSIM4palpha1 * Inv_LW;
            BSIM4beta0 = BSIM4beta0
              + BSIM4lbeta0 * Inv_L
              + BSIM4wbeta0 * Inv_W
              + BSIM4pbeta0 * Inv_LW;
            BSIM4agidl = BSIM4agidl
              + BSIM4lagidl * Inv_L
              + BSIM4wagidl * Inv_W
              + BSIM4pagidl * Inv_LW;
            BSIM4bgidl = BSIM4bgidl
              + BSIM4lbgidl * Inv_L
              + BSIM4wbgidl * Inv_W
              + BSIM4pbgidl * Inv_LW;
            BSIM4cgidl = BSIM4cgidl
              + BSIM4lcgidl * Inv_L
              + BSIM4wcgidl * Inv_W
              + BSIM4pcgidl * Inv_LW;
            BSIM4egidl = BSIM4egidl
              + BSIM4legidl * Inv_L
              + BSIM4wegidl * Inv_W
              + BSIM4pegidl * Inv_LW;
            BSIM4aigc = BSIM4aigc
              + BSIM4laigc * Inv_L
              + BSIM4waigc * Inv_W
              + BSIM4paigc * Inv_LW;
            BSIM4bigc = BSIM4bigc
              + BSIM4lbigc * Inv_L
              + BSIM4wbigc * Inv_W
              + BSIM4pbigc * Inv_LW;
            BSIM4cigc = BSIM4cigc
              + BSIM4lcigc * Inv_L
              + BSIM4wcigc * Inv_W
              + BSIM4pcigc * Inv_LW;
            BSIM4aigsd = BSIM4aigsd
              + BSIM4laigsd * Inv_L
              + BSIM4waigsd * Inv_W
              + BSIM4paigsd * Inv_LW;
            BSIM4bigsd = BSIM4bigsd
              + BSIM4lbigsd * Inv_L
              + BSIM4wbigsd * Inv_W
              + BSIM4pbigsd * Inv_LW;
            BSIM4cigsd = BSIM4cigsd
              + BSIM4lcigsd * Inv_L
              + BSIM4wcigsd * Inv_W
              + BSIM4pcigsd * Inv_LW;
            BSIM4aigbacc = BSIM4aigbacc
              + BSIM4laigbacc * Inv_L
              + BSIM4waigbacc * Inv_W
              + BSIM4paigbacc * Inv_LW;
            BSIM4bigbacc = BSIM4bigbacc
              + BSIM4lbigbacc * Inv_L
              + BSIM4wbigbacc * Inv_W
              + BSIM4pbigbacc * Inv_LW;
            BSIM4cigbacc = BSIM4cigbacc
              + BSIM4lcigbacc * Inv_L
              + BSIM4wcigbacc * Inv_W
              + BSIM4pcigbacc * Inv_LW;
            BSIM4aigbinv = BSIM4aigbinv
              + BSIM4laigbinv * Inv_L
              + BSIM4waigbinv * Inv_W
              + BSIM4paigbinv * Inv_LW;
            BSIM4bigbinv = BSIM4bigbinv
              + BSIM4lbigbinv * Inv_L
              + BSIM4wbigbinv * Inv_W
              + BSIM4pbigbinv * Inv_LW;
            BSIM4cigbinv = BSIM4cigbinv
              + BSIM4lcigbinv * Inv_L
              + BSIM4wcigbinv * Inv_W
              + BSIM4pcigbinv * Inv_LW;
            BSIM4nigc = BSIM4nigc
              + BSIM4lnigc * Inv_L
              + BSIM4wnigc * Inv_W
              + BSIM4pnigc * Inv_LW;
            BSIM4nigbacc = BSIM4nigbacc
              + BSIM4lnigbacc * Inv_L
              + BSIM4wnigbacc * Inv_W
              + BSIM4pnigbacc * Inv_LW;
            BSIM4nigbinv = BSIM4nigbinv
              + BSIM4lnigbinv * Inv_L
              + BSIM4wnigbinv * Inv_W
              + BSIM4pnigbinv * Inv_LW;
            BSIM4ntox = BSIM4ntox
              + BSIM4lntox * Inv_L
              + BSIM4wntox * Inv_W
              + BSIM4pntox * Inv_LW;
            BSIM4eigbinv = BSIM4eigbinv
              + BSIM4leigbinv * Inv_L
              + BSIM4weigbinv * Inv_W
              + BSIM4peigbinv * Inv_LW;
            BSIM4pigcd = BSIM4pigcd
              + BSIM4lpigcd * Inv_L
              + BSIM4wpigcd * Inv_W
              + BSIM4ppigcd * Inv_LW;
            BSIM4poxedge = BSIM4poxedge
              + BSIM4lpoxedge * Inv_L
              + BSIM4wpoxedge * Inv_W
              + BSIM4ppoxedge * Inv_LW;
            BSIM4xrcrg1 = BSIM4xrcrg1
              + BSIM4lxrcrg1 * Inv_L
              + BSIM4wxrcrg1 * Inv_W
              + BSIM4pxrcrg1 * Inv_LW;
            BSIM4xrcrg2 = BSIM4xrcrg2
              + BSIM4lxrcrg2 * Inv_L
              + BSIM4wxrcrg2 * Inv_W
              + BSIM4pxrcrg2 * Inv_LW;
    
            // BSIM4.3
            BSIM4lambda = BSIM4lambda
              + BSIM4llambda * Inv_L
              + BSIM4wlambda * Inv_W
              + BSIM4plambda * Inv_LW;
            BSIM4vtl = BSIM4vtl
              + BSIM4lvtl * Inv_L
              + BSIM4wvtl * Inv_W
              + BSIM4pvtl * Inv_LW;
            BSIM4xn = BSIM4xn
              + BSIM4lxn * Inv_L
              + BSIM4wxn * Inv_W
              + BSIM4pxn * Inv_LW;
            BSIM4cgsl = BSIM4cgsl
              + BSIM4lcgsl * Inv_L
              + BSIM4wcgsl * Inv_W
              + BSIM4pcgsl * Inv_LW;
            BSIM4cgdl = BSIM4cgdl
              + BSIM4lcgdl * Inv_L
              + BSIM4wcgdl * Inv_W
              + BSIM4pcgdl * Inv_LW;
            BSIM4ckappas = BSIM4ckappas
              + BSIM4lckappas * Inv_L
              + BSIM4wckappas * Inv_W
              + BSIM4pckappas * Inv_LW;
            BSIM4ckappad = BSIM4ckappad
              + BSIM4lckappad * Inv_L
              + BSIM4wckappad * Inv_W
              + BSIM4pckappad * Inv_LW;
            BSIM4cf = BSIM4cf
              + BSIM4lcf * Inv_L
              + BSIM4wcf * Inv_W
              + BSIM4pcf * Inv_LW;
            BSIM4clc = BSIM4clc
              + BSIM4lclc * Inv_L
              + BSIM4wclc * Inv_W
              + BSIM4pclc * Inv_LW;
            BSIM4cle = BSIM4cle
              + BSIM4lcle * Inv_L
              + BSIM4wcle * Inv_W
              + BSIM4pcle * Inv_LW;
            BSIM4vfbcv = BSIM4vfbcv
              + BSIM4lvfbcv * Inv_L
              + BSIM4wvfbcv * Inv_W
              + BSIM4pvfbcv * Inv_LW;
            BSIM4acde = BSIM4acde
              + BSIM4lacde * Inv_L
              + BSIM4wacde * Inv_W
              + BSIM4pacde * Inv_LW;
            BSIM4moin = BSIM4moin
              + BSIM4lmoin * Inv_L
              + BSIM4wmoin * Inv_W
              + BSIM4pmoin * Inv_LW;
            BSIM4noff = BSIM4noff
              + BSIM4lnoff * Inv_L
              + BSIM4wnoff * Inv_W
              + BSIM4pnoff * Inv_LW;
            BSIM4voffcv = BSIM4voffcv
              + BSIM4lvoffcv * Inv_L
              + BSIM4wvoffcv * Inv_W
              + BSIM4pvoffcv * Inv_LW;
            
            BSIM4abulkCVfactor = 1.0 + pow((BSIM4clc / BSIM4leffCV), BSIM4cle);
            if(verbose == 1)
              $strobe("BSIM4abulkCVfactor=%g\n", BSIM4abulkCVfactor);
    
            T0 = (TRatio - 1.0);
            PowWeffWr = pow(BSIM4weffCJ * 1.0e6, BSIM4wr) * BSIM4nf;
    
            T1 = 0.0;
            T2 = 0.0;
            T3 = 0.0;
            T4 = 0.0;
            
            if(BSIM4tempMod == 0) begin
                BSIM4ua = BSIM4ua + BSIM4ua1 * T0;
                BSIM4ub = BSIM4ub + BSIM4ub1 * T0;
                BSIM4uc = BSIM4uc + BSIM4uc1 * T0;
                BSIM4vsattemp = BSIM4vsat - BSIM4at * T0;
                T10 = BSIM4prt * T0;
                /* External Rd(V) */
                if (BSIM4rdsMod) begin
                    T1 = BSIM4rdw + T10;
                    T2 = BSIM4rdwmin + T10;
                    /* External Rs(V) */
                    T3 = BSIM4rsw + T10;
                    T4 = BSIM4rswmin + T10;
                end
                /* Internal Rds(V) in IV */
                BSIM4rds0 = (BSIM4rdsw + T10) * BSIM4nf / PowWeffWr;
                BSIM4rdswmin = (BSIM4rdswmin + T10) * BSIM4nf / PowWeffWr;
            end  
            else begin
	      if (BSIM4tempMod == 3) begin
		  BSIM4ua = BSIM4ua * pow(TRatio, BSIM4ua1) ;
	          BSIM4ub = BSIM4ub * pow(TRatio, BSIM4ub1);
	          BSIM4uc = BSIM4uc * pow(TRatio, BSIM4uc1);
	          BSIM4ud = BSIM4ud * pow(TRatio, BSIM4ud1);
                end
		else begin
                /* tempMod = 1,2 */
                  BSIM4ua = BSIM4ua * (1.0 + BSIM4ua1 * delTemp) ;
                  BSIM4ub = BSIM4ub * (1.0 + BSIM4ub1 * delTemp);
                  BSIM4uc = BSIM4uc * (1.0 + BSIM4uc1 * delTemp);
                end
                BSIM4vsattemp = BSIM4vsat * (1.0 - BSIM4at * delTemp);
                T10 = 1.0 + BSIM4prt * delTemp;
                /* External Rd(V) */
                if (BSIM4rdsMod) begin
                    T1 = BSIM4rdw * T10;
                    T2 = BSIM4rdwmin * T10;
                    /* External Rs(V) */
                    T3 = BSIM4rsw * T10;
                    T4 = BSIM4rswmin * T10;
                end
                /* Internal Rds(V) in IV */
                BSIM4rds0 = BSIM4rdsw * T10 * BSIM4nf / PowWeffWr;
                BSIM4rdswmin = BSIM4rdswmin * T10 * BSIM4nf / PowWeffWr;
            end
    
            if (T1 < 0.0) begin
                T1 = 0.0;
                $strobe("Warning: (instance X*) Rdw at current temperature is negative; set to 0.\n");
            end 
            if (T2 < 0.0) begin
                T2 = 0.0;
                $strobe("Warning: (instance X*) Rdwmin at current temperature is negative; \
                         set to 0.\n");
            end 
            BSIM4rd0 = T1 / PowWeffWr;
            BSIM4rdwmin = T2 / PowWeffWr;
            if (T3 < 0.0) begin
                T3 = 0.0;
                $strobe("Warning: (instance X*) Rsw at current temperature is negative; \
                         set to 0.\n");
            end
    
            if (T4 < 0.0) begin
                T4 = 0.0;
                $strobe("Warning: (instance X*) Rswmin at current temperature is negative; \
                         set to 0.\n");
            end 
            BSIM4rs0 = T3 / PowWeffWr;
            BSIM4rswmin = T4 / PowWeffWr;
    
            if (BSIM4u0 > 1.0)
                BSIM4u0 = BSIM4u0 / 1.0e4;
            
            /* mobility channel length dependence */
            T5 = 1.0 - BSIM4up * exp( - BSIM4leff / BSIM4lp);
            BSIM4u0temp = BSIM4u0 * T5 * pow(TRatio, BSIM4ute);
            
            if (BSIM4eu < 0.0) begin
                BSIM4eu = 0.0;
                $strobe("Warning: (instance X*) eu has been negative; reset to 0.0.\n");
            end
            if (BSIM4ucs < 0.0) begin
                BSIM4ucs = 0.0;
		$strobe("Warning: ucs has been negative; reset to 0.0.\n");
	    end		            
	    BSIM4vfbsdoff = BSIM4vfbsdoff * (1.0 + BSIM4tvfbsdoff * delTemp);
	    BSIM4voff = BSIM4voff * (1.0 + BSIM4tvoff * delTemp);

	    BSIM4nfactor = BSIM4nfactor + BSIM4tnfactor * delTemp / Tnom;  /* v4.7 temp dep of leakage currents */
	    BSIM4voffcv = BSIM4voffcv * (1.0 + BSIM4tvoffcv * delTemp);   /*	 v4.7 temp dep of leakage currents */
	    BSIM4eta0 = BSIM4eta0 + BSIM4teta0 * delTemp / Tnom;   /*	 v4.7 temp dep of leakage currents */
            
            /* Source End Velocity Limit  */
            if ((BSIM4vtlGiven) && (BSIM4vtl > 0.0) ) begin
                if(BSIM4lc < 0.0)
                    BSIM4lc = 0.0;
    
                T0 = BSIM4leff / (BSIM4xn * BSIM4leff + BSIM4lc);
                BSIM4tfactor = (1.0 - T0) / (1.0 + T0 );
            end
    
            BSIM4cgdo = (BSIM4cgdo + BSIM4cf) * BSIM4weffCV;
            BSIM4cgso = (BSIM4cgso + BSIM4cf) * BSIM4weffCV;
            BSIM4cgbo = BSIM4cgbo * BSIM4leffCV * BSIM4nf;
    
            if (!BSIM4ndepGiven && BSIM4gamma1Given) begin
                T0 = BSIM4gamma1 * BSIM4coxe;
                BSIM4ndep = 3.01248e22 * T0 * T0;
            end
    
            BSIM4phi = Vtm0 * ln(BSIM4ndep / ni) + BSIM4phin + 0.4;
    
            BSIM4sqrtPhi = sqrt(BSIM4phi);
            BSIM4phis3 = BSIM4sqrtPhi * BSIM4phi;
    
            BSIM4Xdep0 = sqrt(2.0 * epssubl / (`P_Q * BSIM4ndep * 1.0e6)) 
                      * BSIM4sqrtPhi; 
            BSIM4sqrtXdep0 = sqrt(BSIM4Xdep0);

            //BSIM4litl = sqrt(3.0 * BSIM4xj * BSIM4toxe);
            //New model version >4.3
            if(BSIM4mtrlmod == 0)
              BSIM4litl = sqrt(3.0 * 3.9 / epsroxl * BSIM4xj * toxel);
            else
              BSIM4litl = sqrt(BSIM4epsrsub/epsroxl * BSIM4xj * toxel);
            
            BSIM4vbi = Vtm0 * ln(BSIM4nsd * BSIM4ndep / (ni * ni));
   
            if (BSIM4mtrlmod == 0) begin
              if (BSIM4ngate > 0.0)
                  BSIM4vfbsd = Vtm0 * ln(BSIM4ngate / BSIM4nsd);
              else
                  BSIM4vfbsd = 0.0;
            end
            else begin
              T0 = Vtm0 * ln(BSIM4nsd/ni);
              T1 = 0.5 * Eg0;
              if(T0 > T1)
                T0 = T1;
              T2 = BSIM4easub + T1 - BSIM4type * T0;
              BSIM4vfbsd = BSIM4phig - T2;            
            end
    
            BSIM4cdep0 = sqrt(`P_Q * epssubl * BSIM4ndep * 1.0e6 / 2.0 / BSIM4phi);
    
            BSIM4ToxRatio = exp(BSIM4ntox * ln(BSIM4toxref / toxel)) 
                            / toxel / toxel;
            BSIM4ToxRatioEdge = exp(BSIM4ntox * ln(BSIM4toxref / 
                (toxel * BSIM4poxedge))) /
                toxel / toxel / BSIM4poxedge / BSIM4poxedge;
            BSIM4Aechvb = (BSIM4type == `NMOS) ? 4.97232e-7 : 3.42537e-7;
            BSIM4Bechvb = (BSIM4type == `NMOS) ? 7.45669e11 : 1.16645e12;
            BSIM4AechvbEdgeS = BSIM4Aechvb * BSIM4weff * BSIM4dlcig 
                                * BSIM4ToxRatioEdge;
            BSIM4AechvbEdgeD = BSIM4Aechvb * BSIM4weff * BSIM4dlcigd
			        * BSIM4ToxRatioEdge;
                                
            BSIM4BechvbEdge = -BSIM4Bechvb * toxel * BSIM4poxedge;
            BSIM4Aechvb = BSIM4Aechvb * ( BSIM4weff * BSIM4leff * BSIM4ToxRatio);
            BSIM4Bechvb = BSIM4Bechvb * ( -toxel);
    
            BSIM4mstar = 0.5 + atan(BSIM4minv) / `M_PI;
            BSIM4mstarcv = 0.5 + atan(BSIM4minvcv) / `M_PI;
            BSIM4voffcbn = BSIM4voff + BSIM4voffl / BSIM4leff;
            BSIM4voffcbncv =  BSIM4voffcv + BSIM4voffcvl / BSIM4leff;
            BSIM4ldeb = sqrt( epssubl * Vtm0 / (`P_Q * BSIM4ndep * 1.0e6)) / 3.0;
            BSIM4acde = BSIM4acde * (  pow((BSIM4ndep / 2.0e16), -0.25));
            if(verbose ==1) begin
              $strobe("BSIM4AechvbEdgeS,D=%g,%g\n",BSIM4AechvbEdgeS, BSIM4AechvbEdgeD);
              $strobe("BSIM4BechvbEdge,BSIM4Aechvb,BSIM4Bechvb=%g,%g,%g\n",BSIM4BechvbEdge,BSIM4Aechvb,BSIM4Bechvb);
            end
    
            if (BSIM4k1Given || BSIM4k2Given) begin
                if (!BSIM4k1Given) begin
                    $strobe("Warning: (instance X*) k1 should be specified with k2.\n");
                    BSIM4k1 = 0.53;
                end 
                if (!BSIM4k2Given) begin
                    $strobe("Warning: (instance X*) k2 should be specified with k1.\n");
                    BSIM4k2 = -0.0186;
                end 
                if (BSIM4nsubGiven)
                    $strobe("Warning: (instance X*) nsub is ignored because k1 or k2 is given.\n");
                if (BSIM4xtGiven)
                    $strobe("Warning: (instance X*) xt is ignored because k1 or k2 is given.\n");
                if (BSIM4vbxGiven)
                    $strobe("Warning: (instance X*) vbx is ignored because k1 or k2 is given.\n");
                if (BSIM4gamma1Given)
                    $strobe("Warning: (instance X*) gamma1 is ignored because k1 or k2 \
                             is given.\n");
                if (BSIM4gamma2Given)
                    $strobe("Warning: (instance X*) gamma2 is ignored because k1 or k2 \
                             is given.\n");
            end 
            else begin
                if (!BSIM4vbxGiven)
                    $strobe("\n RECALCULATION for no K1 or K2");
                BSIM4vbx = BSIM4phi - 7.7348e-4 * BSIM4ndep * BSIM4xt * BSIM4xt;
    
                if (BSIM4vbx > 0.0)
                    BSIM4vbx = -BSIM4vbx;
                if (BSIM4vbm > 0.0)
                    BSIM4vbm = -BSIM4vbm;        
                if (!BSIM4gamma1Given)
                    BSIM4gamma1 = 5.753e-12 * sqrt(BSIM4ndep) / BSIM4coxe;
                if (!BSIM4gamma2Given)
                    BSIM4gamma2 = 5.753e-12 * sqrt(BSIM4nsub) / BSIM4coxe;
    
                T0 = BSIM4gamma1 - BSIM4gamma2;
                T1 = sqrt(BSIM4phi - BSIM4vbx) - BSIM4sqrtPhi;
                T2 = sqrt(BSIM4phi * (BSIM4phi - BSIM4vbm)) - BSIM4phi;
                BSIM4k2 = T0 * T1 / (2.0 * T2 + BSIM4vbm);
                BSIM4k1 = BSIM4gamma2 - 2.0 * BSIM4k2 * sqrt(BSIM4phi - BSIM4vbm);
            end 
           
    
            if (!BSIM4vfbGiven) begin
                if (BSIM4vth0Given)
                    BSIM4vfb = BSIM4type * BSIM4vth0 - BSIM4phi 
                                - BSIM4k1 * BSIM4sqrtPhi;
                else begin
	            if ((BSIM4mtrlmod) && (BSIM4phigGiven) && 
	                (BSIM4nsubGiven))
	              begin
	                T0 = Vtm0 * ln(BSIM4nsub/ni);
	                T1 = 0.5 * Eg0;
	                if(T0 > T1)
	                  T0 = T1;
	                T2 = BSIM4easub + T1 + BSIM4type * T0;
	                BSIM4vfb = BSIM4phig - T2;			    
	              end
                    else
                      BSIM4vfb = -1.0;
                end
            end 
            if (!BSIM4vth0Given) begin
                BSIM4vth0 = BSIM4type * (BSIM4vfb + BSIM4phi 
                         + BSIM4k1 * BSIM4sqrtPhi);
            end 
    
            BSIM4k1ox = BSIM4k1 * toxel / BSIM4toxm;
            tmp = sqrt(epssubl / (epsroxl * `EPS0) * toxel * BSIM4Xdep0);
   
            T0 = BSIM4dsub * BSIM4leff / tmp;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                BSIM4theta0vb0 = T1 / T4;
            end 
            else
                BSIM4theta0vb0 = 1.0 / (`MAX_EXP - 2.0);
    
            T0 = BSIM4drout * BSIM4leff / tmp;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                T5 = T1 / T4;
            end 
            else
                T5 = 1.0 / (`MAX_EXP - 2.0); /* 3.0 * `MIN_EXP omitted */
            BSIM4thetaRout = BSIM4pdibl1 * T5 + BSIM4pdibl2;
            
            tmp = sqrt(BSIM4Xdep0);
            tmp1 = BSIM4vbi - BSIM4phi;
            tmp2 = BSIM4factor1 * tmp;
    
            T0 = BSIM4dvt1w * BSIM4weff * BSIM4leff / tmp2;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                T8 = T1 / T4;
            end 
            else
                T8 = 1.0 / (`MAX_EXP - 2.0);
           
            T0 = BSIM4dvt0w * T8;
            T8 = T0 * tmp1;
    
            T0 = BSIM4dvt1 * BSIM4leff / tmp2;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                T9 = T1 / T4;
            end 
            else
                T9 = 1.0 / (`MAX_EXP - 2.0);
    
            T9 = BSIM4dvt0 * T9 * tmp1;
            T4 = toxel * BSIM4phi / (BSIM4weff + BSIM4w0);
    
            T0 = sqrt(1.0 + BSIM4lpe0 / BSIM4leff);
            if((BSIM4tempMod == 1) || (BSIM4tempMod == 0))
            	T3 = (BSIM4kt1 + BSIM4kt1l / BSIM4leff) * (TRatio - 1.0);
            if((BSIM4tempMod == 2)||(BSIM4tempMod == 3))
                  T3 = - BSIM4kt1 * (TRatio - 1.0);
            
            T5 = BSIM4k1ox * (T0 - 1.0) * BSIM4sqrtPhi 
                  + T3;
            BSIM4vfbzbfactor = - T8 - T9 + BSIM4k3 * T4 + T5
			     - BSIM4phi - BSIM4k1 * BSIM4sqrtPhi;
    
            /* Stress effect */
	    if (BSIM4wlod < 0.0) begin
	             $strobe("Warning: WLOD = %g is less than 0. 0.0 is used\n",BSIM4wlod);
               	     BSIM4wlod = 0.0;
	    end
            T0 = pow(Lnew, BSIM4llodku0);
            W_tmp = Wnew + BSIM4wlod;
            T1 = pow(W_tmp, BSIM4wlodku0);
            tmp1 = BSIM4lku0 / T0 + BSIM4wku0 / T1 + BSIM4pku0 / (T0 * T1);
            T9 = 1.0 + tmp1;           
    
            T0 = pow(Lnew, BSIM4llodvth);
            T1 = pow(W_tmp, BSIM4wlodvth);
            tmp1 = BSIM4lkvth0 / T0 + BSIM4wkvth0 / T1 + BSIM4pkvth0 / (T0 * T1);
            param_BSIM4kvth0 = 1.0 + tmp1;
            param_BSIM4kvth0 = sqrt(param_BSIM4kvth0*param_BSIM4kvth0 + `DELTA);
    
            T0 = (TRatio - 1.0);
            BSIM4ku0temp = T9 * (1.0 + BSIM4tku0 * T0) + `DELTA;
    
            Inv_saref = 1.0/(BSIM4saref + 0.5*Ldrn);
            Inv_sbref = 1.0/(BSIM4sbref + 0.5*Ldrn);
            BSIM4inv_od_ref = Inv_saref + Inv_sbref;
            BSIM4rho_ref = BSIM4ku0 / BSIM4ku0temp * BSIM4inv_od_ref;

            //New model paramsters version > 4.3
            /*high k*/
            /*Calculate VgsteffVth for mobMod=3*/
            if (BSIM4mobMod == 3) begin
            	/*Calculate n @ Vbs=Vds=0*/
                lt1 = BSIM4factor1* BSIM4sqrtXdep0;
                T0 = BSIM4dvt1 * BSIM4leff / lt1;
                if (T0 < `EXP_THRESHOLD) begin
                    T1 = exp(T0);
                    T2 = T1 - 1.0;
                    T3 = T2 * T2;
                    T4 = T3 + 2.0 * T1 * `MIN_EXP;
                    Theta0 = T1 / T4;
                end
                else 
                    Theta0 = 1.0 / (`MAX_EXP - 2.0);
            
                tmp1 = epssubl / BSIM4Xdep0;
                tmp2 = BSIM4nfactor * tmp1;
                tmp3 = (tmp2 + BSIM4cdsc * Theta0 + BSIM4cit) / BSIM4coxe;
                if (tmp3 >= -0.5)
                    N0 = 1.0 + tmp3;
                else begin
                    T0 = 1.0 / (3.0 + 8.0 * tmp3);
                    N0 = (1.0 + 3.0 * tmp3) * T0;
                end
            
                T0 = N0 * BSIM4vtm;
                T1 = BSIM4voffcbn;
                T2 = T1/T0;
                if (T2 < -`EXP_THRESHOLD) begin
                    T3 = BSIM4coxe * `MIN_EXP / BSIM4cdep0;
                    T4 = BSIM4mstar + T3 * N0;
                end
                else if (T2 > `EXP_THRESHOLD) begin
                    T3 = BSIM4coxe * `MAX_EXP / BSIM4cdep0;
                    T4 = BSIM4mstar + T3 * N0;
                end
                else begin
                   T3 = exp(T2)* BSIM4coxe / BSIM4cdep0;
                   T4 = BSIM4mstar + T3 * N0;
                end
                BSIM4VgsteffVth = T0 * ln(2.0)/T4;
            end /*BSIM4mobMod == 3*/

            /* New DITS term added in 4.7 */
            T0 = -BSIM4dvtp3 * ln(BSIM4leff); 
            `DEXP(T0, T1)
            BSIM4dvtp2factor = BSIM4dvtp5 + BSIM4dvtp2 * T1;            

            /*  Stress effect */
            if( (BSIM4sa > 0.0) && (BSIM4sb > 0.0) &&
                ((BSIM4nf == 1.0) || ((BSIM4nf > 1.0) && (BSIM4sd > 0.0))) ) begin
                Inv_sa = 0.0;
                Inv_sb = 0.0;
		if (BSIM4kvsat < -1.0 )
	          begin   
                      $strobe("Warning: KVSAT = %g is too small; -1.0 is used.\n",BSIM4kvsat);
	       	      BSIM4kvsat = -1.0;
            	  end
            	if (BSIM4kvsat > 1.0)
            	  begin   
                      $strobe("Warning: KVSAT = %g is too big; 1.0 is used.\n",BSIM4kvsat);
           	      BSIM4kvsat = 1.0;
            	  end
                
                for (i = 0; i < BSIM4nf; i = i + 1) begin
                    T0 = 1.0 / BSIM4nf / (BSIM4sa + 0.5*Ldrn + i * (BSIM4sd +Ldrn));
                    T1 = 1.0 / BSIM4nf / (BSIM4sb + 0.5*Ldrn + i * (BSIM4sd +Ldrn));
                    Inv_sa = Inv_sa +T0;
                    Inv_sb = Inv_sb + T1;
                end
    
                Inv_ODeff = Inv_sa + Inv_sb;
                rho = BSIM4ku0 / BSIM4ku0temp * Inv_ODeff;
    
                T0 = (1.0 + rho)/(1.0 + BSIM4rho_ref);
                here_BSIM4u0temp = BSIM4u0temp * T0;
                T1 = (1.0 + BSIM4kvsat * rho)/(1.0 + BSIM4kvsat * BSIM4rho_ref);
                here_BSIM4vsattemp = BSIM4vsattemp * T1;
    
                OD_offset = Inv_ODeff - BSIM4inv_od_ref;
                dvth0_lod = BSIM4kvth0 / param_BSIM4kvth0 * OD_offset;
    
                dk2_lod = BSIM4stk2 / pow(param_BSIM4kvth0, BSIM4lodk2)* OD_offset;
                deta0_lod = BSIM4steta0 / pow(param_BSIM4kvth0, BSIM4lodeta0) 
                             * OD_offset;
            
                here_BSIM4vth0 = BSIM4vth0 + dvth0_lod;
                here_BSIM4eta0 = BSIM4eta0 + deta0_lod;
		here_BSIM4k2 = BSIM4k2 + dk2_lod;
            end 
            else begin
                here_BSIM4u0temp = BSIM4u0temp;
                here_BSIM4vth0 = BSIM4vth0;
                here_BSIM4vsattemp = BSIM4vsattemp;
                here_BSIM4eta0 = BSIM4eta0;
                here_BSIM4k2 = BSIM4k2;
            end
             
	      /*  Well Proximity Effect  */
              if (BSIM4wpemod) begin  
                if( (!BSIM4scaGiven) && (!BSIM4scbGiven) && (!BSIM4sccGiven) )
		  begin 
                  if((BSIM4scGiven) && (BSIM4sc > 0.0) ) begin
	      	        T1 = BSIM4sc + Wdrn;
                	T2 = 1.0 / BSIM4scref;
			BSIM4sca = BSIM4scref * BSIM4scref 
					/ (BSIM4sc * T1);		
			BSIM4scb = ( (0.1 * BSIM4sc + 0.01 * BSIM4scref) 
					* exp(-10.0 * BSIM4sc * T2)  
					- (0.1 * T1 + 0.01 * BSIM4scref) 
					* exp(-10.0 * T1 * T2) ) / Wdrn;
                        BSIM4scc = ( (0.05 * BSIM4sc + 0.0025 * BSIM4scref)
                                        * exp(-20.0 * BSIM4sc * T2)  
                                        - (0.05 * T1 + 0.0025 * BSIM4scref) 
                                        * exp(-20.0 * T1 * T2) ) / Wdrn;
		    end else  
                        $strobe("Warning: No WPE as none of SCA, SCB, SCC, SC is given and/or SC not positive.\n");
		    
		end
		
	       if (BSIM4sca < 0.0) begin
                    $strobe("Warning: SCA = %g is negative. Set to 0.0.\n", BSIM4sca);
                    BSIM4sca = 0.0;
                end
                if (BSIM4scb < 0.0) begin
                    $strobe("Warning: SCB = %g is negative. Set to 0.0.\n", BSIM4scb);
                    BSIM4scb = 0.0;
                end
                if (BSIM4scc < 0.0) begin
                    $strobe("Warning: SCC = %g is negative. Set to 0.0.\n", BSIM4scc);
                    BSIM4scc = 0.0;
                end
                if (BSIM4sc < 0.0) begin
                    $strobe("Warning: SC = %g is negative. Set to 0.0.\n", BSIM4sc);
                    BSIM4sc = 0.0;
                end
				/*4.6.2*/
		sceff = BSIM4sca + BSIM4web * BSIM4scb 
                      + BSIM4wec * BSIM4scc;
                here_BSIM4vth0 = here_BSIM4vth0 + BSIM4kvth0we * sceff;
                here_BSIM4k2 = here_BSIM4k2 +  BSIM4k2we * sceff;
	  	T3 =  1.0 + BSIM4ku0we * sceff;
		if (T3 <= 0.0) 
		begin 	T3 = 0.0;
                        $strobe("Warning: ku0we = %g is negatively too high. Negative mobility! \n",BSIM4ku0we);
		end
                here_BSIM4u0temp = here_BSIM4u0temp * T3; 
            end
            
	    /* adding delvto  */
            here_BSIM4vth0 = here_BSIM4vth0 + BSIM4delvto;
            here_BSIM4vfb = BSIM4vfb + BSIM4type * BSIM4delvto;
           
	    /* Instance variables calculation  */ 
            T3 = BSIM4type * here_BSIM4vth0
               - here_BSIM4vfb - BSIM4phi;
            T4 = T3 + T3;
            T5 = 2.5 * T3;
            here_BSIM4vtfbphi1 = (BSIM4type == `NMOS) ? T4 : T5;
            if (here_BSIM4vtfbphi1 < 0.0)
                here_BSIM4vtfbphi1 = 0.0;

            here_BSIM4vtfbphi2 = 4.0 * T3;
            if (here_BSIM4vtfbphi2 < 0.0)
                here_BSIM4vtfbphi2 = 0.0;

            if (here_BSIM4k2 < 0.0)
            begin   T0 = 0.5 * BSIM4k1 / here_BSIM4k2;
                here_BSIM4vbsc = 0.9 * (BSIM4phi - T0 * T0);
                if (here_BSIM4vbsc > -3.0)
                    here_BSIM4vbsc = -3.0;
                else if (here_BSIM4vbsc < -30.0)
                    here_BSIM4vbsc = -30.0;
            end
            else
                here_BSIM4vbsc = -30.0;
            if (here_BSIM4vbsc > BSIM4vbm)
                here_BSIM4vbsc = BSIM4vbm;
            here_BSIM4k2ox = here_BSIM4k2 * toxel
                              / BSIM4toxm;

            here_BSIM4vfbzb = BSIM4vfbzbfactor 
				+  BSIM4type * here_BSIM4vth0 ;
            
//`ifdef __RBODYMOD__
            //New model rbodyMod >1                    
	    lnl = ln(BSIM4leff * 1.0e6);
	    lnw = ln(BSIM4weff * 1.0e6);
	    lnnf =ln(BSIM4nf);

	    bodymode = 5;
	    if( ( !BSIM4rbps0Given) || 
	        ( !BSIM4rbpd0Given) )
	      bodymode = 1;
	    else 
	      if( (!BSIM4rbsbx0Given && !BSIM4rbsby0Given) ||
	            (!BSIM4rbdbx0Given && !BSIM4rbdby0Given) )
	        bodymode = 3;

	    if(BSIM4rbodyMod == 2)
	      begin
	        if (bodymode == 5)
	          begin
                    T0 =  BSIM4rbsbx0 * exp( BSIM4rbsdbxl * lnl +  BSIM4rbsdbxw * lnw + BSIM4rbsdbxnf * lnnf ); //rbsbx -> T0
	            T1 =  BSIM4rbsby0 * exp( BSIM4rbsdbyl * lnl +  BSIM4rbsdbyw * lnw + BSIM4rbsdbynf * lnnf ); //rbsby -> T1             
	            BSIM4rbsb = T0 * T1 / (T0 + T1);
         
                    T0 =  BSIM4rbdbx0 * exp( BSIM4rbsdbxl * lnl +  BSIM4rbsdbxw * lnw + BSIM4rbsdbxnf * lnnf );
	            T1 =  BSIM4rbdby0 * exp(  BSIM4rbsdbyl * lnl +  BSIM4rbsdbyw * lnw + BSIM4rbsdbynf * lnnf );
	            BSIM4rbdb = T0 * T1 / (T0 + T1);
	          end

	        if ((bodymode == 3)|| (bodymode == 5)) 
	          begin
	           BSIM4rbps = BSIM4rbps0 * exp( BSIM4rbpsl * lnl +  BSIM4rbpsw * lnw + BSIM4rbpsnf * lnnf );
	           BSIM4rbpd = BSIM4rbpd0 * exp( BSIM4rbpdl * lnl +  BSIM4rbpdw * lnw + BSIM4rbpdnf * lnnf );
                  
	          end
                T0 =  BSIM4rbpbx0 * exp(  BSIM4rbpbxl * lnl +  
	      		BSIM4rbpbxw * lnw + BSIM4rbpbxnf * lnnf );
	        T1 =  BSIM4rbpby0 * exp(  BSIM4rbpbyl * lnl +  
	      		BSIM4rbpbyw * lnw + BSIM4rbpbynf * lnnf );
	        
	        BSIM4rbpb = T0*T1/(T0 + T1);
	      end


            if ((BSIM4rbodyMod == 1 ) || ((BSIM4rbodyMod == 2 ) && (bodymode == 5)) )
            begin
                if (BSIM4rbdb < 1.0e-3)
                    BSIM4grbdb = 1.0e3; /* in mho */
                else
                    BSIM4grbdb = BSIM4gbmin + 1.0 / BSIM4rbdb;
                if (BSIM4rbpb < 1.0e-3)
                    BSIM4grbpb = 1.0e3;
                else
                    BSIM4grbpb = BSIM4gbmin + 1.0 / BSIM4rbpb;
                if (BSIM4rbps < 1.0e-3)
                    BSIM4grbps = 1.0e3;
                else
                    BSIM4grbps = BSIM4gbmin + 1.0 / BSIM4rbps;
                if (BSIM4rbsb < 1.0e-3)
                    BSIM4grbsb = 1.0e3;
                else
                    BSIM4grbsb = BSIM4gbmin + 1.0 / BSIM4rbsb;
                if (BSIM4rbpd < 1.0e-3)
                    BSIM4grbpd = 1.0e3;
                else
                    BSIM4grbpd = BSIM4gbmin + 1.0 / BSIM4rbpd;
            end

	    if((BSIM4rbodyMod == 2) && (bodymode == 3)) 
            begin   
                    BSIM4grbdb = BSIM4gbmin;
                    BSIM4grbsb = BSIM4gbmin;
                if (BSIM4rbpb < 1.0e-3)
                    BSIM4grbpb = 1.0e3;
                else
                    BSIM4grbpb = BSIM4gbmin + 1.0 / BSIM4rbpb;
                if (BSIM4rbps < 1.0e-3)
                    BSIM4grbps = 1.0e3;
                else
                    BSIM4grbps = BSIM4gbmin + 1.0 / BSIM4rbps;
                if (BSIM4rbpd < 1.0e-3)
                    BSIM4grbpd = 1.0e3;
                else
                    BSIM4grbpd = BSIM4gbmin + 1.0 / BSIM4rbpd;
            end

	    if((BSIM4rbodyMod == 2) && (bodymode == 1)) 
            begin   
                    BSIM4grbsb = BSIM4gbmin;
                    BSIM4grbdb = BSIM4gbmin;
	            BSIM4grbps = 1.0e3;
	            BSIM4grbpd = 1.0e3;
                if (BSIM4rbpb < 1.0e-3)
                    BSIM4grbpb = 1.0e3;
                else
                    BSIM4grbpb = BSIM4gbmin + 1.0 / BSIM4rbpb;
            end
//`endif

    
            /* 
             * Process geometry dependent parasitics
             */
    
            BSIM4grgeltd = BSIM4rshg * (BSIM4xgw + BSIM4weffCJ / 3.0 / BSIM4ngcon)
                            / (BSIM4ngcon * BSIM4nf * (Lnew - BSIM4xgl));
    
            if (BSIM4grgeltd > 0.0)
                BSIM4grgeltd = 1.0 / BSIM4grgeltd;
            else begin
                BSIM4grgeltd = 1.0e3; /* mho */
                if (BSIM4rgateMod != 0)
                    $strobe("Warning: (instance X*) The gate conductance reset to 1.0e3 mho.\n");
            end
    
            DMCGeff = BSIM4dmcg - BSIM4dmcgt;
            DMCIeff = BSIM4dmci;
            DMDGeff = BSIM4dmdg - BSIM4dmcgt;
   
            /* New Diode Model v4.7*/
            if (BSIM4sourcePerimeterGiven) 
                //if (BSIM4perMod == 0)
                //    BSIM4Pseff = BSIM4sourcePerimeter;
                //else
                //    BSIM4Pseff = BSIM4sourcePerimeter - BSIM4weffCJ * BSIM4nf;
	      begin   /* given */
		if (BSIM4sourcePerimeter == 0.0)
			BSIM4Pseff = 0.0;
		else if (BSIM4sourcePerimeter < 0.0)
		begin
			$strobe("Warning: Source Perimeter is specified as negative, it is set to zero.\n");
			BSIM4Pseff = 0.0;
		end else begin
			if (BSIM4perMod == 0)
				BSIM4Pseff = BSIM4sourcePerimeter;
			else
				BSIM4Pseff = BSIM4sourcePerimeter 
					- BSIM4weffCJ * BSIM4nf;
		end
            end 
            else begin  /* not given */
                `BSIM4PAeffGeo(BSIM4nf, BSIM4geoMod, BSIM4min, BSIM4weffCJ, DMCGeff,
                               DMCIeff, DMDGeff, BSIM4Pseff, dumPd, dumAs, dumAd)
            end
            if (BSIM4Pseff < 0.0) begin
             /* v4.7 final check */
		BSIM4Pseff = 0.0;		  
		$strobe("Warning: Pseff is negative, it is set to zero.\n");
	    end	           
            if (BSIM4drainPerimeterGiven) 
                //if (BSIM4perMod == 0)
                //    BSIM4Pdeff = BSIM4drainPerimeter;
                //else
                //    BSIM4Pdeff = BSIM4drainPerimeter - BSIM4weffCJ * BSIM4nf;
		begin   /* given */
		  if (BSIM4drainPerimeter == 0.0)
		      BSIM4Pdeff = 0.0;
		  else if (BSIM4drainPerimeter < 0.0)
		  begin
		      $strobe("Warning: Drain Perimeter is specified as negative, it is set to zero.\n");
			BSIM4Pdeff = 0.0;	
		  end else begin
			if (BSIM4perMod == 0)
			    BSIM4Pdeff = BSIM4drainPerimeter;
			else
			    BSIM4Pdeff = BSIM4drainPerimeter 
							- BSIM4weffCJ * BSIM4nf;
                  end
                end 
            else begin /* not given */
                `BSIM4PAeffGeo(BSIM4nf, BSIM4geoMod, BSIM4min, BSIM4weffCJ, DMCGeff,
                               DMCIeff, DMDGeff, dumPs, BSIM4Pdeff, dumAs, dumAd)
            end 

            /*New Diode v4.7*/
	    if (BSIM4Pdeff < 0.0) begin
		BSIM4Pdeff = 0.0; 
		$strobe("Warning: Pdeff is negative, it is set to zero.\n");
	    end            
            if (BSIM4sourceAreaGiven)
                BSIM4Aseff = BSIM4sourceArea;
            else begin
                `BSIM4PAeffGeo(BSIM4nf, BSIM4geoMod, BSIM4min, BSIM4weffCJ, DMCGeff,
                               DMCIeff, DMDGeff, dumPs, dumPd, BSIM4Aseff, dumAd)
            end
	    if (BSIM4Aseff < 0.0) begin
		  BSIM4Aseff = 0.0; /* v4.7 */
	          $strobe("Warning: Aseff is negative, it is set to zero.\n");
            end     
            if (BSIM4drainAreaGiven)
                BSIM4Adeff = BSIM4drainArea;
            else begin
                `BSIM4PAeffGeo(BSIM4nf, BSIM4geoMod, BSIM4min, BSIM4weffCJ, DMCGeff, 
                               DMCIeff, DMDGeff, dumPs, dumPd, dumAs, BSIM4Adeff)
            end 
	    if (BSIM4Adeff < 0.0) begin
		  BSIM4Adeff = 0.0; /* v4.7 */
	          $strobe("Warning: Adeff is negative, it is set to zero.\n");
            end             

            /* Processing S/D resistance and conductance below */
            //VA: if   (BSIM4sNodePrime != BSIM4sNode)
            BSIM4sourceConductance = 0.0;
            if(BSIM4sourceSquaresGiven) begin
                BSIM4sourceConductance = BSIM4sheetResistance * BSIM4sourceSquares;
            end  
            else if (BSIM4rgeoMod > 0) begin
                `BSIM4RdseffGeo(BSIM4nf, BSIM4geoMod, BSIM4rgeoMod, BSIM4min, 
                                BSIM4weffCJ, BSIM4sheetResistance, DMCGeff, DMCIeff, 
                                DMDGeff, 1, BSIM4sourceConductance)
            end
            else
                BSIM4sourceConductance = 0.0; 
    
            if (BSIM4sourceConductance > 0.0)
                BSIM4sourceConductance = 1.0 / BSIM4sourceConductance;
            else begin
	      //if (BSIM4sourceConductance == 0.0 ) begin /*TODO: always keeps internal nodes,we used all full static nodes at setup.*/
	      if (BSIM4sourceConductance == 0.0 && (BSIM4rsh > 0 
                 && (!BSIM4sourceSquaresGiven && BSIM4rgeoMod != 0) 
                   || BSIM4rdsMod != 0) ) begin
                  BSIM4sourceConductance = 1.0e3; /* mho */
	          $strobe ("Warning: (instance X*) Source diffusion conductance reset to 1.0e3 mho.\n");
              end
            end 
    
            //VA: if (BSIM4dNodePrime != BSIM4dNode)
            BSIM4drainConductance = 0.0;
            if(BSIM4drainSquaresGiven) 
                BSIM4drainConductance = BSIM4sheetResistance * BSIM4drainSquares;
            else if (BSIM4rgeoMod > 0) begin
                `BSIM4RdseffGeo(BSIM4nf, BSIM4geoMod, BSIM4rgeoMod, BSIM4min, 
                                BSIM4weffCJ, BSIM4sheetResistance, DMCGeff, DMCIeff, 
                                DMDGeff, 0, BSIM4drainConductance)
            end
            else                  
               BSIM4drainConductance = 0.0;
            
            if (BSIM4drainConductance > 0.0)
                BSIM4drainConductance = 1.0 / BSIM4drainConductance;
            else begin    
	      //if (BSIM4drainConductance == 0.0 ) begin /*TODO: need to remove internal nodes? but we used all full static nodes at setup.*/
	      if (BSIM4drainConductance == 0.0 && (BSIM4rsh > 0 
                 && (!BSIM4drainSquaresGiven && BSIM4rgeoMod != 0) 
                   || BSIM4rdsMod != 0 ) ) begin
                  BSIM4drainConductance = 1.0e3; /* mho */
	          $strobe ("Warning: (instance X*) Drain diffusion conductance reset to 1.0e3 mho.\n");
              end            
            end
    
            if (verbose == 1) begin
              $strobe("BSIM4geoMod, BSIM4rgeoMod, d/s-conductance=%d,%d,%e,%e\n",BSIM4geoMod, BSIM4rgeoMod,BSIM4drainConductance,BSIM4sourceConductance);
              $strobe("ps,pd,ad,as(given):%e,%e,%d,%e,%e,%d,%e,%e,%d,%e,%e,%d\n",
                  BSIM4Pseff,BSIM4sourcePerimeter,BSIM4sourcePerimeterGiven,
                  BSIM4Pdeff,BSIM4drainPerimeter,BSIM4drainPerimeterGiven,
                  BSIM4Adeff,BSIM4drainArea,BSIM4drainAreaGiven,
                  BSIM4Aseff,BSIM4sourceArea,BSIM4sourceAreaGiven);
            end
            /* End of Rsd processing */
            
            Nvtms = BSIM4vtm * BSIM4SjctEmissionCoeff;
            if ((BSIM4Aseff <= 0.0) && (BSIM4Pseff <= 0.0))
                //SourceSatCurrent = 1.0e-14;
                SourceSatCurrent = 0.0; /* v4.7 */
            else
                SourceSatCurrent = BSIM4Aseff * BSIM4SjctTempSatCurDensity
                       + BSIM4Pseff * BSIM4SjctSidewallTempSatCurDensity
                       + BSIM4weffCJ * BSIM4nf
                       * BSIM4SjctGateSidewallTempSatCurDensity;
            
            if (SourceSatCurrent > 0.0) begin
                case (BSIM4dioMod)
                    0: begin
                        if ((BSIM4bvs / Nvtms) > `EXP_THRESHOLD)
                            BSIM4XExpBVS = BSIM4xjbvs * `MIN_EXP;
                        else
                            BSIM4XExpBVS = BSIM4xjbvs * exp(-BSIM4bvs / Nvtms);
                    end // case: 0
                    1: begin
                        BSIM4vjsmFwd=BSIM4DioIjthVjmEval(Nvtms, BSIM4ijthsfwd, SourceSatCurrent, 0.0);
                        BSIM4IVjsmFwd = SourceSatCurrent * exp(BSIM4vjsmFwd / Nvtms);
                    end
                    2: begin
                        if ((BSIM4bvs / Nvtms) > `EXP_THRESHOLD)
                        begin
                            BSIM4XExpBVS = BSIM4xjbvs * `MIN_EXP;
                            tmp = `MIN_EXP;
                        end 
                        else begin
                            BSIM4XExpBVS = exp(-BSIM4bvs / Nvtms);
                            tmp = BSIM4XExpBVS;
                            BSIM4XExpBVS = BSIM4XExpBVS * (  BSIM4xjbvs);
                        end 
                        BSIM4vjsmFwd=BSIM4DioIjthVjmEval(Nvtms, BSIM4ijthsfwd, SourceSatCurrent, BSIM4XExpBVS); 
                        T0 = exp(BSIM4vjsmFwd / Nvtms);
                        BSIM4IVjsmFwd = SourceSatCurrent * (T0 - BSIM4XExpBVS / T0
                        + BSIM4XExpBVS - 1.0);
                        BSIM4SslpFwd = SourceSatCurrent
                        * (T0 + BSIM4XExpBVS / T0) / Nvtms;
                        
                        T2 = BSIM4ijthsrev / SourceSatCurrent;
                        if (T2 < 1.0) begin
                            T2 = 10.0;
                            $strobe("Warning: (instance X*) ijthsrev too small and set to 10 times IsbSat.\n");
                        end  
                        BSIM4vjsmRev = -BSIM4bvs
                        - Nvtms * ln((T2 - 1.0) / BSIM4xjbvs);
                        T1 = BSIM4xjbvs * exp(-(BSIM4bvs
                        + BSIM4vjsmRev) / Nvtms);
                        BSIM4IVjsmRev = SourceSatCurrent * (1.0 + T1);
                        BSIM4SslpRev = -SourceSatCurrent * T1 / Nvtms;
                    end
                    default:
                        $strobe("Specified dioMod = %d not matched\n", BSIM4dioMod);
                endcase
    
                Nvtmd = BSIM4vtm * BSIM4DjctEmissionCoeff;
                if ((BSIM4Adeff <= 0.0) && (BSIM4Pdeff <= 0.0))
                    /* DrainSatCurrent = 1.0e-14; v4.7 */
                    DrainSatCurrent = 0.0;
                else
                    DrainSatCurrent = BSIM4Adeff * BSIM4DjctTempSatCurDensity
                        + BSIM4Pdeff * BSIM4DjctSidewallTempSatCurDensity
                        + BSIM4weffCJ * BSIM4nf
                        * BSIM4DjctGateSidewallTempSatCurDensity;
            end 
            
            if (DrainSatCurrent > 0.0) begin
                case (BSIM4dioMod)
                    0: begin
                        if ((BSIM4bvd / Nvtmd) > `EXP_THRESHOLD)
                            BSIM4XExpBVD = BSIM4xjbvd * `MIN_EXP;
                        else
                            BSIM4XExpBVD = BSIM4xjbvd * exp(-BSIM4bvd / Nvtmd);
                    end
                    1: begin
                        BSIM4vjdmFwd=BSIM4DioIjthVjmEval(Nvtmd, BSIM4ijthdfwd, DrainSatCurrent, 0.0);  
                        BSIM4IVjdmFwd = DrainSatCurrent * exp(BSIM4vjdmFwd / Nvtmd);
                    end
                    2: begin
                        if ((BSIM4bvd / Nvtmd) > `EXP_THRESHOLD) 
                            BSIM4XExpBVD = BSIM4xjbvd * `MIN_EXP;
                        else begin
                            BSIM4XExpBVD = exp(-BSIM4bvd / Nvtmd);
                            BSIM4XExpBVD = BSIM4XExpBVD * BSIM4xjbvd;
                        end
                        BSIM4vjdmFwd=BSIM4DioIjthVjmEval(Nvtmd, BSIM4ijthdfwd, DrainSatCurrent, BSIM4XExpBVD); 
        
                        T0 = exp(BSIM4vjdmFwd / Nvtmd);
                        BSIM4IVjdmFwd = DrainSatCurrent * (T0 - BSIM4XExpBVD / T0
                                        + BSIM4XExpBVD - 1.0);
                        BSIM4DslpFwd = DrainSatCurrent
                                        * (T0 + BSIM4XExpBVD / T0) / Nvtmd;
                 
                        T2 = BSIM4ijthdrev / DrainSatCurrent;
                        if (T2 < 1.0) begin
                            T2 = 10.0;
                            $strobe("Warning: (instance X*) ijthdrev too small and set to 10 times IdbSat.\n");
                        end 
                        BSIM4vjdmRev = -BSIM4bvd - Nvtmd * ln((T2 - 1.0) 
                                      / BSIM4xjbvd);
                        T1 = BSIM4xjbvd * exp(-(BSIM4bvd + BSIM4vjdmRev) / Nvtmd);
                        BSIM4IVjdmRev = DrainSatCurrent * (1.0 + T1);
                        BSIM4DslpRev = -DrainSatCurrent * T1 / Nvtmd;
                    end
                    default:
                        $strobe("Specified dioMod = %d not matched\n", BSIM4dioMod);
                endcase
        
            end 
		/* GEDL current reverse bias */
	        T0 = (TRatio - 1.0);
                BSIM4njtsstemp = BSIM4njts * (1.0 + BSIM4tnjts * T0);
                BSIM4njtsswstemp = BSIM4njtssw * (1.0 + BSIM4tnjtssw * T0);
                BSIM4njtsswgstemp = BSIM4njtsswg * (1.0 + BSIM4tnjtsswg * T0);
                BSIM4njtsdtemp = BSIM4njtsd * (1.0 + BSIM4tnjtsd * T0);
                BSIM4njtsswdtemp = BSIM4njtsswd * (1.0 + BSIM4tnjtsswd * T0);
                BSIM4njtsswgdtemp = BSIM4njtsswgd * (1.0 + BSIM4tnjtsswgd * T0);
                T7 = Eg0 / BSIM4vtm * T0;
                T9 = BSIM4xtss * T7;
                `DEXP(T9, T1)
                T9 = BSIM4xtsd * T7;
                `DEXP(T9, T2)
                T9 = BSIM4xtssws * T7;
                `DEXP(T9, T3)
                T9 = BSIM4xtsswd * T7;
                `DEXP(T9, T4)
                T9 = BSIM4xtsswgs * T7;
                `DEXP(T9, T5)
                T9 = BSIM4xtsswgd * T7;
                `DEXP(T9, T6)
			/*IBM TAT*/
		if(BSIM4jtweff < 0.0) begin
		  BSIM4jtweff = 0.0;
	          $strobe("TAT width dependence effect is negative. Jtweff is clamped to zero.\n");
	          end 
		T11 = sqrt(BSIM4jtweff / BSIM4weffCJ) + 1.0;

		T10 = BSIM4weffCJ * BSIM4nf;
		BSIM4SjctTempRevSatCur = T1 * BSIM4Aseff * BSIM4jtss;
		BSIM4DjctTempRevSatCur = T2 * BSIM4Adeff * BSIM4jtsd;
		BSIM4SswTempRevSatCur = T3 * BSIM4Pseff * BSIM4jtssws;
		BSIM4DswTempRevSatCur = T4 * BSIM4Pdeff * BSIM4jtsswd;
		BSIM4SswgTempRevSatCur = T5 * T10 * T11 * BSIM4jtsswgs;
		BSIM4DswgTempRevSatCur = T6 * T10 * T11 * BSIM4jtsswgd;

            if(BSIM4mtrlmod != 0 && BSIM4mtrlcompatmod == 0)
		begin 
		    /* Calculate TOXP from EOT */
		    /* Calculate Vgs_eff @ Vgs = VDD with Poly Depletion Effect */		
                    Vtm0eot = `KboQ * BSIM4tempeot;
		    Vtmeot  = Vtm0eot;
		    vbieot = Vtm0eot * ln(BSIM4nsd
			           * BSIM4ndep / (ni * ni));
		    phieot = Vtm0eot * ln(BSIM4ndep / ni)
				   + BSIM4phin + 0.4;			
		    tmp2 = BSIM4vfb + phieot;
		    vddeotl = BSIM4type * BSIM4vddeot;
		    T0 = BSIM4epsrgate * `EPS0;
		    if ((BSIM4ngate > 1.0e18) && (BSIM4ngate < 1.0e25) 
			&& (vddeotl > tmp2) && (T0!=0))
		      begin
			T1 = 1.0e6 * `P_Q * T0 * BSIM4ngate / 
			  (BSIM4coxe * BSIM4coxe);
			T8 = vddeotl - tmp2;
			T4 = sqrt(1.0 + 2.0 * T8 / T1);
			T2 = 2.0 * T8 / (T4 + 1.0);
			T3 = 0.5 * T2 * T2 / T1;
			T7 = 1.12 - T3 - 0.05;
			T6 = sqrt(T7 * T7 + 0.224);
			T5 = 1.12 - 0.5 * (T7 + T6);
			Vgs_eff = vddeotl - T5;
		      end
		    else 
		      Vgs_eff = vddeotl;
		    
		    /* Calculate Vth @ Vds=Vbs=0 */
			
		    V0 = vbieot - phieot;
		    lt1 = BSIM4factor1* BSIM4sqrtXdep0;
		    ltw = lt1;
		    T0 = BSIM4dvt1 * BSIM4leffeot / lt1;
		    if (T0 < `EXP_THRESHOLD)
		      begin   
			T1 = exp(T0);
			T2 = T1 - 1.0;
			T3 = T2 * T2;
			T4 = T3 + 2.0 * T1 * `MIN_EXP;
			Theta0 = T1 / T4;
		      end
		    else
		      Theta0 = 1.0 / (`MAX_EXP - 2.0);
		    Delt_vth = BSIM4dvt0 * Theta0 * V0;
		    T0 = BSIM4dvt1w * BSIM4weffeot * BSIM4leffeot / ltw;
		    if (T0 < `EXP_THRESHOLD) begin
                      T1 = exp(T0);
		      T2 = T1 - 1.0;
		      T3 = T2 * T2;
		      T4 = T3 + 2.0 * T1 * `MIN_EXP;
		      T5 = T1 / T4;
		    end
		    else
		      T5 = 1.0 / (`MAX_EXP - 2.0); /* 3.0 * MIN_EXP omitted */
		    T2 = BSIM4dvt0w * T5 * V0;
		    TempRatioeot =  BSIM4tempeot / BSIM4tnom - 1.0;
		    T0 = sqrt(1.0 + BSIM4lpe0 / BSIM4leffeot);
		    T1 = BSIM4k1ox * (T0 - 1.0) * sqrt(phieot)
		      + (BSIM4kt1 + BSIM4kt1l / BSIM4leffeot) * TempRatioeot;
		    Vth_NarrowW = toxel * phieot
	              / (BSIM4weffeot + BSIM4w0);
		    Lpe_Vb = sqrt(1.0 + BSIM4lpeb / BSIM4leffeot);
		    Vth = BSIM4type * BSIM4vth0 + 
		      (BSIM4k1ox - BSIM4k1)*sqrt(phieot)*Lpe_Vb
		      - Delt_vth - T2 + BSIM4k3 * Vth_NarrowW + T1;
		    
		    /* Calculate n */
		    tmp1 = epssubl / BSIM4Xdep0;
		    tmp2 = BSIM4nfactor * tmp1;
		    tmp3 = (tmp2 + BSIM4cdsc * Theta0 + BSIM4cit) / BSIM4coxe;
		    if (tmp3 >= -0.5)
		      n = 1.0 + tmp3;
		    else begin   
			T0 = 1.0 / (3.0 + 8.0 * tmp3);
			n = (1.0 + 3.0 * tmp3) * T0;
		    end
 
		    /* Vth correction for Pocket implant */
		    if (BSIM4dvtp0 > 0.0)
		      begin   
			T3 = BSIM4leffeot + BSIM4dvtp0 * 2.0;
			if (BSIM4tempMod < 2)
			  T4 = Vtmeot * ln(BSIM4leffeot / T3);
			else
			  T4 = Vtm0eot * ln(BSIM4leffeot / T3);
			Vth = Vth - n * T4;
		      end
		    Vgsteff = Vgs_eff-Vth;
	            /* calculating Toxp */
	            T3 = BSIM4type * BSIM4vth0 - BSIM4vfb - phieot;
                    T4 = T3 + T3;
                    T5 = 2.5 * T3;
                    
                    vtfbphi2eot = 4.0 * T3;
                    if (vtfbphi2eot < 0.0)
                        vtfbphi2eot = 0.0;

		    niter = 0;
		    toxpf = toxel;
                    toxpi = 0.0;
		    while ((niter<=4) && (abs(toxpf-toxpi)>1e-12))
		      begin
			toxpi = toxpf;
			tmp2 = 2.0e8 * toxpf;
			T0 = (Vgsteff + vtfbphi2eot) / tmp2;
			T1 = 1.0 + exp(BSIM4bdos * 0.7 * ln(T0));
			Tcen = BSIM4ados * 1.9e-9 / T1;
			toxpf = toxel - epsroxl/BSIM4epsrsub * Tcen;
			niter = niter+1;
                        if(verbose == 1)
                          $strobe("niter,toxpf,toxpi=%g,%g,%g\n",niter,toxpf,toxpi);
		      end
		      BSIM4toxp = toxpf;  //changed code order to fix
		      BSIM4coxp = epsroxl * `EPS0 / BSIM4toxp;
	    end 
            //else {
	    //	  here->BSIM4toxp = model->BSIM4toxp;
	    //	  here->BSIM4coxp = model->BSIM4coxp;
            //}            
            if(verbose == 1) begin
              $strobe("New model param check starts...\n");
              $strobe("Topology Selection: rdsmod=%d rgatemod=%d rbodymod=%d\n", BSIM4rdsMod, BSIM4rgateMod, BSIM4rbodyMod);
            end
            if ((BSIM4version-4.8) > 0.0001) 
                $strobe("\nWarning: (instance X*) The latest version is BSIM4.8.0; you specified a wrong version number.\n");
    
            if ((BSIM4rgateMod == 2) || (BSIM4rgateMod == 3)) begin
                if ((BSIM4trnqsMod == 1) || (BSIM4acnqsMod == 1))
                    $strobe("Warning: (instance X*) You've selected both Rg and charge deficit NQS; select one only.\n");
            end 
    
            if (BSIM4toxe <= 0.0) begin
                $strobe("Fatal: Toxe = %g is not positive.\n", BSIM4toxe);
                Fatal_Flag = 1;
            end 
            if (BSIM4toxp <= 0.0) begin
                $strobe("Fatal: Toxp = %g is not positive.\n", BSIM4toxp);
                Fatal_Flag = 1;
            end 
        if (BSIM4eot <= 0.0) begin
            $strobe("Fatal: EOT = %g is not positive.\n", BSIM4eot);
            Fatal_Flag = 1;
        end
        if (BSIM4epsrgate < 0.0)
        begin   
            $strobe("Fatal: Epsrgate = %g is not positive.\n", BSIM4epsrgate);
            Fatal_Flag = 1;
        end
        if (BSIM4epsrsub < 0.0)
        begin   
            $strobe("Fatal: Epsrsub = %g is not positive.\n", BSIM4epsrsub);
            Fatal_Flag = 1;
        end
        if (BSIM4easub < 0.0)
        begin   
            $strobe("Fatal: Easub = %g is not positive.\n", BSIM4easub);
            Fatal_Flag = 1;
        end
        if (BSIM4ni0sub <= 0.0)
        begin   
            $strobe("Fatal: Easub = %g is not positive.\n", BSIM4ni0sub);
            Fatal_Flag = 1;
        end
    
            if (BSIM4toxm <= 0.0)
            begin
                $strobe("Fatal: Toxm = %g is not positive.\n", BSIM4toxm);
                Fatal_Flag = 1;
            end
    
            if (BSIM4toxref <= 0.0) begin
                $strobe("Fatal: Toxref = %g is not positive.\n", BSIM4toxref);
                Fatal_Flag = 1;
            end 
    
            if (BSIM4lpe0 < -BSIM4leff) begin
                $strobe("Fatal: Lpe0 = %g is less than -Leff.\n", BSIM4lpe0);
                Fatal_Flag = 1;
            end 
            if (BSIM4lpeb < -BSIM4leff) begin
                $strobe("Fatal: Lpeb = %g is less than -Leff.\n", BSIM4lpeb);
                Fatal_Flag = 1;
            end 
    
            if (BSIM4phin < -0.4) begin
                $strobe("Fatal: Phin = %g is less than -0.4.\n", BSIM4phin);
                Fatal_Flag = 1;
            end 
            if (BSIM4ndep <= 0.0) begin
                $strobe("Fatal: Ndep = %g is not positive.\n", BSIM4ndep);
                Fatal_Flag = 1;
            end 
        if (BSIM4phi <= 0.0)
        begin   
            $strobe("Fatal: Phi = %g is not positive. Please check Phin and Ndep\n", BSIM4phi);
            $strobe("	   Phin = %g  Ndep = %g \n", 
            	    BSIM4phin, BSIM4ndep);
            Fatal_Flag = 1;
        end
            
            if (BSIM4nsub <= 0.0) begin
                $strobe("Fatal: Nsub = %g is not positive.\n", BSIM4nsub);
                Fatal_Flag = 1;
            end 
            
            if (BSIM4ngate < 0.0) begin
                $strobe("Fatal: Ngate = %g Ngate is not positive.\n", BSIM4ngate);
                Fatal_Flag = 1;
            end 
            if (BSIM4ngate > 1.0e25) begin
                $strobe("Fatal: Ngate = %g Ngate is too high\n", BSIM4ngate);
                Fatal_Flag = 1;
            end 
            if (BSIM4xj <= 0.0) begin
                $strobe("Fatal: Xj = %g is not positive.\n", BSIM4xj);
                Fatal_Flag = 1;
            end 
            if (BSIM4dvt1 < 0.0) begin
                $strobe("Fatal: Dvt1 = %g is negative.\n", BSIM4dvt1);   
                Fatal_Flag = 1;
            end 
            if (BSIM4dvt1w < 0.0) begin
                $strobe("Fatal: Dvt1w = %g is negative.\n", BSIM4dvt1w);
                Fatal_Flag = 1;
            end 
            if (BSIM4w0 == -BSIM4weff) begin
                $strobe("Fatal: (W0 + Weff) = 0 causing divided-by-zero.\n");
                Fatal_Flag = 1;
            end    
            if (BSIM4dsub < 0.0) begin
                $strobe("Fatal: Dsub = %g is negative.\n", BSIM4dsub);
                Fatal_Flag = 1;
            end 
            if (BSIM4b1 == -BSIM4weff) begin
                $strobe("Fatal: (B1 + Weff) = 0 causing divided-by-zero.\n");
                Fatal_Flag = 1;
            end   
            if (here_BSIM4u0temp <= 0.0) begin
                $strobe("Fatal: u0 at current temperature = %g is not positive.\n", here_BSIM4u0temp);      
                Fatal_Flag = 1;
            end 
            if (BSIM4delta < 0.0) begin
                $strobe("Fatal: Delta = %g is less than zero.\n", BSIM4delta);
                Fatal_Flag = 1;
            end       
            if (here_BSIM4vsattemp <= 0.0) begin
                $strobe("Fatal: Vsat at current temperature = %g is not positive.\n", here_BSIM4vsattemp);
                Fatal_Flag = 1;
            end 
            if (BSIM4pclm <= 0.0) begin
                $strobe("Fatal: Pclm = %g is not positive.\n", BSIM4pclm);
                Fatal_Flag = 1;
            end 
            if (BSIM4drout < 0.0) begin
                $strobe("Fatal: Drout = %g is negative.\n", BSIM4drout);
                Fatal_Flag = 1;
            end 
            if (BSIM4pscbe2 <= 0.0) begin
                $strobe("Warning: (instance X*) Pscbe2 = %g is not positive.\n", BSIM4pscbe2);
            end 
    
            if (BSIM4nf < 1.0) begin
                $strobe("Fatal: Number of finger = %g is smaller than one.\n", BSIM4nf);
                Fatal_Flag = 1;
            end
        if((BSIM4sa > 0.0) && (BSIM4sb > 0.0) && 
       	((BSIM4nf == 1.0) || ((BSIM4nf > 1.0) && (BSIM4sd > 0.0))) )
        begin   
          if (BSIM4saref <= 0.0)
            begin  
             	$strobe("Fatal: SAref = %g is not positive.\n",BSIM4saref);
             	Fatal_Flag = 1;
            end
          if (BSIM4sbref <= 0.0)
            begin   
            	$strobe("Fatal: SBref = %g is not positive.\n",BSIM4sbref);
            	Fatal_Flag = 1;
            end
 	end            
            if ((BSIM4l + BSIM4xl) <= BSIM4xgl) begin
                $strobe("Fatal: The parameter xgl must be smaller than Ldrawn+XL.\n");
                Fatal_Flag = 1;
            end 
            if (BSIM4ngcon < 1.0) begin
                $strobe("Fatal: The parameter ngcon cannot be smaller than one.\n");
                Fatal_Flag = 1;
            end 
            if ((BSIM4ngcon != 1.0) && (BSIM4ngcon != 2.0)) begin
                BSIM4ngcon = 1.0;
                $strobe("Warning: (instance X*) Ngcon must be equal to one or two; reset to 1.0.\n");
            end 
            if (BSIM4gbmin < 1.0e-20) 
                $strobe("Warning: (instance X*) Gbmin = %g is too small.\n", BSIM4gbmin);
            if (BSIM4noff < 0.1) 
                $strobe("Warning: (instance X*) Noff = %g is too small.\n", BSIM4noff);
            if (BSIM4noff > 4.0) 
                $strobe("Warning: (instance X*) Noff = %g is too large.\n", BSIM4noff);
            if (BSIM4voffcv < -0.5) 
                $strobe("Warning: (instance X*) Voffcv = %g is too small.\n", BSIM4voffcv);
            if (BSIM4voffcv > 0.5)
                $strobe("Warning: (instance X*) Voffcv = %g is too large.\n", BSIM4voffcv);
    
            /* Check capacitance parameters */
            if (BSIM4clc < 0.0) begin
                $strobe("Fatal: Clc = %g is negative.\n", BSIM4clc);
                Fatal_Flag = 1;
            end      
        /* Check overlap capacitance parameters */
        if (BSIM4ckappas < 0.02)
        begin  
            $strobe("Warning: ckappas = %g is too small.\n", BSIM4ckappas);
            BSIM4ckappas = 0.02;
       end
        if (BSIM4ckappad < 0.02)
        begin   
            $strobe("Warning: ckappad = %g is too small.\n", BSIM4ckappad);
            BSIM4ckappad = 0.02;
        end
	if (BSIM4vtss < 0.0)
	begin   
	    $strobe("Fatal: Vtss = %g is negative.\n",
			BSIM4vtss);
	    Fatal_Flag = 1;
	end
	if (BSIM4vtsd < 0.0)
	begin  
	    $strobe("Fatal: Vtsd = %g is negative.\n",
		    BSIM4vtsd);
	    Fatal_Flag = 1;
	end
	if (BSIM4vtssws < 0.0)
	begin   
	    $strobe("Fatal: Vtssws = %g is negative.\n",
		    BSIM4vtssws);
	    Fatal_Flag = 1;
	end
	if (BSIM4vtsswd < 0.0)
	begin   
	    $strobe("Fatal: Vtsswd = %g is negative.\n",
		    BSIM4vtsswd);
	    Fatal_Flag = 1;
	end
	if (BSIM4vtsswgs < 0.0)
	begin   
	    $strobe("Fatal: Vtsswgs = %g is negative.\n",
		    BSIM4vtsswgs);
	    Fatal_Flag = 1;
	end
	if (BSIM4vtsswgd < 0.0)
	begin   
	    $strobe("Fatal: Vtsswgd = %g is negative.\n",
			BSIM4vtsswgd);
	    Fatal_Flag = 1;
	end
            
            if (BSIM4moin < 5.0)
                $strobe("Warning: (instance X*) Moin = %g is too small.\n", BSIM4moin);
            if (BSIM4moin > 25.0)
                $strobe("Warning: (instance X*) Moin = %g is too large.\n", BSIM4moin);
            if(BSIM4capMod ==2) begin
                if (BSIM4acde < 0.1)
                    $strobe("Warning: (instance X*) Acde = %g is too small.\n", BSIM4acde);
                if (BSIM4acde > 1.6)
                    $strobe("Warning: (instance X*) Acde = %g is too large.\n", BSIM4acde);
            end
    
            if (BSIM4paramChk ==1) begin
            
            /* Check L and W parameters */ 
            if (BSIM4leff <= 1.0e-9) 
                $strobe("Warning: (instance X*) Leff = %g <= 1.0e-9. Recommended Leff >= 1e-8 \n", BSIM4leff);
            if (BSIM4leffCV <= 1.0e-9)
                $strobe("Warning: (instance X*) Leff for CV = %g <= 1.0e-9. Recommended LeffCV >=1e-8 \n", BSIM4leffCV);
            if (BSIM4weff <= 1.0e-9)
                $strobe("Warning: (instance X*) Weff = %g <= 1.0e-9. Recommended Weff >=1e-7 \n", BSIM4weff);
            if (BSIM4weffCV <= 1.0e-9)
                $strobe("Warning: (instance X*) Weff for CV = %g <= 1.0e-9. Recommended WeffCV >= 1e-7 \n", BSIM4weffCV);
            
            /* Check threshold voltage parameters */
            if (BSIM4toxe < 1.0e-10)
                $strobe("Warning: (instance X*) Toxe = %g is less than 1A. Recommended Toxe >= 5A\n", BSIM4toxe);
            if (BSIM4toxp < 1.0e-10)
                $strobe("Warning: (instance X*) Toxp = %g is less than 1A. Recommended Toxp >= 5A\n", BSIM4toxp);
            if (BSIM4toxm < 1.0e-10)
                $strobe("Warning: (instance X*) Toxm = %g is less than 1A. Recommended Toxm >= 5A\n", BSIM4toxm);
            if (BSIM4ndep <= 1.0e12)
                $strobe("Warning: (instance X*) Ndep = %g may be too small.\n", BSIM4ndep);
            else if (BSIM4ndep >= 1.0e21)
                $strobe("Warning: (instance X*) Ndep = %g may be too large.\n", BSIM4ndep);
            if (BSIM4nsub <= 1.0e14)
                $strobe("Warning: (instance X*) Nsub = %g may be too small.\n", BSIM4nsub);
            else if (BSIM4nsub >= 1.0e21)
                $strobe("Warning: (instance X*) Nsub = %g may be too large.\n", BSIM4nsub);
            if ((BSIM4ngate > 0.0) &&  (BSIM4ngate <= 1.0e18))
                $strobe("Warning: (instance X*) Ngate = %g is less than 1.E18cm^-3.\n", BSIM4ngate);
            if (BSIM4dvt0 < 0.0)
                $strobe("Warning: (instance X*) Dvt0 = %g is negative.\n", BSIM4dvt0);   
            if (abs(1.0e-6 / (BSIM4w0 + BSIM4weff)) > 10.0)
                $strobe("Warning: (instance X*) (W0 + Weff) may be too small.\n");
    
            /* Check subthreshold parameters */
            if (BSIM4nfactor < 0.0)
              begin
              $strobe("Warning: (instance X*) Nfactor = %g is negative.\n", BSIM4nfactor);
              end 
            if (BSIM4cdsc < 0.0)
              begin
              $strobe("Warning: (instance X*) Cdsc = %g is negative.\n", BSIM4cdsc);
              end 
            if (BSIM4cdscd < 0.0)
              begin
              $strobe("Warning: (instance X*) Cdscd = %g is negative.\n", BSIM4cdscd);
              end 
            /* Check DIBL parameters */
            if (BSIM4eta0 < 0.0)
              begin
              $strobe("Warning: (instance X*) Eta0 = %g is negative.\n", BSIM4eta0); 
              end 
            
            /* Check Abulk parameters */        
            if (abs(1.0e-6 / (BSIM4b1 + BSIM4weff)) > 10.0)
              begin
              $strobe("Warning: (instance X*) (B1 + Weff) may be too small.\n");
              end     
            
            /* Check Saturation parameters */
            if (BSIM4a2 < 0.01)
              begin
              $strobe("Warning: (instance X*) A2 = %g is too small. Set to 0.01.\n", BSIM4a2);
              BSIM4a2 = 0.01;
              end 
            else if (BSIM4a2 > 1.0)
              begin
              $strobe("Warning: (instance X*) A2 = %g is larger than 1. A2 is set to 1 and A1 is set to 0.\n", BSIM4a2);
              BSIM4a2 = 1.0;
              BSIM4a1 = 0.0;
    
              end 
    
            if (BSIM4prwg < 0.0)
              begin
              $strobe("Warning: (instance X*) Prwg = %g is negative. Set to zero.\n", BSIM4prwg);
              BSIM4prwg = 0.0;
              end 
            if (BSIM4rdsw < 0.0)
              begin
              $strobe("Warning: (instance X*) Rdsw = %g is negative. Set to zero.\n", BSIM4rdsw);
              BSIM4rdsw = 0.0;
              BSIM4rds0 = 0.0;
              end 
            if (BSIM4rds0 < 0.0)
              begin
              $strobe("Warning: (instance X*) Rds at current temperature = %g is negative. Set to zero.\n", BSIM4rds0);
              BSIM4rds0 = 0.0;
              end 
    
            if (BSIM4rdswmin < 0.0)
              begin
              $strobe("Warning: (instance X*) Rdswmin at current temperature = %g is negative. Set to zero.\n", BSIM4rdswmin);
              BSIM4rdswmin = 0.0;
              end 
    
            if (BSIM4vsattemp < 1.0e3)
              begin
              $strobe("Warning: (instance X*) Vsat at current temperature = %g may be too small.\n", BSIM4vsattemp);
              end 
    
            if (BSIM4fprout < 0.0)
              begin
              $strobe("Fatal: fprout = %g is negative.\n", BSIM4fprout);
              Fatal_Flag = 1;
              end 
            if (BSIM4pdits < 0.0)
               begin
              $strobe("Fatal: pdits = %g is negative.\n", BSIM4pdits);
              Fatal_Flag = 1;
               end 
            if (BSIM4pditsl < 0.0)
               begin
              $strobe("Fatal: pditsl = %g is negative.\n", BSIM4pditsl);
              Fatal_Flag = 1;
               end 
    
            if (BSIM4pdibl1 < 0.0)
               begin
              $strobe("Warning: (instance X*) Pdibl1 = %g is negative.\n", BSIM4pdibl1);
               end 
            if (BSIM4pdibl2 < 0.0)
               begin
              $strobe("Warning: (instance X*) Pdibl2 = %g is negative.\n", BSIM4pdibl2);
               end 
    
            if (BSIM4nigbinv <= 0.0)
               begin
              $strobe("Fatal: nigbinv = %g is non-positive.\n", BSIM4nigbinv);
              Fatal_Flag = 1;
               end 
            if (BSIM4nigbacc <= 0.0)
               begin
              $strobe("Fatal: nigbacc = %g is non-positive.\n", BSIM4nigbacc);
              Fatal_Flag = 1;
               end 
            if (BSIM4nigc <= 0.0)
               begin
              $strobe("Fatal: nigc = %g is non-positive.\n", BSIM4nigc);
              Fatal_Flag = 1;
               end 
            if (BSIM4poxedge <= 0.0)
               begin
              $strobe("Fatal: poxedge = %g is non-positive.\n", BSIM4poxedge);
              Fatal_Flag = 1;
               end 
            if (BSIM4pigcd <= 0.0)
               begin
              $strobe("Fatal: pigcd = %g is non-positive.\n", BSIM4pigcd);
              Fatal_Flag = 1;
               end 

       /* Check stress effect parameters */        
        if((BSIM4sa > 0.0) && (BSIM4sb > 0.0) && 
       	((BSIM4nf == 1.0) || ((BSIM4nf > 1.0) && (BSIM4sd > 0.0))) )
        begin   
            if (BSIM4lodk2 <= 0.0)
            begin   
                $strobe("Warning: LODK2 = %g is not positive.\n",BSIM4lodk2);
            end
            if (BSIM4lodeta0 <= 0.0)
            begin   
            	$strobe("Warning: LODETA0 = %g is not positive.\n",BSIM4lodeta0);
            end
 	end

        /* Check gate resistance parameters */        
        if (BSIM4rgateMod == 1)
        begin   if (BSIM4rshg <= 0.0)
	        $strobe("Warning: rshg should be positive for rgateMod = 1.\n");
	end
        else if (BSIM4rgateMod == 2)
        begin   
            if (BSIM4rshg <= 0.0)
                $strobe("Warning: rshg <= 0.0 for rgateMod = 2.\n");
            else if (BSIM4xrcrg1 <= 0.0)
                     $strobe("Warning: xrcrg1 <= 0.0 for rgateMod = 2.\n");
         end
        if (BSIM4rgateMod == 3)
        begin   
            if (BSIM4rshg <= 0.0)
                $strobe("Warning: rshg should be positive for rgateMod = 3.\n");
            else if (BSIM4xrcrg1 <= 0.0)
                     $strobe("Warning: xrcrg1 should be positive for rgateMod = 3.\n");
         end
         
         /* Check body resistance parameters */ 
        if (BSIM4rbps0 <= 0.0)
	begin   
	    $strobe("Fatal: RBPS0 = %g is not positive.\n", BSIM4rbps0);
	    Fatal_Flag = 1;
	end
        if (BSIM4rbpd0 <= 0.0)
	begin   
	    $strobe("Fatal: RBPD0 = %g is not positive.\n", BSIM4rbpd0);
	    Fatal_Flag = 1;
	end
        if (BSIM4rbpbx0 <= 0.0)
	begin   
	    $strobe("Fatal: RBPBX0 = %g is not positive.\n", BSIM4rbpbx0);
	    Fatal_Flag = 1;
	end
        if (BSIM4rbpby0 <= 0.0)
	begin   
	    $strobe("Fatal: RBPBY0 = %g is not positive.\n", BSIM4rbpby0);
	    Fatal_Flag = 1;
	end
        if (BSIM4rbdbx0 <= 0.0)
	begin   
	    $strobe("Fatal: RBDBX0 = %g is not positive.\n", BSIM4rbdbx0);
	    Fatal_Flag = 1;
	end
        if (BSIM4rbdby0 <= 0.0)
	begin   
	    $strobe("Fatal: RBDBY0 = %g is not positive.\n", BSIM4rbdby0);
	    Fatal_Flag = 1;
	end
        if (BSIM4rbsbx0 <= 0.0)
	begin   
	    $strobe("Fatal: RBSBX0 = %g is not positive.\n", BSIM4rbsbx0);
	    Fatal_Flag = 1;
	end
	    if (BSIM4rbsby0 <= 0.0)
	begin   
	    $strobe("Fatal: RBSBY0 = %g is not positive.\n", BSIM4rbsby0);
	    Fatal_Flag = 1;
	end
	
        /* Check capacitance parameters */
        if (BSIM4noff < 0.1)
            $strobe("Warning: Noff = %g is too small.\n", BSIM4noff);

        if (BSIM4voffcv < -0.5)
            $strobe("Warning: Voffcv = %g is too small.\n", BSIM4voffcv);
        if (BSIM4moin < 5.0)
            $strobe("Warning: Moin = %g is too small.\n", BSIM4moin);
        if (BSIM4moin > 25.0)
            $strobe("Warning: Moin = %g is too large.\n", BSIM4moin);
	if(BSIM4capMod ==2) begin
        	if (BSIM4acde < 0.1)
            	  $strobe("Warning: Acde = %g is too small.\n", BSIM4acde);
        	if (BSIM4acde > 1.6)
            	  $strobe("Warning: Acde = %g is too large.\n", BSIM4acde);
	end
               
        /* Check overlap capacitance parameters */
        if (BSIM4cgdo < 0.0)
           begin
          $strobe("Warning: (instance X*) cgdo = %g is negative. Set to zero.\n", BSIM4cgdo);
          BSIM4cgdo = 0.0;
           end       
        if (BSIM4cgso < 0.0)
           begin
          $strobe("Warning: (instance X*) cgso = %g is negative. Set to zero.\n", BSIM4cgso);
          BSIM4cgso = 0.0;
           end       
    
        if (BSIM4tnoia < 0.0)
           begin
          $strobe("Warning: (instance X*) tnoia = %g is negative. Set to zero.\n", BSIM4tnoia);
          BSIM4tnoia = 0.0;
           end 
        if (BSIM4tnoib < 0.0)
           begin
          $strobe("Warning: (instance X*) tnoib = %g is negative. Set to zero.\n", BSIM4tnoib);
          BSIM4tnoib = 0.0;
           end 
        if (BSIM4ntnoi < 0.0)
           begin
          $strobe("Warning: (instance X*) ntnoi = %g is negative. Set to zero.\n", BSIM4ntnoi);
          BSIM4ntnoi = 0.0;
           end 
	/* Limits of Njs and Njd modified in BSIM4.7 */
	if (BSIM4SjctEmissionCoeff < 0.1) begin
	    $strobe("Warning: Njs = %g is less than 0.1. Setting Njs to 0.1.\n", BSIM4SjctEmissionCoeff);
	    BSIM4SjctEmissionCoeff = 0.1;
	end 
	else if (BSIM4SjctEmissionCoeff < 0.7) begin 
	    $strobe("Warning: Njs = %g is less than 0.7.\n", BSIM4SjctEmissionCoeff);
	end
	if (BSIM4DjctEmissionCoeff < 0.1) begin 
	    $strobe("Warning: Njd = %g is less than 0.1. Setting Njd to 0.1.\n", BSIM4DjctEmissionCoeff);
	    BSIM4DjctEmissionCoeff = 0.1;
	end
	else if (BSIM4DjctEmissionCoeff < 0.7) begin
	    $strobe("Warning: Njd = %g is less than 0.7.\n", BSIM4DjctEmissionCoeff);
	end

	if (BSIM4njtsstemp < 0.0)
	begin   
	    $strobe("Warning: Njts = %g is negative at temperature = %g.\n",
                   BSIM4njtsstemp, T);
	end
	if (BSIM4njtsswstemp < 0.0)
	begin   
	    $strobe("Warning: Njtssw = %g is negative at temperature = %g.\n",
	    BSIM4njtsswstemp, T);
	end
	if (BSIM4njtsswgstemp < 0.0)
	begin   
	    $strobe("Warning: Njtsswg = %g is negative at temperature = %g.\n",
		    BSIM4njtsswgstemp, T);
	end

	if (BSIM4njtsdGiven && BSIM4njtsdtemp < 0.0)
	begin   
	    $strobe("Warning: Njtsd = %g is negative at temperature = %g.\n",
		    BSIM4njtsdtemp, T);
	end
	if (BSIM4njtsswdGiven && BSIM4njtsswdtemp < 0.0)
	begin   
	    $strobe("Warning: Njtsswd = %g is negative at temperature = %g.\n",
		    BSIM4njtsswdtemp, T);
	end
	if (BSIM4njtsswgdGiven && BSIM4njtsswgdtemp < 0.0)
	begin   
	    $strobe("Warning: Njtsswgd = %g is negative at temperature = %g.\n",
		    BSIM4njtsswgdtemp, T);
	end

       if (BSIM4ntnoi < 0.0)
        begin   
            $strobe("Warning: ntnoi = %g is negative. Set to zero.\n", BSIM4ntnoi);
            BSIM4ntnoi = 0.0;
        end

        /* diode model */
       if (BSIM4SbulkJctBotGradingCoeff >= 0.99)
        begin   
            $strobe("Warning: MJS = %g is too big. Set to 0.99.\n", BSIM4SbulkJctBotGradingCoeff);
            BSIM4SbulkJctBotGradingCoeff = 0.99;
        end
       if (BSIM4SbulkJctSideGradingCoeff >= 0.99)
        begin   
            $strobe("Warning: MJSWS = %g is too big. Set to 0.99.\n", BSIM4SbulkJctSideGradingCoeff);
            BSIM4SbulkJctSideGradingCoeff = 0.99;
        end
       if (BSIM4SbulkJctGateSideGradingCoeff >= 0.99)
        begin   
            $strobe("Warning: MJSWGS = %g is too big. Set to 0.99.\n", BSIM4SbulkJctGateSideGradingCoeff);
            BSIM4SbulkJctGateSideGradingCoeff = 0.99;
        end

       if (BSIM4DbulkJctBotGradingCoeff >= 0.99)
        begin   
            $strobe("Warning: MJD = %g is too big. Set to 0.99.\n", BSIM4DbulkJctBotGradingCoeff);
            BSIM4DbulkJctBotGradingCoeff = 0.99;
        end
       if (BSIM4DbulkJctSideGradingCoeff >= 0.99)
        begin   
            $strobe("Warning: MJSWD = %g is too big. Set to 0.99.\n", BSIM4DbulkJctSideGradingCoeff);
            BSIM4DbulkJctSideGradingCoeff = 0.99;
        end
       if (BSIM4DbulkJctGateSideGradingCoeff >= 0.99)
        begin   
            $strobe("Warning: MJSWGD = %g is too big. Set to 0.99.\n", BSIM4DbulkJctGateSideGradingCoeff);
            BSIM4DbulkJctGateSideGradingCoeff = 0.99;
        end
	if (BSIM4wpemod == 1)
	begin
		if (BSIM4scref <= 0.0)
		begin   
		    $strobe("Warning: SCREF = %g is not positive. Set to 1e-6.\n", BSIM4scref);
		    BSIM4scref = 1e-6;
		end
				
	end
    
            end // if (BSIM4paramChk ==1)
            else 
            $strobe("Warning: (instance X*) Can't open log file; parameter checking skipped.\n");
           
        end // initial_step

        if(verbose == 1)
          $strobe("New model main evaluation starts...\n");
        //New model main evaluation starts

        // Get voltages:      
        vds  = BSIM4type * V(di,si);
        vgs  = BSIM4type * V(gi,si);
        vbs  = BSIM4type * V(bi,si); 
        vges = BSIM4type * V(g,si);
        vgms = BSIM4type * V(gm,si);
//`ifdef __RBODYMOD__
        vdbs = BSIM4type * V(dbulk,si);
        vsbs = BSIM4type * V(sbulk,si);
//`else
//        vdbs = vbs;
//        vsbs = vbs;
//`endif
        vses = BSIM4type * V(s,si);
        vdes = BSIM4type * V(d,si);
        if(verbose == 1)
          $strobe("Volts:%g,%g,%g,%g,%g,%g,%g,%g,%g\n",vds,vgs,vbs,vges,vgms,vdbs,vsbs,vses,vdes);


        /* Calculate DC currents and their derivatives */
        vbd = vbs - vds;
        vgd = vgs - vds;
        vgb = vgs - vbs;
        vged = vges - vds;
        vgmd = vgms - vds;
        vgmb = vgms - vbs;
        vdbd = vdbs - vds;
        
        vbs_jct = (!BSIM4rbodyMod) ? vbs : vsbs;
        vbd_jct = (!BSIM4rbodyMod) ? vbd : vdbd;

        /* Source/drain junction diode DC model begins */
        Nvtms = BSIM4vtm * BSIM4SjctEmissionCoeff;
        if ((BSIM4Aseff <= 0.0) && (BSIM4Pseff <= 0.0)) begin
            SourceSatCurrent = 0.0;
        end 
        else begin
            SourceSatCurrent = BSIM4Aseff * BSIM4SjctTempSatCurDensity
                           + BSIM4Pseff * BSIM4SjctSidewallTempSatCurDensity
                           + BSIM4weffCJ * BSIM4nf
                           * BSIM4SjctGateSidewallTempSatCurDensity;
        end 

        if (SourceSatCurrent <= 0.0) begin
            BSIM4gbs = _ckt_gmin;
            BSIM4cbs = BSIM4gbs * vbs_jct;
        end 
        else begin
            case (BSIM4dioMod)
                0: begin
                    evbs = exp(vbs_jct / Nvtms);
                    T1 = BSIM4xjbvs * exp(-(BSIM4bvs + vbs_jct) / Nvtms);
                    // WDLiu: Magic T1 in this form; different from BSIM4 beta. 
                    BSIM4gbs = SourceSatCurrent * (evbs + T1) / Nvtms + _ckt_gmin;
		    BSIM4cbs = SourceSatCurrent * (evbs + BSIM4XExpBVS
				     - T1 - 1.0) + _ckt_gmin * vbs_jct;
                end
                1: begin
                    T2 = vbs_jct / Nvtms;
                    if (T2 < -`EXP_THRESHOLD) begin
                        BSIM4gbs = _ckt_gmin; 
                        BSIM4cbs = SourceSatCurrent * (`MIN_EXP - 1.0)
                                         + _ckt_gmin * vbs_jct;
                    end    
                    else if (vbs_jct <= BSIM4vjsmFwd) begin
                        evbs = exp(T2);
                        BSIM4gbs = SourceSatCurrent * evbs / Nvtms + _ckt_gmin;
                        BSIM4cbs = SourceSatCurrent * (evbs - 1.0)
                                         + _ckt_gmin * vbs_jct;
                    end 
                    else begin
                        T0 = BSIM4IVjsmFwd / Nvtms;
                        BSIM4gbs = T0 + _ckt_gmin;
                        BSIM4cbs = BSIM4IVjsmFwd - SourceSatCurrent + T0 
					 * (vbs_jct - BSIM4vjsmFwd) + _ckt_gmin * vbs_jct;                        
                    end     
                end
                2: begin
                    if (vbs_jct < BSIM4vjsmRev) begin
                        T0 = vbs_jct / Nvtms;
                        if (T0 < -`EXP_THRESHOLD) begin
                            evbs = `MIN_EXP;
                            devbs_dvb = 0.0;
                        end 
                        else begin
                            evbs = exp(T0);
                            devbs_dvb = evbs / Nvtms;
                        end

                        T1 = evbs - 1.0;
                        T2 = BSIM4IVjsmRev + BSIM4SslpRev *
                            (vbs_jct - BSIM4vjsmRev);
                        BSIM4gbs = devbs_dvb * T2 + T1 * BSIM4SslpRev + _ckt_gmin;
                        BSIM4cbs = T1 * T2 + _ckt_gmin * vbs_jct;
                    end          
                    else if (vbs_jct <= BSIM4vjsmFwd) begin
                        T0 = vbs_jct / Nvtms;
                        if (T0 < -`EXP_THRESHOLD) begin
                            evbs = `MIN_EXP;
                            devbs_dvb = 0.0;
                        end 
                        else begin
                            evbs = exp(T0);
                            devbs_dvb = evbs / Nvtms;
                        end

                        T1 = (BSIM4bvs + vbs_jct) / Nvtms;
                        if (T1 > `EXP_THRESHOLD) begin
                            T2 = `MIN_EXP;
                            T3 = 0.0;
                        end 
                        else begin
                            T2 = exp(-T1);
                            T3 = -T2 /Nvtms;
                        end 
                        BSIM4gbs = SourceSatCurrent * (devbs_dvb - 
                            BSIM4xjbvs * T3) + _ckt_gmin;
			BSIM4cbs = SourceSatCurrent * (evbs + BSIM4XExpBVS - 1.0
				         - BSIM4xjbvs * T2) + _ckt_gmin * vbs_jct;                        
                    end 
                    else begin
                        BSIM4gbs = BSIM4SslpFwd + _ckt_gmin;
                        BSIM4cbs = BSIM4IVjsmFwd + BSIM4SslpFwd * (vbs_jct
					 - BSIM4vjsmFwd) + _ckt_gmin * vbs_jct;
                    end
                end // case: 2
            endcase // case(BSIM4dioMod)

        end // else: !if(SourceSatCurrent <= 0.0)

        Nvtmd = BSIM4vtm * BSIM4DjctEmissionCoeff;
        if ((BSIM4Adeff <= 0.0) && (BSIM4Pdeff <= 0.0))
            DrainSatCurrent = 0.0;
        else
            DrainSatCurrent = BSIM4Adeff * BSIM4DjctTempSatCurDensity
                  + BSIM4Pdeff * BSIM4DjctSidewallTempSatCurDensity
                  + BSIM4weffCJ * BSIM4nf
                  * BSIM4DjctGateSidewallTempSatCurDensity;
        
        if (DrainSatCurrent <= 0.0) begin
            BSIM4gbd = _ckt_gmin;
            BSIM4cbd = BSIM4gbd * vbd_jct;
        end
        else begin
            case (BSIM4dioMod)
                0: begin
                    evbd = exp(vbd_jct / Nvtmd);   
                    T1 = BSIM4xjbvd * exp(-(BSIM4bvd + vbd_jct) / Nvtmd);
                    // WDLiu: Magic T1 in this form; different from BSIM4 beta. 
                    BSIM4gbd = DrainSatCurrent * (evbd + T1) / Nvtmd + _ckt_gmin;
                    BSIM4cbd = DrainSatCurrent * (evbd + BSIM4XExpBVD
                                     - T1 - 1.0) + _ckt_gmin * vbd_jct;
                end
                1: begin
                    T2 = vbd_jct / Nvtmd;
                    if (T2 < -`EXP_THRESHOLD) begin
                        BSIM4gbd = _ckt_gmin;
                        BSIM4cbd = DrainSatCurrent * (`MIN_EXP - 1.0)
                                         + _ckt_gmin * vbd_jct;
                    end
                    else if (vbd_jct <= BSIM4vjdmFwd) begin
                        evbd = exp(T2);
                        BSIM4gbd = DrainSatCurrent * evbd / Nvtmd + _ckt_gmin;
                        BSIM4cbd = DrainSatCurrent * (evbd - 1.0)
                                         + _ckt_gmin * vbd_jct;
                    end 
                    else begin
                        T0 = BSIM4IVjdmFwd / Nvtmd;
                        BSIM4gbd = T0 + _ckt_gmin;
                        BSIM4cbd = BSIM4IVjdmFwd - DrainSatCurrent + T0
                                         * (vbd_jct - BSIM4vjdmFwd) + _ckt_gmin * vbd_jct;
                    end 
                end
                2: begin
                    if (vbd_jct < BSIM4vjdmRev) begin
                        T0 = vbd_jct / Nvtmd;
                        if (T0 < -`EXP_THRESHOLD) begin
                            evbd = `MIN_EXP;
                            devbd_dvb = 0.0;
                        end 
                        else begin
                            evbd = exp(T0);
                            devbd_dvb = evbd / Nvtmd;
                        end

                        T1 = evbd - 1.0;
                        T2 = BSIM4IVjdmRev + BSIM4DslpRev *
                            (vbd_jct - BSIM4vjdmRev);
                        BSIM4gbd = devbd_dvb * T2 + T1 * BSIM4DslpRev + _ckt_gmin;
                        BSIM4cbd = T1 * T2 + _ckt_gmin * vbd_jct;
                    end 
                    else if (vbd_jct <= BSIM4vjdmFwd) begin
                        T0 = vbd_jct / Nvtmd;
                        if (T0 < -`EXP_THRESHOLD) begin
                            evbd = `MIN_EXP;
                            devbd_dvb = 0.0;
                        end 
                        else begin
                            evbd = exp(T0);
                            devbd_dvb = evbd / Nvtmd;
                        end

                        T1 = (BSIM4bvd + vbd_jct) / Nvtmd;
                        if (T1 > `EXP_THRESHOLD) begin
                            T2 = `MIN_EXP;
                            T3 = 0.0;
                        end 
                        else begin
                            T2 = exp(-T1);
                            T3 = -T2 /Nvtmd;
                        end      
                        BSIM4gbd = DrainSatCurrent * (devbd_dvb - BSIM4xjbvd *
                            T3) + _ckt_gmin;
                        BSIM4cbd = DrainSatCurrent * (evbd + BSIM4XExpBVD - 1.0
                                         - BSIM4xjbvd * T2) + _ckt_gmin * vbd_jct;
                    end 
                    else begin
                        BSIM4gbd = BSIM4DslpFwd + _ckt_gmin;
                        BSIM4cbd = BSIM4IVjdmFwd + BSIM4DslpFwd * (vbd_jct
                                         - BSIM4vjdmFwd) + _ckt_gmin * vbd_jct;
                    end 
                end
            endcase 
        end // else: !if(DrainSatCurrent <= 0.0)

	/* trap-assisted tunneling and recombination current for reverse bias  */
        Nvtmrssws = Vtm0 * BSIM4njtsswstemp;
        Nvtmrsswgs = Vtm0 * BSIM4njtsswgstemp;
        Nvtmrss = Vtm0 * BSIM4njtsstemp;
        Nvtmrsswd = Vtm0 * BSIM4njtsswdtemp;
        Nvtmrsswgd = Vtm0 * BSIM4njtsswgdtemp;
        Nvtmrsd = Vtm0 * BSIM4njtsdtemp;

        if ((BSIM4vtss - vbs_jct) < (BSIM4vtss * 1e-3))
        begin 
          T9 = 1.0e3; 
          T0 = - vbs_jct / Nvtmrss * T9;
          `DEXP2(T0, T1, T10)
          dT1_dVb = T10 / Nvtmrss * T9; 
        end else begin
          T9 = 1.0 / (BSIM4vtss - vbs_jct);
          T0 = -vbs_jct / Nvtmrss * BSIM4vtss * T9;
          dT0_dVb = BSIM4vtss / Nvtmrss * (T9 + vbs_jct * T9 * T9) ;
          `DEXP2(T0, T1, T10)
          dT1_dVb = T10 * dT0_dVb;
        end

       if ((BSIM4vtsd - vbd_jct) < (BSIM4vtsd * 1e-3) )
        begin T9 = 1.0e3;
          T0 = -vbd_jct / Nvtmrsd * T9;
          `DEXP2(T0, T2, T10)
          dT2_dVb = T10 / Nvtmrsd * T9; 
        end else begin
          T9 = 1.0 / (BSIM4vtsd - vbd_jct);
          T0 = -vbd_jct / Nvtmrsd * BSIM4vtsd * T9;
          dT0_dVb = BSIM4vtsd / Nvtmrsd * (T9 + vbd_jct * T9 * T9) ;
          `DEXP2(T0, T2, T10)
          dT2_dVb = T10 * dT0_dVb;
        end

        if ((BSIM4vtssws - vbs_jct) < (BSIM4vtssws * 1e-3) )
        begin T9 = 1.0e3; 
          T0 = -vbs_jct / Nvtmrssws * T9;
          `DEXP2(T0, T3, T10)
          dT3_dVb = T10 / Nvtmrssws * T9; 
        end else begin
          T9 = 1.0 / (BSIM4vtssws - vbs_jct);
          T0 = -vbs_jct / Nvtmrssws * BSIM4vtssws * T9;
          dT0_dVb = BSIM4vtssws / Nvtmrssws * (T9 + vbs_jct * T9 * T9) ;
          `DEXP2(T0, T3, T10)
          dT3_dVb = T10 * dT0_dVb;
        end

        if ((BSIM4vtsswd - vbd_jct) < (BSIM4vtsswd * 1e-3) )
        begin T9 = 1.0e3; 
          T0 = -vbd_jct / Nvtmrsswd * T9;
          `DEXP2(T0, T4, T10)
          dT4_dVb = T10 / Nvtmrsswd * T9; 
        end else begin
          T9 = 1.0 / (BSIM4vtsswd - vbd_jct);
          T0 = -vbd_jct / Nvtmrsswd * BSIM4vtsswd * T9;
          dT0_dVb = BSIM4vtsswd / Nvtmrsswd * (T9 + vbd_jct * T9 * T9) ;
          `DEXP2(T0, T4, T10)
          dT4_dVb = T10 * dT0_dVb;
        end

        if ((BSIM4vtsswgs - vbs_jct) < (BSIM4vtsswgs * 1e-3) )
        begin T9 = 1.0e3; 
          T0 = -vbs_jct / Nvtmrsswgs * T9;
          `DEXP2(T0, T5, T10)
          dT5_dVb = T10 / Nvtmrsswgs * T9; 
        end else begin
          T9 = 1.0 / (BSIM4vtsswgs - vbs_jct);
          T0 = -vbs_jct / Nvtmrsswgs * BSIM4vtsswgs * T9;
          dT0_dVb = BSIM4vtsswgs / Nvtmrsswgs * (T9 + vbs_jct * T9 * T9) ;
          `DEXP2(T0, T5, T10)
          dT5_dVb = T10 * dT0_dVb;
        end

        if ((BSIM4vtsswgd - vbd_jct) < (BSIM4vtsswgd * 1e-3) )
        begin T9 = 1.0e3; 
          T0 = -vbd_jct / Nvtmrsswgd * T9;
          `DEXP2(T0, T6, T10)
          dT6_dVb = T10 / Nvtmrsswgd * T9; 
        end else begin
          T9 = 1.0 / (BSIM4vtsswgd - vbd_jct);
          T0 = -vbd_jct / Nvtmrsswgd * BSIM4vtsswgd * T9;
          dT0_dVb = BSIM4vtsswgd / Nvtmrsswgd * (T9 + vbd_jct * T9 * T9) ;
          `DEXP2(T0, T6, T10)
          dT6_dVb = T10 * dT0_dVb;
        end

	  BSIM4gbs = BSIM4gbs + BSIM4SjctTempRevSatCur * dT1_dVb
	  			+ BSIM4SswTempRevSatCur * dT3_dVb
	  			+ BSIM4SswgTempRevSatCur * dT5_dVb; 
          BSIM4cbs = BSIM4cbs -(BSIM4SjctTempRevSatCur * (T1 - 1.0)
	  			+ BSIM4SswTempRevSatCur * (T3 - 1.0)
	  			+ BSIM4SswgTempRevSatCur * (T5 - 1.0));                                
	  BSIM4gbd = BSIM4gbd + BSIM4DjctTempRevSatCur * dT2_dVb
	  			+ BSIM4DswTempRevSatCur * dT4_dVb
	  			+ BSIM4DswgTempRevSatCur * dT6_dVb; 
	  BSIM4cbd = BSIM4cbd -(BSIM4DjctTempRevSatCur * (T2 - 1.0) 
	  			+ BSIM4DswTempRevSatCur * (T4 - 1.0)
	  			+ BSIM4DswgTempRevSatCur * (T6 - 1.0));                                
        if(verbose == 1) begin
          $strobe("BSIM4cbd,s=%g,%g\n", BSIM4cbd, BSIM4cbs);
          $strobe("BSIM4cbd's RHS=%g,%g,%g,%g,%g,%g\n", BSIM4DjctTempRevSatCur,BSIM4DswTempRevSatCur, BSIM4DswgTempRevSatCur,T2,T4,T6);
        end
        /* End of diode DC model */
        
        if (vds >= 0.0) begin
            BSIM4mode = 1;
            Vds = vds;
            Vgs = vgs;
            Vbs = vbs;
            Vdb = vds - vbs;  /* WDLiu: for GIDL */
        end 
        else begin
            BSIM4mode = -1;
            Vds = -vds;
            Vgs = vgd;
            Vbs = vbd;
            Vdb = -vbs;
        end 

        T0 = Vbs - here_BSIM4vbsc - 0.001;
        T1 = sqrt(T0 * T0 - 0.004 * here_BSIM4vbsc);
        if (T0 >= 0.0)
            Vbseff = here_BSIM4vbsc + 0.5 * (T0 + T1);
        else begin
            T2 = -0.002 / (T1 - T0);
            Vbseff = here_BSIM4vbsc * (1.0 + T2);
        end 
        if(verbose == 1) begin
          $strobe("Vbseff=%g,%g,%g,%g,%g\n", Vbseff,Vds,Vgs,Vbs,Vdb);
          $strobe("gbs,d=%g,%g\n", BSIM4gbs,BSIM4gbd);
        end

        /* JX: Correction to forward body bias */
        T9 = 0.95 * BSIM4phi;
        T0 = T9 - Vbseff - 0.001;
        T1 = sqrt(T0 * T0 + 0.004 * T9);
        Vbseff = T9 - 0.5 * (T0 + T1);

        Phis = BSIM4phi - Vbseff;
        sqrtPhis = sqrt(Phis);
        if(verbose == 1)
          $strobe("Vbseff=%g\n", Vbseff);
        
        Xdep = BSIM4Xdep0 * sqrtPhis / BSIM4sqrtPhi;

        Leff = BSIM4leff;
        Vtm = BSIM4vtm;
        if(verbose == 1) begin
          $strobe("Leff=%g\n", Leff);
          $strobe("Vtm=%g\n", Vtm);
          $strobe("BSIM4phi=%g\n", BSIM4phi);
          $strobe("Xdep=%g\n", Xdep);
          $strobe("here_BSIM4vbsc=%g\n", here_BSIM4vbsc);
          $strobe("DrainSatCurrent,SourceSatCurrent=%g,%g\n", DrainSatCurrent, SourceSatCurrent);
        end

`ifdef NOISE_DERIVATIVES
        if(verbose == 1)
          $strobe("analysis(noise)=%g\n", analysis("noise"));
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if (T0 >= 0.0)
                dVbseff_dVb = 0.5 * (1.0 + T0 / T1);
            else
                dVbseff_dVb = T2 * here_BSIM4vbsc / T1;

            if (Vbseff > 0.0) begin
                T0 = BSIM4phi / (BSIM4phi + Vbseff);
                dPhis_dVb = -T0 * T0;
                dsqrtPhis_dVb = -0.5 * sqrtPhis * sqrtPhis / BSIM4phis3;
            end
            else begin
                dPhis_dVb = -1.0;
                dsqrtPhis_dVb = -0.5 / sqrtPhis;
            end

            dXdep_dVb = (BSIM4Xdep0 / BSIM4sqrtPhi)
                        * dsqrtPhis_dVb;
        end
`endif
        
        /* Vth Calculation */
        T3 = sqrt(Xdep);
        V0 = BSIM4vbi - BSIM4phi;

        T0 = BSIM4dvt2 * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
            T2 = BSIM4dvt2;
        end 
        else begin
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4; 
            T2 = BSIM4dvt2 * T4 * T4;
        end 
        lt1 = BSIM4factor1 * T3 * T1;

        T0 = BSIM4dvt2w * Vbseff;
        if (T0 >= - 0.5) begin
            T1 = 1.0 + T0;
            T2 = BSIM4dvt2w;
        end 
        else begin
            T4 = 1.0 / (3.0 + 8.0 * T0);
            T1 = (1.0 + 3.0 * T0) * T4; 
            T2 = BSIM4dvt2w * T4 * T4;
        end 
        ltw = BSIM4factor1 * T3 * T1;

        T0 = BSIM4dvt1 * Leff / lt1;
        if (T0 < `EXP_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 - 1.0;
            T3 = T2 * T2;
            T4 = T3 + 2.0 * T1 * `MIN_EXP;
            Theta0 = T1 / T4;
        end 
        else
            Theta0 = 1.0 / (`MAX_EXP - 2.0); /* 3.0 * `MIN_EXP omitted */

        BSIM4thetavth = BSIM4dvt0 * Theta0;
        Delt_vth = BSIM4thetavth * V0;
        if(verbose == 1)
          $strobe("Delt_vth=%g,%g,%g,%g,%g\n", Delt_vth, BSIM4dvt0,lt1,BSIM4factor1,BSIM4vbi);

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            T3 = sqrt(Xdep);

            T0 = BSIM4dvt2 * Vbseff;
            if (T0 >= - 0.5) begin
                T1 = 1.0 + T0;
                T2 = BSIM4dvt2;
            end
            else begin
                T4 = 1.0 / (3.0 + 8.0 * T0);
                T1 = (1.0 + 3.0 * T0) * T4;
                T2 = BSIM4dvt2 * T4 * T4;
            end
            dlt1_dVb = BSIM4factor1 * (0.5 / T3 * T1 
                        * dXdep_dVb + T3 * T2);

            T0 = BSIM4dvt2w * Vbseff;
            if (T0 >= - 0.5) begin
                T1 = 1.0 + T0;
                T2 = BSIM4dvt2w;
            end
            else begin
                T4 = 1.0 / (3.0 + 8.0 * T0);
                T1 = (1.0 + 3.0 * T0) * T4;
                T2 = BSIM4dvt2w * T4 * T4;
            end
            dltw_dVb = BSIM4factor1 * (0.5 / T3 * T1 
                        * dXdep_dVb + T3 * T2);

            T0 = BSIM4dvt1 * Leff / lt1;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                dT1_dVb = -T0 * T1 * dlt1_dVb / lt1;
                dTheta0_dVb = dT1_dVb * (T4 - 2.0 * T1 * (T2 + `MIN_EXP)) / T4 / T4;
            end
            else 
                dTheta0_dVb = 0.0;

            dDelt_vth_dVb = BSIM4dvt0 * dTheta0_dVb * V0;
        end
`endif

        T0 = BSIM4dvt1w * BSIM4weff * Leff / ltw;
        if (T0 < `EXP_THRESHOLD) begin
            T1 = exp(T0);
            T2 = T1 - 1.0;
            T3 = T2 * T2;
            T4 = T3 + 2.0 * T1 * `MIN_EXP;
            T5 = T1 / T4;
        end 
        else
            T5 = 1.0 / (`MAX_EXP - 2.0); /* 3.0 * `MIN_EXP omitted */

        T0 = BSIM4dvt0w * T5;
        T2 = T0 * V0;
       
        TempRatio = T / BSIM4tnom - 1.0;
        T0 = sqrt(1.0 + BSIM4lpe0 / Leff);
        T1 = BSIM4k1ox * (T0 - 1.0) * BSIM4sqrtPhi +
            (BSIM4kt1 + BSIM4kt1l / Leff +
            BSIM4kt2 * Vbseff) * TempRatio;
        Vth_NarrowW = toxel * BSIM4phi / (BSIM4weff + BSIM4w0);

        T3 = here_BSIM4eta0 + BSIM4etab * Vbseff;
        if (T3 < 1.0e-4) begin
            T9 = 1.0 / (3.0 - 2.0e4 * T3);
            T3 = (2.0e-4 - T3) * T9;
        end 
        dDIBL_Sft_dVd = T3 * BSIM4theta0vb0;
        DIBL_Sft = dDIBL_Sft_dVd * Vds;

        Lpe_Vb = sqrt(1.0 + BSIM4lpeb / Leff);

        Vth = BSIM4type * here_BSIM4vth0 + (BSIM4k1ox * sqrtPhis -
            BSIM4k1 * BSIM4sqrtPhi) * Lpe_Vb -
            here_BSIM4k2ox * Vbseff - Delt_vth - T2 + (BSIM4k3 +
            BSIM4k3b * Vbseff) * Vth_NarrowW + T1 - DIBL_Sft;      
        if(verbose == 1)
          $strobe("Vth=%g,%g,%g,%g,%g,%g,%g,%g,%g,%g,%g\n", Vth,here_BSIM4vth0,sqrtPhis,Lpe_Vb,here_BSIM4k2ox,
           Vbseff,Delt_vth,T2, Vth_NarrowW,T1,DIBL_Sft);

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
   
            T0 = BSIM4dvt1w * BSIM4weff * Leff / ltw;
            if (T0 < `EXP_THRESHOLD) begin
                T1 = exp(T0);
                T2 = T1 - 1.0;
                T3 = T2 * T2;
                T4 = T3 + 2.0 * T1 * `MIN_EXP;
                T5 = T1 / T4;
                dT1_dVb = -T0 * T1 * dltw_dVb / ltw; /* bugfix -JX */
                dT5_dVb = dT1_dVb * (T4 - 2.0 * T1 * (T2 + `MIN_EXP)) / T4 / T4;
            end
            else
                dT5_dVb = 0.0;

            dT2_dVb = BSIM4dvt0w * dT5_dVb * V0;
      
            dVth_dVb = Lpe_Vb * BSIM4k1ox * dsqrtPhis_dVb 
                       - here_BSIM4k2ox - dDelt_vth_dVb - dT2_dVb 
                       + BSIM4k3b * Vth_NarrowW
                       - BSIM4etab * Vds * BSIM4theta0vb0 * T4
                       + BSIM4kt2 * TempRatio;
            dVth_dVd = -dDIBL_Sft_dVd;

        end
`endif
        
        /* Calculate n */
        tmp1 = `EPSSI / Xdep;
        BSIM4nstar = BSIM4vtm / `P_Q * (BSIM4coxe + tmp1 + BSIM4cit);
        tmp2 = BSIM4nfactor * tmp1;
        tmp3 = BSIM4cdsc + BSIM4cdscb * Vbseff + BSIM4cdscd * Vds;
        tmp4 = (tmp2 + tmp3 * Theta0 + BSIM4cit) / BSIM4coxe;
        if (tmp4 >= -0.5)
            n = 1.0 + tmp4;
        else begin
            T0 = 1.0 / (3.0 + 8.0 * tmp4);
            n = (1.0 + 3.0 * tmp4) * T0;
        end 

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if (tmp4 >= -0.5) begin
                dn_dVb = (-tmp2 / Xdep * dXdep_dVb + tmp3 * dTheta0_dVb
                          + BSIM4cdscb * Theta0) / BSIM4coxe;
                dn_dVd = BSIM4cdscd * Theta0 / BSIM4coxe;
            end
            else begin
                T0 = 1.0 / (3.0 + 8.0 * tmp4);
                n = (1.0 + 3.0 * tmp4) * T0;
                T0 = T0 * (  T0);
                dn_dVb = (-tmp2 / Xdep * dXdep_dVb + tmp3 * dTheta0_dVb
                          + BSIM4cdscb * Theta0) / BSIM4coxe * T0;
                dn_dVd = BSIM4cdscd * Theta0 / BSIM4coxe * T0;
             end
        end
`endif
        if(verbose == 1)
          $strobe("n=%g\n", n);
        
        /* Vth correction for Pocket implant */
        if (BSIM4dvtp0 > 0.0) begin
            T0 = -BSIM4dvtp1 * Vds;
            if (T0 < -`EXP_THRESHOLD)
                T2 = `MIN_EXP;
            else
                T2 = exp(T0);

            T3 = Leff + BSIM4dvtp0 * (1.0 + T2);
            if (BSIM4tempMod < 2)
              T4 = Vtm * ln(Leff / T3);
            else
              T4 = Vtm0 * ln(Leff / T3);
            Vth = Vth - (n * T4);
        end 
`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if (BSIM4dvtp0 > 0.0) begin
                T0 = -BSIM4dvtp1 * Vds;
                if (T0 < -`EXP_THRESHOLD) 
                    dT2_dVd = 0.0;
                else
                    dT2_dVd = -BSIM4dvtp1 * T2;

                dT3_dVd = BSIM4dvtp0 * dT2_dVd;
                dT4_dVd = -Vtm * dT3_dVd / T3;
                dDITS_Sft_dVd = dn_dVd * T4 + n * dT4_dVd;
                dDITS_Sft_dVb = T4 * dn_dVb;

                dVth_dVd = dVth_dVd - (  dDITS_Sft_dVd);
                dVth_dVb = dVth_dVb - (  dDITS_Sft_dVb);
             end
        end
`endif
	/* v4.7 DITS_SFT2  */
	if ((BSIM4dvtp4  == 0.0) || (BSIM4dvtp2factor == 0.0)) begin
	  T0 = 0.0;
  	  DITS_Sft2 = 0.0;   
	end
	else 
	  begin
	  //T0 = exp(2.0 * BSIM4dvtp4 * Vds);   /* beta code */
	  T1 = 2.0 * BSIM4dvtp4 * Vds;
	  `DEXP2(T1, T0, T10)
  	  DITS_Sft2 = BSIM4dvtp2factor * (T0-1) / (T0+1);   
	  //dDITS_Sft2_dVd = BSIM4dvtp2factor * BSIM4dvtp4 * 4.0 * T0 / ((T0+1) * (T0+1));   /* beta code */
	  dDITS_Sft2_dVd = BSIM4dvtp2factor * BSIM4dvtp4 * 4.0 * T10 / ((T0+1) * (T0+1));
	  Vth = Vth - DITS_Sft2;
	  dVth_dVd = dVth_dVd - dDITS_Sft2_dVd;
	end
        if(verbose == 1) 
          $strobe("Vth=%g\n", Vth);      

        /* Poly Gate Si Depletion Effect */
        T0 = here_BSIM4vfb + BSIM4phi;
	if(BSIM4mtrlmod == 0)                 
	    T1 = `EPSSI;
	else
	    T1 = BSIM4epsrgate * `EPS0;        
        if(verbose == 1) begin
          $strobe("T0,T1=%g,%g\n", T0, T1);
        end

        `BSIM4polyDepletion(T0, BSIM4ngate,T1, BSIM4coxe, vgs, vgs_eff, dvgs_eff_dvg)
        
        `BSIM4polyDepletion(T0, BSIM4ngate,T1, BSIM4coxe, vgd, vgd_eff, dvgd_eff_dvg)
        
        if(BSIM4mode > 0)
            Vgs_eff = vgs_eff;
        else 
            Vgs_eff = vgd_eff;

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if (BSIM4mode>0) 
                dVgs_eff_dVg = dvgs_eff_dvg;
            else
                dVgs_eff_dVg = dvgd_eff_dvg;
        end
`endif

        Vgst = Vgs_eff - Vth;
        if(verbose == 1) begin
          $strobe("T0,T1=%g,%g\n", T0, T1);
          $strobe("Vgst=%g,%g,%g\n", Vgst,Vgs_eff,vgs,vgd);
          $strobe("Vgs,d_eff=%g,%g\n", vgs_eff, vgd_eff);
        end
        
        /* Calculate Vgsteff */
        T0 = n * Vtm;
        T1 = BSIM4mstar * Vgst;
        T2 = T1 / T0;
        if (T2 > `EXP_THRESHOLD)
            T10 = T1;
        else if (T2 < -`EXP_THRESHOLD) begin
            T10 = Vtm * ln(1.0 + `MIN_EXP);
            T10 = T10 * n;
        end 
        else begin
            ExpVgst = exp(T2);
            T3 = Vtm * ln(1.0 + ExpVgst);
            T10 = n * T3;
        end 

        T1 = BSIM4voffcbn - (1.0 - BSIM4mstar) * Vgst;
        T2 = T1 / T0;
        if (T2 < -`EXP_THRESHOLD) begin
            T3 = BSIM4coxe * `MIN_EXP / BSIM4cdep0;
            T9 = BSIM4mstar + T3 * n;
        end 
        else if (T2 > `EXP_THRESHOLD) begin
            T3 = BSIM4coxe * `MAX_EXP / BSIM4cdep0;
            T9 = BSIM4mstar + T3 * n;
        end 
        else begin
            ExpVgst = exp(T2);
            T3 = BSIM4coxe / BSIM4cdep0;
            T4 = T3 * ExpVgst;
            T5 = T1 * T4 / T0;
            T9 = BSIM4mstar + n * T4;
        end 

        Vgsteff = T10 / T9;
        here_Vgsteff = Vgsteff;

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            T0 = n * Vtm;
            T1 = BSIM4mstar * Vgst;
            T2 = T1 / T0;
            if (T2 > `EXP_THRESHOLD) begin
                T10 = T1;
                dT10_dVg = BSIM4mstar * dVgs_eff_dVg;
                dT10_dVd = -dVth_dVd * BSIM4mstar;
                dT10_dVb = -dVth_dVb * BSIM4mstar;
            end
            else if (T2 < -`EXP_THRESHOLD) begin
                T10 = Vtm * ln(1.0 + `MIN_EXP);
                dT10_dVg = 0.0;
                dT10_dVd = T10 * dn_dVd;
                dT10_dVb = T10 * dn_dVb;
                T10 = T10 * n;
            end
            else begin
                ExpVgst = exp(T2);
                T3 = Vtm * ln(1.0 + ExpVgst);
                T10 = n * T3;
                dT10_dVg = BSIM4mstar * ExpVgst / (1.0 + ExpVgst);
                dT10_dVb = T3 * dn_dVb - dT10_dVg * (dVth_dVb + Vgst * dn_dVb / n);
                dT10_dVd = T3 * dn_dVd - dT10_dVg * (dVth_dVd + Vgst * dn_dVd / n);
                dT10_dVg = dT10_dVg * (  dVgs_eff_dVg);
            end

            T1 = BSIM4voffcbn - (1.0 - BSIM4mstar) * Vgst;
            T2 = T1 / T0;
            if (T2 < -`EXP_THRESHOLD) begin
                T3 = BSIM4coxe * `MIN_EXP / BSIM4cdep0;
                T9 = BSIM4mstar + T3 * n;
                dT9_dVg = 0.0;
                dT9_dVd = dn_dVd * T3;
                dT9_dVb = dn_dVb * T3;
            end
            else if (T2 > `EXP_THRESHOLD) begin
                T3 = BSIM4coxe * `MAX_EXP / BSIM4cdep0;
                T9 = BSIM4mstar + T3 * n;
                dT9_dVg = 0.0;
                dT9_dVd = dn_dVd * T3;
                dT9_dVb = dn_dVb * T3;
            end
            else begin
                ExpVgst = exp(T2);
                T3 = BSIM4coxe / BSIM4cdep0;
                T4 = T3 * ExpVgst;
                T5 = T1 * T4 / T0;
                T9 = BSIM4mstar + n * T4;
                dT9_dVg = T3 * (BSIM4mstar - 1.0) * ExpVgst / Vtm;
                dT9_dVb = T4 * dn_dVb - dT9_dVg * dVth_dVb - T5 * dn_dVb;
                dT9_dVd = T4 * dn_dVd - dT9_dVg * dVth_dVd - T5 * dn_dVd;
                dT9_dVg = dT9_dVg * (  dVgs_eff_dVg);
            end
            T11 = T9 * T9;
            dVgsteff_dVg = (T9 * dT10_dVg - T10 * dT9_dVg) / T11;
            dVgsteff_dVd = (T9 * dT10_dVd - T10 * dT9_dVd) / T11;
            dVgsteff_dVb = (T9 * dT10_dVb - T10 * dT9_dVb) / T11;

        end
`endif
        if(verbose == 1) 
        $strobe("Vgsteff=%g\n", Vgsteff);
        
        /* Calculate Effective Channel Geometry */
        T9 = sqrtPhis - BSIM4sqrtPhi;
        Weff = BSIM4weff - 2.0 * (BSIM4dwg * Vgsteff + BSIM4dwb * T9); 

    /* to avoid the discontinuity problem due to Weff*/
        if (Weff < 2.0e-8) begin
            T0 = 1.0 / (6.0e-8 - 2.0 * Weff);
            Weff = 2.0e-8 * (4.0e-8 - Weff) * T0;
            T0 = T0 * (T0 * 4.0e-16);
        end 
`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            dWeff_dVg = -2.0 * BSIM4dwg;
            dWeff_dVb = -2.0 * BSIM4dwb * dsqrtPhis_dVb;

            if (Weff < 2.0e-8) begin
                T0 = T0 * T0 * 4.0e-16;
                dWeff_dVg = dWeff_dVg * T0;
                dWeff_dVb = dWeff_dVb * T0;
            end
        end
`endif
        if(verbose == 1) 
        $strobe("Weff=%g\n", Weff);

        if (BSIM4rdsMod == 1)
            Rds = 0.0;
        else begin
            T0 = 1.0 + BSIM4prwg * Vgsteff;
            T1 = BSIM4prwb * T9;
            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01); /* 0.01 = 4.0 * 0.05 * 0.05 */
            T4 = BSIM4rds0 * 0.5;
            Rds = BSIM4rdswmin + T3 * T4;
            if (Rds > 0.0)
                //grdsw = 1.0 / (Rds * BSIM4nf);
                grdsw = 1.0 / Rds* BSIM4nf; /*4.6.2 */
            else
                grdsw = 0.0;
        end 
`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if (BSIM4rdsMod == 1) begin
               dRds_dVg = 0.0;
               dRds_dVb = 0.0;
            end
            else begin
                T0 = 1.0 + BSIM4prwg * Vgsteff;
                dT0_dVg = -BSIM4prwg / T0 / T0;
                T1 = BSIM4prwb * T9;
                dT1_dVb = BSIM4prwb * dsqrtPhis_dVb;
                T2 = 1.0 / T0 + T1;
                T3 = T2 + sqrt(T2 * T2 + 0.01); /* 0.01 = 4.0 * 0.05 * 0.05 */
                dT3_dVg = 1.0 + T2 / (T3 - T2);
                dT3_dVb = dT3_dVg * dT1_dVb;
                dT3_dVg = dT3_dVg * (  dT0_dVg);
                T4 = BSIM4rds0 * 0.5;
                dRds_dVg = T4 * dT3_dVg;
                dRds_dVb = T4 * dT3_dVb;
            end
        end
`endif
        if(verbose == 1) 
        $strobe("Rds=%g\n", Rds);
        
        /* Calculate Abulk */
        T9 = 0.5 * BSIM4k1ox * Lpe_Vb / sqrtPhis;
        T1 = T9 + here_BSIM4k2ox - BSIM4k3b * Vth_NarrowW;
        T9 = sqrt(BSIM4xj * Xdep);
        tmp1 = Leff + 2.0 * T9;
        T5 = Leff / tmp1; 
        tmp2 = BSIM4a0 * T5;
        tmp3 = BSIM4weff + BSIM4b1; 
        tmp4 = BSIM4b0 / tmp3;
        T2 = tmp2 + tmp4;
        T7 = T5 * T5 * T5;
        Abulk0 = 1.0 + T1 * T2; 
        T8 = BSIM4ags * BSIM4a0 * T7;
        dAbulk_dVg = -T1 * T8;
        Abulk = Abulk0 + dAbulk_dVg * Vgsteff; 

    /* added to avoid the problems caused by Abulk0 */
        if (Abulk0 < 0.1) begin
            T9 = 1.0 / (3.0 - 20.0 * Abulk0);
            Abulk0 = (0.2 - Abulk0) * T9;
        end 

        if (Abulk < 0.1) begin
            T9 = 1.0 / (3.0 - 20.0 * Abulk);
            Abulk = (0.2 - Abulk) * T9;
            T10 = T9 * T9;
            dAbulk_dVg = dAbulk_dVg * T10;
        end 
        here_Abulk = Abulk;

        T2 = BSIM4keta * Vbseff;
        if (T2 >= -0.9)
            T0 = 1.0 / (1.0 + T2);
        else begin
            T1 = 1.0 / (0.8 + T2);
            T0 = (17.0 + 20.0 * T2) * T1;
        end 
        Abulk = Abulk * T0;
        Abulk0 = Abulk0 * T0;

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            T9 = 0.5 * BSIM4k1ox * Lpe_Vb / sqrtPhis;
            T1 = T9 + here_BSIM4k2ox - BSIM4k3b * Vth_NarrowW;
            dT1_dVb = -T9 / sqrtPhis * dsqrtPhis_dVb;

            T9 = sqrt(BSIM4xj * Xdep);
            tmp1 = Leff + 2.0 * T9;
            T5 = Leff / tmp1;
            tmp2 = BSIM4a0 * T5;
            tmp3 = BSIM4weff + BSIM4b1;
            tmp4 = BSIM4b0 / tmp3;
            T2 = tmp2 + tmp4;
            dT2_dVb = -T9 / tmp1 / Xdep * dXdep_dVb;
            T6 = T5 * T5;
            T7 = T5 * T6;
          
            dAbulk0_dVb = T1 * tmp2 * dT2_dVb + T2 * dT1_dVb;
          
            dAbulk_dVb = dAbulk0_dVb - T8 * Vgsteff * (dT1_dVb
                              + 3.0 * T1 * dT2_dVb);
          
            if (Abulk0 < 0.1) begin
                T9 = 1.0 / (3.0 - 20.0 * Abulk0);
                dAbulk0_dVb = dAbulk0_dVb * T9 * T9;
            end

            if (Abulk < 0.1) begin
                T9 = 1.0 / (3.0 - 20.0 * Abulk);
                T10 = T9 * T9;
                dAbulk_dVb = dAbulk_dVb * T10;
            end
          
            T2 = BSIM4keta * Vbseff;
            if (T2 >= -0.9) begin
                T0 = 1.0 / (1.0 + T2);
                dT0_dVb = -BSIM4keta * T0 * T0;
            end
            else begin
                T1 = 1.0 / (0.8 + T2);
                T0 = (17.0 + 20.0 * T2) * T1;
                dT0_dVb = -BSIM4keta * T1 * T1;
            end
            dAbulk_dVg = dAbulk_dVg * (  T0);
            dAbulk_dVb = dAbulk_dVb * T0 + Abulk * dT0_dVb;
            dAbulk0_dVb = dAbulk0_dVb * T0 + Abulk0 * dT0_dVb;
        end
`endif

        if(verbose == 1) begin 
          $strobe("Abulk,0=%g,%g\n", Abulk,Abulk0);
        end
        
        /* Mobility calculation */
	if (BSIM4mtrlmod && BSIM4mtrlcompatmod == 0)
	    T14 = 2.0 * BSIM4type *(BSIM4phig - BSIM4easub - 0.5*BSIM4Eg0 + 0.45);   
	  else
	    T14 = 0.0;        
        if (BSIM4mobMod == 0) begin
            T0 = Vgsteff + Vth + Vth - T14;
            T2 = BSIM4ua + BSIM4uc * Vbseff;
            T3 = T0 / toxel;
            T12 = sqrt(Vth * Vth + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * Vth;
            T6 = T8 * Vth;
            T5 = T3 * (T2 + BSIM4ub * T3) + T6;            
        end 
        else if (BSIM4mobMod == 1) begin
            T0 = Vgsteff + Vth + Vth - T14;
            T2 = 1.0 + BSIM4uc * Vbseff;
            T3 = T0 / toxel;
            T4 = T3 * (BSIM4ua + BSIM4ub * T3);
            T12 = sqrt(Vth * Vth + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * Vth;
            T6 = T8 * Vth;
            T5 = T4 * T2 + T6;            
        end 
        else if (BSIM4mobMod == 2) begin
            T0 = (Vgsteff + here_BSIM4vtfbphi1) / toxel;
            T1 = exp(BSIM4eu * ln(T0));
            T2 = BSIM4ua + BSIM4uc * Vbseff;
            T12 = sqrt(Vth * Vth + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * Vth;
            T6 = T8 * Vth;
            T5 = T1 * T2 + T6;
        end 
        else if (BSIM4mobMod == 4) begin
            T0 = Vgsteff + here_BSIM4vtfbphi1 - T14;
            T2 = BSIM4ua + BSIM4uc * Vbseff;
            T3 = T0 / toxel;	  
            T12 = sqrt(here_BSIM4vtfbphi1*here_BSIM4vtfbphi1 + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * here_BSIM4vtfbphi1;
            T6 = T8 * here_BSIM4vtfbphi1;
            T5 = T3 * (T2 + BSIM4ub * T3) + T6;
        end 
        else if (BSIM4mobMod == 5) begin
            T0 = Vgsteff + here_BSIM4vtfbphi1 - T14;
            T2 = 1.0 + BSIM4uc * Vbseff;
            T3 = T0 / toxel;
            T4 = T3 * (BSIM4ua + BSIM4ub * T3);
            T12 = sqrt(here_BSIM4vtfbphi1 * here_BSIM4vtfbphi1 + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * here_BSIM4vtfbphi1;
            T6 = T8 * here_BSIM4vtfbphi1;
            T5 = T4 * T2 + T6;
        end 
        else if (BSIM4mobMod == 6) begin
            T0 = (Vgsteff + here_BSIM4vtfbphi1) / toxel;
            T1 = exp(BSIM4eu * ln(T0));
            T2 = BSIM4ua + BSIM4uc * Vbseff;
            T12 = sqrt(here_BSIM4vtfbphi1 * here_BSIM4vtfbphi1 + 0.0001);
            T9 = 1.0/(Vgsteff + 2*T12);
            T10 = T9*toxel;
            T8 = BSIM4ud * T10 * T10 * here_BSIM4vtfbphi1;
            T6 = T8 * here_BSIM4vtfbphi1;
            T5 = T1 * T2 + T6;
        end 
        /*high K mobility*/
        else begin // mobmod==3, and others
	    /*univsersal mobility*/
	    T0 = (Vgsteff + here_BSIM4vtfbphi1)* 1.0e-8 / toxel / 6.0;
	    T1 = exp(BSIM4eu * ln(T0)); 
	    T2 = BSIM4ua + BSIM4uc * Vbseff;
	    /*Coulombic*/
	    T10 = exp(BSIM4ucs * ln(0.5 + 0.5 * Vgsteff/BSIM4VgsteffVth));
	    T11 =  BSIM4ud/T10;
	    T5 = T1 * T2 + T11;
        end 

        if (T5 >= -0.8)
            Denomi = 1.0 + T5;
        else begin
            T9 = 1.0 / (7.0 + 10.0 * T5);
            Denomi = (0.6 + T5) * T9;
            //T9 = T9 * T9;
        end

        if(verbose == 1) 
          $strobe("T0=%g,T2=%g,T3=%g,T12=%g,T9=%g,T10=%g,T5=%g,T6=%g,T8=%g\n", T0,T2,T3,T12,T9,T10,T5,T6,T8);
        BSIM4ueff = here_BSIM4u0temp / Denomi;
        ueff      = BSIM4ueff;
        if(verbose == 1) 
          $strobe("ueff=%g,here_BSIM4u0temp=%g,Denomi=%g\n", ueff,here_BSIM4u0temp,Denomi);

`ifdef NOISE_DERIVATIVES
        //Enh: not impl mobmod > 2 for Noise
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if (BSIM4mobMod == 0) begin
                T0 = Vgsteff + Vth + Vth;
                T2 = BSIM4ua + BSIM4uc * Vbseff;
                T3 = T0 / toxel;
                T5 = T3 * (T2 + BSIM4ub * T3);
                dDenomi_dVg = (T2 + 2.0 * BSIM4ub * T3) / toxel;
                dDenomi_dVd = dDenomi_dVg * 2.0 * dVth_dVd;
                dDenomi_dVb = dDenomi_dVg * 2.0 * dVth_dVb + BSIM4uc * T3;
            end
            else if (BSIM4mobMod == 1) begin
                T0 = Vgsteff + Vth + Vth;
                T2 = 1.0 + BSIM4uc * Vbseff;
                T3 = T0 / toxel;
                T4 = T3 * (BSIM4ua + BSIM4ub * T3);
                T5 = T4 * T2;
                dDenomi_dVg = (BSIM4ua + 2.0 * BSIM4ub * T3) * T2
                              / toxel;
                dDenomi_dVd = dDenomi_dVg * 2.0 * dVth_dVd;
                dDenomi_dVb = dDenomi_dVg * 2.0 * dVth_dVb + BSIM4uc * T4;
            end
            else begin
                T0 = (Vgsteff + here_BSIM4vtfbphi1) / toxel;
                T1 = exp(BSIM4eu * ln(T0));
                dT1_dVg = T1 * BSIM4eu / T0 / toxel;
                T2 = BSIM4ua + BSIM4uc * Vbseff;
                T5 = T1 * T2;
                dDenomi_dVg = T2 * dT1_dVg;
                dDenomi_dVd = 0.0;
                dDenomi_dVb = T1 * BSIM4uc;
            end

            if (T5 >= -0.8)
                Denomi = 1.0 + T5;
            else begin
                T9 = 1.0 / (7.0 + 10.0 * T5);
                Denomi = (0.6 + T5) * T9;
                T9 = T9 * T9;
                dDenomi_dVg = dDenomi_dVg * T9;
                dDenomi_dVd = dDenomi_dVd * T9;
                dDenomi_dVb = dDenomi_dVb * T9;
            end
      
            T9 = -ueff / Denomi;
            dueff_dVg = T9 * dDenomi_dVg;
            dueff_dVd = T9 * dDenomi_dVd;
            dueff_dVb = T9 * dDenomi_dVb;
        end
`endif

        
        /* Saturation Drain Voltage  Vdsat */
        WVCox = Weff * here_BSIM4vsattemp * BSIM4coxe;
        WVCoxRds = WVCox * Rds; 
        Esat = 2.0 * here_BSIM4vsattemp / ueff;      
        EsatL = Esat * Leff;

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            T0 = -EsatL /ueff;
            dEsatL_dVg = T0 * dueff_dVg;
            dEsatL_dVd = T0 * dueff_dVd;
            dEsatL_dVb = T0 * dueff_dVb;
        end
`endif

        if(verbose == 1) begin 
          $strobe("Esat,L=%g,%g\n", Esat,EsatL);
        end
            
        /* Sqrt() */
        a1l = BSIM4a1;
        if (a1l == 0.0)
            Lambda = BSIM4a2;
        else if (a1l > 0.0) begin
            T0 = 1.0 - BSIM4a2;
            T1 = T0 - BSIM4a1 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * T0);
            Lambda = BSIM4a2 + T0 - 0.5 * (T1 + T2);
        end 
        else begin
            T1 = BSIM4a2 + BSIM4a1 * Vgsteff - 0.0001;
            T2 = sqrt(T1 * T1 + 0.0004 * BSIM4a2);
            Lambda = 0.5 * (T1 + T2);
        end // else: !if(a1 > 0.0)

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if (a1l == 0.0) 
                dLambda_dVg = 0.0;
            else if (a1l > 0.0) 
                dLambda_dVg = 0.5 * BSIM4a1 * (1.0 + T1 / T2);
            else 
                dLambda_dVg = 0.5 * BSIM4a1 * (1.0 + T1 / T2);
        end
`endif

        if(verbose == 1) 
        $strobe("Lambda=%g\n", Lambda);
        
        Vgst2Vtm = Vgsteff + 2.0 * Vtm;
        if ((Rds == 0.0) && (Lambda == 1.0)) begin
            T0 = 1.0 / (Abulk * EsatL + Vgst2Vtm);
            T1 = T0 * T0;
            T2 = Vgst2Vtm * T0;
            T3 = EsatL * Vgst2Vtm;
            Vdsat = T3 * T0;        
        end 
        else begin
            T9 = Abulk * WVCoxRds;
            T8 = Abulk * T9;
            T7 = Vgst2Vtm * T9;
            T6 = Vgst2Vtm * WVCoxRds;
            T0 = 2.0 * Abulk * (T9 - 1.0 + 1.0 / Lambda); 
            T1 = Vgst2Vtm * (2.0 / Lambda - 1.0) + Abulk * EsatL + 3.0 * T7;
            T2 = Vgst2Vtm * (EsatL + 2.0 * T6);
            T3 = sqrt(T1 * T1 - 2.0 * T0 * T2);
            Vdsat = (T1 - T3) / T0;
        end


`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if (Rds > 0) begin
                tmp2 = dRds_dVg / Rds + dWeff_dVg / Weff;
                tmp3 = dRds_dVb / Rds + dWeff_dVb / Weff;
             end
             else begin
                tmp2 = dWeff_dVg / Weff;
                tmp3 = dWeff_dVb / Weff;
             end
             if ((Rds == 0.0) && (Lambda == 1.0)) begin
                 tmp1 = 0.0;
    
                 dT0_dVg = -(Abulk * dEsatL_dVg + EsatL * dAbulk_dVg + 1.0) * T1;
                 dT0_dVd = -(Abulk * dEsatL_dVd) * T1;
                 dT0_dVb = -(Abulk * dEsatL_dVb + dAbulk_dVb * EsatL) * T1;
    
                 dVdsat_dVg = T3 * dT0_dVg + T2 * dEsatL_dVg + EsatL * T0;
                 dVdsat_dVd = T3 * dT0_dVd + T2 * dEsatL_dVd;
                 dVdsat_dVb = T3 * dT0_dVb + T2 * dEsatL_dVb;
             end
             else begin
                 tmp1 = dLambda_dVg / (Lambda * Lambda);
                 dT0_dVg = 2.0 * (T8 * tmp2 - Abulk * tmp1
                             + (2.0 * T9 + 1.0 / Lambda - 1.0) * dAbulk_dVg);

                 dT0_dVb = 2.0 * (T8 * (2.0 / Abulk * dAbulk_dVb + tmp3)
                               + (1.0 / Lambda - 1.0) * dAbulk_dVb);
                 dT0_dVd = 0.0;

                 dT1_dVg = (2.0 / Lambda - 1.0) - 2.0 * Vgst2Vtm * tmp1
                           + Abulk * dEsatL_dVg + EsatL * dAbulk_dVg + 3.0 * 
                           (T9 + T7 * tmp2 + T6 * dAbulk_dVg);
                 dT1_dVb = Abulk * dEsatL_dVb + EsatL * dAbulk_dVb
                           + 3.0 * (T6 * dAbulk_dVb + T7 * tmp3);
                 dT1_dVd = Abulk * dEsatL_dVd;

                 dT2_dVg = EsatL + Vgst2Vtm * dEsatL_dVg
                           + T6 * (4.0 + 2.0 * Vgst2Vtm * tmp2);
                 dT2_dVb = Vgst2Vtm * (dEsatL_dVb + 2.0 * T6 * tmp3);
                 dT2_dVd = Vgst2Vtm * dEsatL_dVd;

                 dT3_dVg = (T1 * dT1_dVg - 2.0 * (T0 * dT2_dVg + T2 * dT0_dVg))
                             / T3;
                 dT3_dVd = (T1 * dT1_dVd - 2.0 * (T0 * dT2_dVd + T2 * dT0_dVd))
                             / T3;
                 dT3_dVb = (T1 * dT1_dVb - 2.0 * (T0 * dT2_dVb + T2 * dT0_dVb))
                             / T3;

                 dVdsat_dVg = (dT1_dVg - (T1 * dT1_dVg - dT0_dVg * T2
                                - T0 * dT2_dVg) / T3 - Vdsat * dT0_dVg) / T0;
                 dVdsat_dVb = (dT1_dVb - (T1 * dT1_dVb - dT0_dVb * T2
                                - T0 * dT2_dVb) / T3 - Vdsat * dT0_dVb) / T0;
                 dVdsat_dVd = (dT1_dVd - (T1 * dT1_dVd - T0 * dT2_dVd) / T3) / T0;
              end
        end
`endif

        if(verbose == 1) 
        $strobe("Vdsat=%g\n", Vdsat);
        
        /* Calculate Vdseff */
        T1 = Vdsat - Vds - BSIM4delta;
        T2 = sqrt(T1 * T1 + 4.0 * BSIM4delta * Vdsat);
        
        T0 = T1 / T2;
        T9 = 2.0 * BSIM4delta;
        T3 = T9 / T2;

        if (T1 >= 0.0)
            Vdseff = Vdsat - 0.5 * (T1 + T2);
        else begin
            T4 = T9 / (T2 - T1);
            T5 = 1.0 - T4;
            T6 = Vdsat * T4 / (T2 - T1);
            Vdseff = Vdsat * T5;
        end

        if (Vds == 0.0)
            Vdseff = 0.0;

        if (Vdseff > Vds)
            Vdseff = Vds;

        diffVds = Vds - Vdseff;
        here_Vdseff = Vdseff;
        if(verbose == 1) 
        $strobe("diffVds=%g\n", diffVds);

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            dT1_dVg = dVdsat_dVg;
            dT1_dVd = dVdsat_dVd - 1.0;
            dT1_dVb = dVdsat_dVb;

            dT2_dVg = T0 * dT1_dVg + T3 * dVdsat_dVg;
            dT2_dVd = T0 * dT1_dVd + T3 * dVdsat_dVd;
            dT2_dVb = T0 * dT1_dVb + T3 * dVdsat_dVb;

            if (T1 >= 0.0) begin
                dVdseff_dVg = dVdsat_dVg - 0.5 * (dT1_dVg + dT2_dVg);
                dVdseff_dVd = dVdsat_dVd - 0.5 * (dT1_dVd + dT2_dVd);
                dVdseff_dVb = dVdsat_dVb - 0.5 * (dT1_dVb + dT2_dVb);
            end
            else begin
                  dVdseff_dVg = dVdsat_dVg * T5 + T6 * (dT2_dVg - dT1_dVg);
                  dVdseff_dVd = dVdsat_dVd * T5 + T6 * (dT2_dVd - dT1_dVd);
                  dVdseff_dVb = dVdsat_dVb * T5 + T6 * (dT2_dVb - dT1_dVb);
            end

            if (Vds == 0.0) begin
                dVdseff_dVg = 0.0;
                dVdseff_dVb = 0.0;
            end
         
        end
`endif

        if(verbose == 1) 
        $strobe("Vdseff=%g\n", Vdseff);

        /* Velocity Overshoot */
        if((BSIM4lambdaGiven) && (BSIM4lambda > 0.0) ) begin
            T1 = Leff * ueff;
            T2 = BSIM4lambda / T1;
            T3 = -T2 / T1 * Leff;
            T5 = 1.0 / (Esat * BSIM4litl);
            T6 = 1.0 + diffVds  * T5;
            T7 = 2.0 / (T6 * T6 + 1.0);     
            T8 = 1.0 - T7;
            T10 = 1.0 + T2 * T8;
            EsatL = EsatL * T10;
            Esat = EsatL / Leff;  /* bugfix by Wenwei Yang (4.6.4) */
        end

        /* Calculate Vasat */
        tmp4 = 1.0 - 0.5 * Abulk * Vdsat / Vgst2Vtm;
        T9 = WVCoxRds * Vgsteff;
        T8 = T9 / Vgst2Vtm;
        T0 = EsatL + Vdsat + 2.0 * T9 * tmp4;
        T9 = WVCoxRds * Abulk; 
        T1 = 2.0 / Lambda - 1.0 + T9; 

        Vasat = T0 / T1;

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            dT0_dVg = dEsatL_dVg + dVdsat_dVg + T7 * (1.0 + tmp2 * Vgsteff)
               - T8 * (Abulk * dVdsat_dVg - Abulk * Vdsat / Vgst2Vtm
               + Vdsat * dAbulk_dVg);
            dT0_dVb = dEsatL_dVb + dVdsat_dVb + T7 * tmp3 * Vgsteff
              - T8 * (dAbulk_dVb * Vdsat + Abulk * dVdsat_dVb);
            dT0_dVd = dEsatL_dVd + dVdsat_dVd - T8 * Abulk * dVdsat_dVd;
            dT1_dVg = -2.0 * tmp1 +  WVCoxRds * (Abulk * tmp2 + dAbulk_dVg);
            dT1_dVb = dAbulk_dVb * WVCoxRds + T9 * tmp3;
            dVasat_dVg = (dT0_dVg - Vasat * dT1_dVg) / T1;
            dVasat_dVb = (dT0_dVb - Vasat * dT1_dVb) / T1;
            dVasat_dVd = dT0_dVd / T1;
        end
`endif

        if(verbose == 1) 
        $strobe("Vasat=%g\n", Vasat);
        
        /* Calculate Idl first */
        tmp1 = here_BSIM4vtfbphi2;
        tmp2 = 2.0e8 * BSIM4toxp;
        T0 = (Vgsteff + tmp1) / tmp2;
        
        tmp3 = exp(BSIM4bdos * 0.7 * ln(T0));
        T1 = 1.0 + tmp3;
        T2 = BSIM4bdos * 0.7 * tmp3 / T0;
        Tcen = BSIM4ados * 1.9e-9 / T1;
        
        Coxeff = epssubl * BSIM4coxp / ( epssubl + BSIM4coxp * Tcen);
        CoxeffWovL = Coxeff * Weff / Leff;
        beta = ueff * CoxeffWovL;
        T3 = ueff / Leff;
        AbovVgst2Vtm = Abulk / Vgst2Vtm;
        T0 = 1.0 - 0.5 * Vdseff * AbovVgst2Vtm;
        fgche1 = Vgsteff * T0;
        T9 = Vdseff / EsatL;
        fgche2 = 1.0 + T9;
        gche = beta * fgche1 / fgche2;
        T0 = 1.0 + gche * Rds;
        Idl = gche / T0;
        // T1 = (1.0 - Idl * Rds) / T0;
        // T2 = Idl * Idl;

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            dT0_dVg = 1.0 / tmp2;
            T0 = (Vgsteff + tmp1) * dT0_dVg;

            tmp3 = exp(0.7 * ln(T0));
            T1 = 1.0 + tmp3;
            T2 = 0.7 * tmp3 / T0;
            dTcen_dVg = -Tcen * T2 * dT0_dVg / T1;
            dCoxeff_dVg = -Coxeff * Coxeff * dTcen_dVg / `EPSSI;
      
            dbeta_dVg = CoxeffWovL * dueff_dVg + ueff / Leff
                        * (Weff * dCoxeff_dVg + Coxeff * dWeff_dVg);
            dbeta_dVd = CoxeffWovL * dueff_dVd;
            dbeta_dVb = CoxeffWovL * dueff_dVb + T3 * Coxeff * dWeff_dVb;
      
            T0 = 1.0 - 0.5 * Vdseff * AbovVgst2Vtm;
            dT0_dVg = -0.5 * (Abulk * dVdseff_dVg
                         - Abulk * Vdseff / Vgst2Vtm + Vdseff * dAbulk_dVg) 
                         / Vgst2Vtm;
            dT0_dVd = -0.5 * Abulk * dVdseff_dVd / Vgst2Vtm;
            dT0_dVb = -0.5 * (Abulk * dVdseff_dVb + dAbulk_dVb * Vdseff)
                        / Vgst2Vtm;
      
            dfgche1_dVg = Vgsteff * dT0_dVg + T0;
            dfgche1_dVd = Vgsteff * dT0_dVd;
            dfgche1_dVb = Vgsteff * dT0_dVb;
      
            dfgche2_dVg = (dVdseff_dVg - T9 * dEsatL_dVg) / EsatL;
            dfgche2_dVd = (dVdseff_dVd - T9 * dEsatL_dVd) / EsatL;
            dfgche2_dVb = (dVdseff_dVb - T9 * dEsatL_dVb) / EsatL;
      
            dgche_dVg = (beta * dfgche1_dVg + fgche1 * dbeta_dVg
                         - gche * dfgche2_dVg) / fgche2;
            dgche_dVd = (beta * dfgche1_dVd + fgche1 * dbeta_dVd
                         - gche * dfgche2_dVd) / fgche2;
            dgche_dVb = (beta * dfgche1_dVb + fgche1 * dbeta_dVb
                         - gche * dfgche2_dVb) / fgche2;
      
            T0 = 1.0 + gche * Rds;
            T1 = (1.0 - Idl * Rds) / T0;
            T2 = Idl * Idl;
            dIdl_dVg = T1 * dgche_dVg - T2 * dRds_dVg;
            dIdl_dVd = T1 * dgche_dVd;
            dIdl_dVb = T1 * dgche_dVb - T2 * dRds_dVb;
        end
`endif

        if(verbose == 1) 
        $strobe("Idl=%g\n", Idl);
        
        /* Calculate degradation factor due to pocket implant */

        if (BSIM4fprout <= 0.0) begin
            FP = 1.0;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dFP_dVg = 0.0;
            end
`endif
        end 
        else begin
            T9 = BSIM4fprout * sqrt(Leff) / Vgst2Vtm;
            FP = 1.0 / (1.0 + T9);

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dFP_dVg = FP * FP * T9 / Vgst2Vtm;
            end
`endif
        end 
        if(verbose == 1) 
        $strobe("FP=%g\n", FP);
        
        /* Calculate VACLM */
        T8 = BSIM4pvag / EsatL;
        T9 = T8 * Vgsteff;
        if (T9 > -0.9) begin
            PvagTerm = 1.0 + T9;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dPvagTerm_dVg = T8 * (1.0 - Vgsteff * dEsatL_dVg / EsatL);
                dPvagTerm_dVb = -T9 * dEsatL_dVb / EsatL;
                dPvagTerm_dVd = -T9 * dEsatL_dVd / EsatL;
            end
`endif
        end
        else begin
            T4 = 1.0 / (17.0 + 20.0 * T9);
            PvagTerm = (0.8 + T9) * T4;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                T4 = T4 * (  T4);
                dPvagTerm_dVg = T8 * (1.0 - Vgsteff * dEsatL_dVg / EsatL) * T4;
                T9 = T9 * (  T4 / EsatL);
                dPvagTerm_dVb = -T9 * dEsatL_dVb;
                dPvagTerm_dVd = -T9 * dEsatL_dVd; 
            end
`endif
        end 

        if ((BSIM4pclm > `MIN_EXP) && (diffVds > 1.0e-10)) begin
            T0 = 1.0 + Rds * Idl;
            T2 = Vdsat / Esat;
            T1 = Leff + T2;

            Cclm = FP * PvagTerm * T0 * T1 / (BSIM4pclm * BSIM4litl);
            VACLM = Cclm * diffVds;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dT0_dVg = dRds_dVg * Idl + Rds * dIdl_dVg;
                dT0_dVd = Rds * dIdl_dVd;
                dT0_dVb = dRds_dVb * Idl + Rds * dIdl_dVb;
                dT1_dVg = (dVdsat_dVg - T2 * dEsatL_dVg / Leff) / Esat;
                dT1_dVd = (dVdsat_dVd - T2 * dEsatL_dVd / Leff) / Esat;
                dT1_dVb = (dVdsat_dVb - T2 * dEsatL_dVb / Leff) / Esat;
   
                dCclm_dVg = Cclm * (dFP_dVg / FP + dPvagTerm_dVg / PvagTerm
                          + dT0_dVg / T0 + dT1_dVg / T1);
                dCclm_dVb = Cclm * (dPvagTerm_dVb / PvagTerm + dT0_dVb / T0
                          + dT1_dVb / T1);
                dCclm_dVd = Cclm * (dPvagTerm_dVd / PvagTerm + dT0_dVd / T0
                          + dT1_dVd / T1);

                dVACLM_dVg = dCclm_dVg * diffVds - dVdseff_dVg * Cclm;
                dVACLM_dVb = dCclm_dVb * diffVds - dVdseff_dVb * Cclm;
                dVACLM_dVd = dCclm_dVd * diffVds + (1.0 - dVdseff_dVd) * Cclm;
             end
`endif
     end 
        else begin
            VACLM = `MAX_EXP;
            Cclm = `MAX_EXP;

`ifdef NOISE_DERIVATIVES
            if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                // Derivatives only needed for this mode.
                dVACLM_dVd = 0.0;
                dVACLM_dVg = 0.0;
                dVACLM_dVb = 0.0;
                dCclm_dVd = 0.0;
                dCclm_dVg = 0.0;
             end
`endif
        end 
        if(verbose == 1) 
          $strobe("VACLM=%g\n", VACLM);
        
        /* Calculate VADIBL */
        if (BSIM4thetaRout > `MIN_EXP) begin
            T8 = Abulk * Vdsat;
            T0 = Vgst2Vtm * T8;
            T1 = Vgst2Vtm + T8;
            T9 = T1 * T1;
            T2 = BSIM4thetaRout;

            VADIBL = (Vgst2Vtm - T0 / T1) / T2;

        T7 = BSIM4pdiblb * Vbseff;
        if (T7 >= -0.9) begin
            T3 = 1.0 / (1.0 + T7);
            VADIBL = VADIBL * T3;
        end 
        else begin
            T4 = 1.0 / (0.8 + T7);
            T3 = (17.0 + 20.0 * T7) * T4;
            VADIBL = VADIBL * T3;
        end 
        VADIBL = VADIBL * (  PvagTerm);
    end 
    else 
        VADIBL = `MAX_EXP;

        if(verbose == 1) 
          $strobe("ELSE VADIBL=%g\n", VADIBL);

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if (BSIM4thetaRout > 0.0) begin
                T8 = Abulk * Vdsat;
                T0 = Vgst2Vtm * T8;
                dT0_dVg = Vgst2Vtm * Abulk * dVdsat_dVg + T8
                          + Vgst2Vtm * Vdsat * dAbulk_dVg;
                dT0_dVb = Vgst2Vtm * (dAbulk_dVb * Vdsat + Abulk * dVdsat_dVb);
                dT0_dVd = Vgst2Vtm * Abulk * dVdsat_dVd;

                T1 = Vgst2Vtm + T8;
                dT1_dVg = 1.0 + Abulk * dVdsat_dVg + Vdsat * dAbulk_dVg;
                dT1_dVb = Abulk * dVdsat_dVb + dAbulk_dVb * Vdsat;
                dT1_dVd = Abulk * dVdsat_dVd;

                T9 = T1 * T1;
                T2 = BSIM4thetaRout;
                VADIBL = (Vgst2Vtm - T0 / T1) / T2;
                dVADIBL_dVg = (1.0 - dT0_dVg / T1 + T0 * dT1_dVg / T9) / T2;
                dVADIBL_dVb = (-dT0_dVb / T1 + T0 * dT1_dVb / T9) / T2;
                dVADIBL_dVd = (-dT0_dVd / T1 + T0 * dT1_dVd / T9) / T2;

                T7 = BSIM4pdiblb * Vbseff;
                if (T7 >= -0.9) begin
                    T3 = 1.0 / (1.0 + T7);
                    VADIBL = VADIBL * T3;
                    dVADIBL_dVg = dVADIBL_dVg * T3;
                    dVADIBL_dVb = (dVADIBL_dVb - VADIBL * BSIM4pdiblb)
                                   * T3;
                    dVADIBL_dVd = dVADIBL_dVd * T3;
                end
                else begin
                    T4 = 1.0 / (0.8 + T7);
                    T3 = (17.0 + 20.0 * T7) * T4;
                    dVADIBL_dVg = dVADIBL_dVg * T3;
                    dVADIBL_dVb = dVADIBL_dVb * T3
                                  - VADIBL * BSIM4pdiblb * T4 * T4;
                    dVADIBL_dVd = dVADIBL_dVd * T3;
                    VADIBL = VADIBL * T3;
                end

                dVADIBL_dVg = dVADIBL_dVg * PvagTerm + VADIBL * dPvagTerm_dVg;
                dVADIBL_dVb = dVADIBL_dVb * PvagTerm + VADIBL * dPvagTerm_dVb;
                dVADIBL_dVd = dVADIBL_dVd * PvagTerm + VADIBL * dPvagTerm_dVd;
                VADIBL = VADIBL * (  PvagTerm);
            end
            else begin
                VADIBL = `MAX_EXP;

                dVADIBL_dVd = 0.0;
                dVADIBL_dVg = 0.0;
                dVADIBL_dVb = 0.0;
            end
        end
        if(verbose == 1) 
          $strobe("NOISE VADIBL=%g\n", VADIBL);
`endif 

        
        /* Calculate Va */
        Va = Vasat + VACLM;

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            dVa_dVg = dVasat_dVg + dVACLM_dVg;
            dVa_dVb = dVasat_dVb + dVACLM_dVb;
            dVa_dVd = dVasat_dVd + dVACLM_dVd;
        end
`endif

        if(verbose == 1) 
        $strobe("Va=%g\n", Va);
        
        /* Calculate VADITS */
        T0 = BSIM4pditsd * Vds;
        if (T0 > `EXP_THRESHOLD)
            T1 = `MAX_EXP;
        else
            T1 = exp(T0);

        if (BSIM4pdits > `MIN_EXP) begin
            T2 = 1.0 + BSIM4pditsl * Leff;
            VADITS = (1.0 + T2 * T1) / BSIM4pdits;
            VADITS = VADITS * FP;
        end 
        else
            VADITS = `MAX_EXP;

        if(verbose == 1) 
        $strobe("VADITS=%g\n", VADITS);

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            T0 = BSIM4pditsd * Vds;
            if (T0 > `EXP_THRESHOLD)
                dT1_dVd = 0;
            else
                dT1_dVd = T1 * BSIM4pditsd;

            if (BSIM4pdits > 0.0) begin
                dVADITS_dVg = VADITS * dFP_dVg;
                dVADITS_dVd = FP * T2 * dT1_dVd / BSIM4pdits;
            end
            else begin
                dVADITS_dVg = 0;
                dVADITS_dVd = 0;
            end
        end
`endif

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            dVASCBE_dVg = 0.0;
            dVASCBE_dVd = 0.0;
            dVASCBE_dVb = 0.0;
        end
`endif
        
        /* Calculate VASCBE */
        if (BSIM4pscbe2 > 0.0 && BSIM4pscbe1 >=0.0) begin
            if (diffVds > BSIM4pscbe1 * BSIM4litl / `EXP_THRESHOLD) begin
                T0 = BSIM4pscbe1 * BSIM4litl / diffVds;
                VASCBE = Leff * exp(T0) / BSIM4pscbe2;

`ifdef NOISE_DERIVATIVES
                if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
                    // Derivatives only needed for this mode.
                    T1 = T0 * VASCBE / diffVds;
                    dVASCBE_dVg = T1 * dVdseff_dVg;
                    dVASCBE_dVd = -T1 * (1.0 - dVdseff_dVd);
                    dVASCBE_dVb = T1 * dVdseff_dVb;
                end
`endif
        end 
        else
            VASCBE = `MAX_EXP * Leff/BSIM4pscbe2;
    end 
    else
        VASCBE = `MAX_EXP;
       
       if(verbose == 1) 
       $strobe("VASCBE=%g\n", VASCBE);
        
        /* Add DIBL to Ids */
        T9 = diffVds / VADIBL;
        T0 = 1.0 + T9;
        if(verbose == 1) begin 
          $strobe("T9=%g\n", T9);
          $strobe("VADIBL=%g\n", VADIBL);
          $strobe("diffVds=%g\n", diffVds);
          $strobe("Idl=%g\n", Idl);
        end
        Idsa = Idl * T0;

        /* Add DITS to Ids */
        T9 = diffVds / VADITS;
        if(verbose == 1) 
          $strobe("T9=%g\n", T9);
        T0 = 1.0 + T9;
        Idsa = Idsa * T0;
        if(verbose == 1) 
        $strobe("Idsa=%g\n", Idsa);

        /* Add CLM to Ids */
        T0 = ln(Va / Vasat);
        T1 = T0 / Cclm;
        T9 = 1.0 + T1;
    
        Idsa = Idsa * T9;
        if(verbose == 1) 
        $strobe("Idsa=%g\n", Idsa);

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            dIdsa_dVg = T0 * dIdl_dVg - Idl * (dVdseff_dVg + T9 * dVADIBL_dVg)
                         / VADIBL;
            dIdsa_dVd = T0 * dIdl_dVd + Idl
                         * (1.0 - dVdseff_dVd - T9 * dVADIBL_dVd) / VADIBL;
            dIdsa_dVb = T0 * dIdl_dVb - Idl * (dVdseff_dVb + T9 * dVADIBL_dVb)
                         / VADIBL;
        end
`endif

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            dT0_dVg = dVa_dVg / Va - dVasat_dVg / Vasat;
            dT0_dVb = dVa_dVb / Va - dVasat_dVb / Vasat;
            dT0_dVd = dVa_dVd / Va - dVasat_dVd / Vasat;
            dT9_dVg = (dT0_dVg - T1 * dCclm_dVg) / Cclm;
            dT9_dVb = (dT0_dVb - T1 * dCclm_dVb) / Cclm;
            dT9_dVd = (dT0_dVd - T1 * dCclm_dVd) / Cclm;
            dIdsa_dVg = dIdsa_dVg * T9 + Idsa * dT9_dVg;
            dIdsa_dVb = dIdsa_dVb * T9 + Idsa * dT9_dVb;
            dIdsa_dVd = dIdsa_dVd * T9 + Idsa * dT9_dVd;
        end
`endif

        
        /* Substrate current begins */
        tmp = BSIM4alpha0 + BSIM4alpha1 * Leff;
        if ((tmp <= 0.0) || (BSIM4beta0 <= 0.0)) begin
            Isub = 0.0;
            Gbd = 0.0;
            Gbb = 0.0;
            Gbg = 0.0;
        end 
        else begin
            T2 = tmp / Leff;
            if (diffVds > BSIM4beta0 / `EXP_THRESHOLD) begin
                T0 = -BSIM4beta0 / diffVds;
                T1 = T2 * diffVds * exp(T0);
                T3 = T1 / diffVds * (T0 - 1.0);
            end 
            else begin
                T3 = T2 * `MIN_EXP;
                T1 = T3 * diffVds;
            end 
            T4 = Idsa * Vdseff;
            Isub = T1 * T4;
        end 

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if ((tmp <= 0.0) || (BSIM4beta0 <= 0.0)) begin
                Isub = 0.0;
                Gbd = 0.0;
                Gbb = 0.0;
                Gbg = 0.0;
            end
            else begin
                T2 = tmp / Leff;
                if (diffVds > BSIM4beta0 / `EXP_THRESHOLD) begin
                    T0 = -BSIM4beta0 / diffVds;
                    T1 = T2 * diffVds * exp(T0);
                    T3 = T1 / diffVds * (T0 - 1.0);
                    dT1_dVg = T3 * dVdseff_dVg;
                    dT1_dVd = T3 * (dVdseff_dVd - 1.0);
                    dT1_dVb = T3 * dVdseff_dVb;
                end
                else begin
                    T3 = T2 * `MIN_EXP;
                    T1 = T3 * diffVds;
                    dT1_dVg = -T3 * dVdseff_dVg;
                    dT1_dVd = T3 * (1.0 - dVdseff_dVd);
                    dT1_dVb = -T3 * dVdseff_dVb;
                end
            end
        end
`endif
        if(verbose == 1) 
          $strobe("Isub=%g\n", Isub);

        /* Add SCBE to Ids */
        T9 = diffVds / VASCBE;
        T0 = 1.0 + T9;
        Ids = Idsa * T0;


`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.

            Gm = T0 * dIdsa_dVg - Idsa
                  * (dVdseff_dVg + T9 * dVASCBE_dVg) / VASCBE;
            Gds = T0 * dIdsa_dVd + Idsa
                   * (1.0 - dVdseff_dVd - T9 * dVASCBE_dVd) / VASCBE;
            Gmb = T0 * dIdsa_dVb - Idsa
                   * (dVdseff_dVb + T9 * dVASCBE_dVb) / VASCBE;
        
            tmp1 = Gds + Gm * dVgsteff_dVd;
            tmp2 = Gmb + Gm * dVgsteff_dVb;
            tmp3 = Gm;
        
            Gm = (Ids * dVdseff_dVg + Vdseff * tmp3) * dVgsteff_dVg;
            Gds = Ids * (dVdseff_dVd + dVdseff_dVg * dVgsteff_dVd)
               + Vdseff * tmp1;
            Gmb = (Ids * (dVdseff_dVb + dVdseff_dVg * dVgsteff_dVb)
                   + Vdseff * tmp2) * dVbseff_dVb;
        end
`endif

        cdrain = Ids * Vdseff;
        if(verbose == 1) begin 
          $strobe("Ids=%g\n", Ids);
          $strobe("cdrain=%g\n", cdrain);
        end
        
        /* Source End Velocity Limit  */
        // VA: Needs better FPE protection...
        if ((BSIM4vtlGiven) && (BSIM4vtl > 0.0)) begin
            T12 = 1.0 / Leff / CoxeffWovL;
            T11 = T12 / Vgsteff;
            vs = cdrain * T11;
            T0 = 2 * `MM;
            T1 = vs / (BSIM4vtl * BSIM4tfactor);
            if (T1 >0.0) begin
                T2 = 1.0 + exp(T0 * ln(T1));
                Fsevl = 1.0 / exp(ln(T2)/ T0);
            end
            else
                Fsevl = 1.0;

            //Fsevl = 1.0 / exp(ln(T2) / T0);
            cdrain = cdrain * Fsevl;
            if(verbose == 1) 
              $strobe("cdrain (source end velocity limit)=%g\n", cdrain); 
        end
            IdovVds = Ids;
            if( IdovVds <= 1.0e-9) 
              IdovVds = 1.0e-9;
            
        /* Calculate Rg */
        if ((BSIM4rgateMod > 1)  ||
            (BSIM4trnqsMod != 0) || 
            (BSIM4acnqsMod != 0)) begin

            T9 = BSIM4xrcrg2 * BSIM4vtm;
            T0 = T9 * beta;

            BSIM4gcrg = BSIM4xrcrg1 * (T0 + Ids);

            if (BSIM4nf != 1.0) 
                BSIM4gcrg = BSIM4gcrg * BSIM4nf;

            if (BSIM4rgateMod == 2) begin
                T10 = BSIM4grgeltd * BSIM4grgeltd;
                T11 = BSIM4grgeltd + BSIM4gcrg;
                BSIM4gcrg = BSIM4grgeltd * BSIM4gcrg / T11;
            end 
        end 

        /* Calculate bias-dependent external S/D resistance */
        if (BSIM4rdsMod) begin
            /* Rs(V) */
            T0 = vgs - BSIM4vfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgs_eff = 0.5 * (T0 + T1);

            T0 = 1.0 + BSIM4prwg * vgs_eff;
            T1 = -BSIM4prwb * vbs;

            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);

            T4 = BSIM4rs0 * 0.5;
            Rs = BSIM4rswmin + T3 * T4;
            if(verbose == 1) begin
              $strobe("BSIM4vfbsd=%g\n",BSIM4vfbsd);
              $strobe("BSIM4prwg=%g\n",BSIM4prwg);
              $strobe("BSIM4prwb=%g\n",BSIM4prwb);
              $strobe("BSIM4rs0=%g\n",BSIM4rs0);
              $strobe("BSIM4rswmin=%g\n",BSIM4rswmin);
              $strobe("vgs_eff=%g\n",vgs_eff);
              $strobe("T0=%g\n",T0);
              $strobe("T1=%g\n",T1);
              $strobe("T2=%g\n",T2);
              $strobe("T3=%g\n",T3);
              $strobe("T4=%g\n",T4);
              $strobe("Rs=%g\n",Rs);
            end

            /* Rd(V) */
            T0 = vgd - BSIM4vfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgd_eff = 0.5 * (T0 + T1);

            T0 = 1.0 + BSIM4prwg * vgd_eff;
            T1 = -BSIM4prwb * vbd;

            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);

            T4 = BSIM4rd0 * 0.5;
            Rd = BSIM4rdwmin + T3 * T4;

        end

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            dvgs_eff_dvg = vgs_eff / T1;
  
            T0 = 1.0 + BSIM4prwg * vgs_eff;
            dT0_dvg = -BSIM4prwg / T0 / T0 * dvgs_eff_dvg;
            T1 = -BSIM4prwb * vbs;
            dT1_dvb = -BSIM4prwb;
   
            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);
            dT3_dvg = T3 / (T3 - T2);
            dT3_dvb = dT3_dvg * dT1_dvb;
            dT3_dvg = dT3_dvg * dT0_dvg;
   
            T4 = BSIM4rs0 * 0.5;
            dRs_dvg = T4 * dT3_dvg;
            dRs_dvb = T4 * dT3_dvb;
   
            T0 = 1.0 + BSIM4sourceConductance * Rs;
            BSIM4gstot = BSIM4sourceConductance / T0;
            if(verbose == 1) 
              $strobe("BSIM4gstot=%g\n",BSIM4gstot);

            T0 = -BSIM4gstot * BSIM4gstot;
            dgstot_dvd = 0.0; /* place holder */
            dgstot_dvg = T0 * dRs_dvg;
            dgstot_dvb = T0 * dRs_dvb;
            dgstot_dvs = -(dgstot_dvg + dgstot_dvb + dgstot_dvd);
   
            /* Rd(V) */
            T0 = vgd - BSIM4vfbsd;
            T1 = sqrt(T0 * T0 + 1.0e-4);
            vgd_eff = 0.5 * (T0 + T1);
            dvgd_eff_dvg = vgd_eff / T1;
   
            T0 = 1.0 + BSIM4prwg * vgd_eff;
            dT0_dvg = -BSIM4prwg / T0 / T0 * dvgd_eff_dvg;
            T1 = -BSIM4prwb * vbd;
            dT1_dvb = -BSIM4prwb;
   
            T2 = 1.0 / T0 + T1;
            T3 = T2 + sqrt(T2 * T2 + 0.01);
            dT3_dvg = T3 / (T3 - T2);
            dT3_dvb = dT3_dvg * dT1_dvb;
            dT3_dvg = dT3_dvg * dT0_dvg;
   
            T4 = BSIM4rd0 * 0.5;
            dRd_dvg = T4 * dT3_dvg;
            dRd_dvb = T4 * dT3_dvb;
   
            T0 = 1.0 + BSIM4drainConductance * Rd;
            BSIM4gdtot = BSIM4drainConductance / T0;
            T0 = -BSIM4gdtot * BSIM4gdtot;
            dgdtot_dvs = 0.0;
            dgdtot_dvg = T0 * dRd_dvg;
            dgdtot_dvb = T0 * dRd_dvb;
            dgdtot_dvd = -(dgdtot_dvg + dgdtot_dvb + dgdtot_dvs);
         end
`endif
	 /* GIDL/GISL Models */
        if(BSIM4mtrlmod == 0)
	  T0 = 3.0 * toxel;
	else
	  T0 = BSIM4epsrsub * toxel / epsroxl;
        
        /* Calculate GIDL current */ 
        if (BSIM4gidlMod==0) begin 
	  if(BSIM4mtrlmod ==0)
	    T1 = (vds - vgs_eff - BSIM4egidl ) / T0;
	  else
	    T1 = (vds - vgs_eff - BSIM4egidl + BSIM4vfbsd) / T0;

        if ((BSIM4agidl <= 0.0) || (BSIM4bgidl <= 0.0)
            || (T1 <= 0.0) || (BSIM4cgidl <= 0.0) || (vbd > 0.0))
            Igidl = 0.0;
        else begin
            T2 = BSIM4bgidl / T1;
            if (T2 < 100.0) begin
                Igidl = BSIM4agidl * BSIM4weffCJ * T1 * exp(-T2);
                T3 = Igidl * (1.0 + T2) / T1;
            end 
            else begin
                Igidl = BSIM4agidl * BSIM4weffCJ * 3.720075976e-44;
                Igidl = Igidl * T1;
            end

            T4 = vbd * vbd;
            T5 = -vbd * T4;
            T6 = BSIM4cgidl + T5;
            T7 = T5 / T6;
            //T8 = 3.0 * BSIM4cgidl * T4 / T6 / T6;
            Igidl = Igidl * T7;
        end 

        /* Calculate GISL current: bugfix recommended by TI  -JX */
	if(BSIM4mtrlmod ==0)
          T1 = (-vds - vgd_eff - BSIM4egisl ) / T0;
	else
          T1 = (-vds - vgd_eff - BSIM4egisl + BSIM4vfbsd ) / T0;
          
        if ((BSIM4agisl <= 0.0) || (BSIM4bgisl <= 0.0)
            || (T1 <= 0.0) || (BSIM4cgisl <= 0.0) || (vbs > 0.0))
            Igisl = 0.0;
        else begin      
            T2 = BSIM4bgisl / T1;
            if (T2 < 100.0) begin
                Igisl = BSIM4agisl * BSIM4weffCJ * T1 * exp(-T2);
                //T3 = Igisl * (1.0 + T2) / T1;
            end 
            else begin
                Igisl = BSIM4agisl * BSIM4weffCJ * 3.720075976e-44;
                Igisl = Igisl * T1;
            end         
            T4 = vbs * vbs;
            T5 = -vbs * T4;
            T6 = BSIM4cgisl + T5;
            T7 = T5 / T6;
            Igisl = Igisl * T7;
        end 
       end
       else begin
	  /* v4.7 New Gidl/GISL model */
          
	            /* GISL */
                    if (BSIM4mtrlmod==0) 
                       T1 = (-vds - BSIM4rgisl * vgd_eff - BSIM4egisl) / T0;     
                    else 
                       T1 = (-vds - BSIM4rgisl * vgd_eff - BSIM4egisl + BSIM4vfbsd) / T0; 
                    
		    if ((BSIM4agisl <= 0.0) ||
                            (BSIM4bgisl <= 0.0) || (T1 <= 0.0) ||
                            (BSIM4cgisl < 0.0)  )
                        Igisl = 0.0; 
                    else
                    begin
                        T2 = BSIM4bgisl / T1;
                        if (T2 < `EXPL_THRESHOLD)
                            Igisl = BSIM4weffCJ * BSIM4agisl * T1 * exp(-T2);
			else
                        begin
                            T3 = BSIM4weffCJ * BSIM4agisl * `MIN_EXPL;
                            Igisl = T3 * T1 ;
                        
                        end
                        T4 = vbs - BSIM4fgisl;
                        
			if (T4==0)
                            T5 = `EXPL_THRESHOLD;
                        else
                            T5 = BSIM4kgisl / T4;
                        if (T5<`EXPL_THRESHOLD)
                            T6 = exp(T5);
                        else
                          T6 = `MAX_EXPL;
                        Igisl=Igisl*T6;

                    end
                    /* End of GISL */
		    
	            /* GIDL */
                    if (BSIM4mtrlmod==0) 
                        T1 = (vds - BSIM4rgidl * vgs_eff - BSIM4egidl) /  T0;                                           
                    else 
                        T1 = (vds - BSIM4rgidl * vgs_eff - BSIM4egidl + BSIM4vfbsd) / T0;
		
                    if ((BSIM4agidl <= 0.0) ||
                            (BSIM4bgidl <= 0.0) || (T1 <= 0.0) ||
                            (BSIM4cgidl < 0.0)  )
                        Igidl = 0.0; 
                    else
                    begin
                        dT1_dVd = 1 / T0;
                        dT1_dVg = - BSIM4rgidl * dT1_dVd * dvgs_eff_dvg;
                        T2 = BSIM4bgidl / T1;
                        if (T2 < `EXPL_THRESHOLD)
                        begin
                            Igidl = BSIM4weffCJ * BSIM4agidl * T1 * exp(-T2);
                        end else
                        begin
                            T3 = BSIM4weffCJ * BSIM4agidl * `MIN_EXPL;
                            Igidl = T3 * T1 ;
                        end
                        T4 = vbd - BSIM4fgidl;
                        if (T4==0)
                            T5 = `EXPL_THRESHOLD;
                        else
                            T5 = BSIM4kgidl / T4;
                        if (T5<`EXPL_THRESHOLD)
                          T6 = exp(T5);
                        else
                          T6 = `MAX_EXPL;
                        Igidl = Igidl*T6;
                    end                                        
                /* End of New GIDL */
       end
       if(verbose == 1) begin
          $strobe("Igisl=%g\n", Igisl);
          $strobe("Igidl=%g\n", Igidl);
       end
	   	/*End of Gidl*/
       
        /* Calculate gate tunneling current */
        if ((BSIM4igcMod != 0) || (BSIM4igbMod != 0)) begin
            Vfb = here_BSIM4vfbzb;
            V3 = Vfb - Vgs_eff + Vbseff - `DELTA_3;
            if (Vfb <= 0.0)
                T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfb);
            else
                T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfb);

            T1 = 0.5 * (1.0 + V3 / T0);
            Vfbeff = Vfb - 0.5 * (V3 + T0);

            Voxacc = Vfb - Vfbeff;
            if (Voxacc < 0.0) /* WDLiu: Avoiding numerical instability. */
                Voxacc = 0.0;

            T0 = 0.5 * BSIM4k1ox;
            T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
            if (BSIM4k1ox == 0.0)
                Voxdepinv = 0.0;
            else if (T3 < 0.0)
                Voxdepinv = -T3;
            else begin
                T1 = sqrt(T0 * T0 + T3);
                //T2 = T0 / T1;
                Voxdepinv = BSIM4k1ox * (T1 - T0);
            end

            Voxdepinv = Voxdepinv + Vgsteff;
        end 

`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.
            if ((BSIM4igcMod != 0) || (BSIM4igbMod != 0)) begin
                V3 = Vfb - Vgs_eff + Vbseff - `DELTA_3;
                if (Vfb <= 0.0)
                    T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfb);
                else
                    T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfb);
                T1 = 0.5 * (1.0 + V3 / T0);
                dVfbeff_dVg = T1 * dVgs_eff_dVg;
                dVfbeff_dVb = -T1; /* WDLiu: -No surprise? No. -Good! */
     
                dVoxacc_dVg = -dVfbeff_dVg;
                dVoxacc_dVb = -dVfbeff_dVb;
                if (Voxacc < 0.0) begin
                    dVoxacc_dVg = 0.0;
                    dVoxacc_dVb = 0.0;
                end
     
                T0 = 0.5 * BSIM4k1ox;
                T3 = Vgs_eff - Vfbeff - Vbseff - Vgsteff;
                if (BSIM4k1ox == 0.0) begin
                    dVoxdepinv_dVd = 0.0;
                    dVoxdepinv_dVg = 0.0;
                    dVoxdepinv_dVd = 0.0;
                    dVoxdepinv_dVb = 0.0;
                end
                else if (T3 < 0.0) begin
                    dVoxdepinv_dVg = -dVgs_eff_dVg + dVfbeff_dVg + dVgsteff_dVg;
                    dVoxdepinv_dVd = dVgsteff_dVd;
                    dVoxdepinv_dVb = dVfbeff_dVb + 1.0 + dVgsteff_dVb;
                end
                else begin
                    T1 = sqrt(T0 * T0 + T3);
                    T2 = T0 / T1;
                    dVoxdepinv_dVg = T2 * (dVgs_eff_dVg - dVfbeff_dVg
                                           - dVgsteff_dVg);
                    dVoxdepinv_dVd = -T2 * dVgsteff_dVd;
                    dVoxdepinv_dVb = -T2 * (dVfbeff_dVb + 1.0 + dVgsteff_dVb);
                end
     
                dVoxdepinv_dVg = dVoxdepinv_dVg + (  dVgsteff_dVg);
                dVoxdepinv_dVd = dVoxdepinv_dVd + (  dVgsteff_dVd);
                dVoxdepinv_dVb = dVoxdepinv_dVb + (  dVgsteff_dVb);
            end
        end
`endif

        if(verbose == 1) 
          $strobe("Voxdepinv=%g\n", Voxdepinv);

        if(BSIM4tempMod < 2)
            tmp = Vtm;
        else /* model->BSIM4tempMod = 2 , 3*/
            tmp = Vtm0;

        if (BSIM4igcMod) begin
            T0 = tmp * BSIM4nigc;
            if(BSIM4igcMod == 1) begin
              VxNVt = (Vgs_eff - BSIM4type * here_BSIM4vth0) / T0;
              if (VxNVt > `EXP_THRESHOLD)
                Vaux = Vgs_eff - BSIM4type * here_BSIM4vth0;
	    end else if (BSIM4igcMod == 2) begin
              VxNVt = (Vgs_eff - Vth) / T0;
              if (VxNVt > `EXP_THRESHOLD)
                Vaux = Vgs_eff - Vth;
            end
              if (VxNVt < -`EXP_THRESHOLD)
              begin   
                  Vaux = T0 * ln(1.0 + `MIN_EXP);
                  //dVaux_dVg = dVaux_dVd = dVaux_dVb = 0.0;
              end
              else if ((VxNVt >= -`EXP_THRESHOLD) && (VxNVt <= `EXP_THRESHOLD))
              begin   
                  ExpVxNVt = exp(VxNVt);
                  Vaux = T0 * ln(1.0 + ExpVxNVt);
                  //dVaux_dVg = ExpVxNVt / (1.0 + ExpVxNVt);
		  //if(BSIM4igcMod == 1) begin
		  //    dVaux_dVd = 0.0;
                  //	dVaux_dVb = 0.0;
                  //end else if (BSIM4igcMod == 2) begin
                  //    dVaux_dVd = -dVaux_dVg* dVth_dVd;  /* Synopsys 08/30/2013 modify */
                  //    dVaux_dVb = -dVaux_dVg* dVth_dVb;  /* Synopsys 08/30/2013 modify */
		  //end
		  //dVaux_dVg *= dVgs_eff_dVg;
              end


            T2 = Vgs_eff * Vaux;
            T11 = BSIM4Aechvb;
            T3 = BSIM4aigc * BSIM4cigc - BSIM4bigc;
            T4 = BSIM4bigc * BSIM4cigc;
            T5 = BSIM4Bechvb * (BSIM4aigc + T3 * Voxdepinv
            - T4 * Voxdepinv * Voxdepinv);

            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igc = T11 * T2 * T6;

            if (BSIM4pigcdGiven)
                Pigcd = BSIM4pigcd;
            else begin
                /*T11 = BSIM4Bechvb * BSIM4toxe; v4.7 */
                T11 = -BSIM4Bechvb;
                T12 = Vgsteff + 1.0e-20;
                T13 = T11 / T12 / T12;
                T14 = -T13 / T12;
                Pigcd = T13 * (1.0 - 0.5 * Vdseff / T12);
            end

            T7 = -Pigcd * Vdseff;
            T8 = T7 * T7 + 2.0e-4;

            if (T7 > `EXP_THRESHOLD)
                T9 = `MAX_EXP;
            else if (T7 < -`EXP_THRESHOLD)
                T9 = `MIN_EXP;
            else
                T9 = exp(T7);

            T0 = T8 * T8;
            T1 = T9 - 1.0 + 1.0e-4;
            T10 = (T1 - T7) / T8;

            Igcs = Igc * T10;

            T1 = T9 - 1.0 - 1.0e-4;
            T10 = (T7 * T9 - T1) / T8;
            Igcd = Igc * T10;

            T0 = vgs - (BSIM4vfbsd + BSIM4vfbsdoff);
            vgs_eff = sqrt(T0 * T0 + 1.0e-4);

            T2 = vgs * vgs_eff;
            T11 = BSIM4AechvbEdgeS;
            T12 = BSIM4BechvbEdge;
            T3 = BSIM4aigs * BSIM4cigs - BSIM4bigs;
            T4 = BSIM4bigs * BSIM4cigs;
            T5 = T12 * (BSIM4aigs + T3 * vgs_eff - T4 * vgs_eff * vgs_eff);
            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);
            Igs = T11 * T2 * T6;
            if(verbose == 1) 
              $strobe("Igs=%g,%g,%g,%g,%g,%g,%g,%g,%g,%g\n", Igs,T11,  T2,  T6, BSIM4aigsd,T5, T3, T4,T12,vgs_eff);

            T0 = vgd - (BSIM4vfbsd + BSIM4vfbsdoff);
            vgd_eff = sqrt(T0 * T0 + 1.0e-4);

            T2 = vgd * vgd_eff;
            T11 = BSIM4AechvbEdgeD;
            T3 = BSIM4aigd * BSIM4cigd
                 - BSIM4bigd;
            T4 = BSIM4bigd * BSIM4cigd;
            T5 = T12 * (BSIM4aigd + T3 * vgd_eff - T4 * vgd_eff * vgd_eff);
            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igd = T11 * T2 * T6;
            if(verbose == 1) 
              $strobe("Igd=%g,%g,%g,%g\n", Igd,T11,  T2,  T6);
        end
        else begin //BSIM4igcMod == 0
          Igcs = 0.0;
          Igs = 0.0;
          Igcd = 0.0;
          Igd = 0.0;
        end
        
        if (BSIM4igbMod) begin
            T0 = tmp * BSIM4nigbacc;
            T1 = -Vgs_eff + Vbseff + Vfb;
            VxNVt = T1 / T0;
            if (VxNVt > `EXP_THRESHOLD)
                Vaux = T1;
            else if (VxNVt < -`EXP_THRESHOLD)
                Vaux = T0 * ln(1.0 + `MIN_EXP);
            else begin
                ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
            end

            T2 = (Vgs_eff - Vbseff) * Vaux;
            T11 = 4.97232e-7 * BSIM4weff * BSIM4leff * BSIM4ToxRatio;
            T12 = -7.45669e11 * toxel;
            T3 = BSIM4aigbacc * BSIM4cigbacc - BSIM4bigbacc;
            T4 = BSIM4bigbacc * BSIM4cigbacc;
            T5 = T12 * (BSIM4aigbacc + T3 * Voxacc - T4 * Voxacc * Voxacc);

            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igbacc = T11 * T2 * T6;
            if(verbose == 1) 
              $strobe("Igbacc=%g\n", Igbacc);

            T0 = tmp * BSIM4nigbinv;
            T1 = Voxdepinv - BSIM4eigbinv;
            VxNVt = T1 / T0;
            if (VxNVt > `EXP_THRESHOLD)
                Vaux = T1;
            else if (VxNVt < -`EXP_THRESHOLD)
                Vaux = T0 * ln(1.0 + `MIN_EXP);
            else begin
                ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
            end        

            T2 = (Vgs_eff - Vbseff) * Vaux;
            T11 = T11 * (0.75610);
            T12 = T12 * (1.31724);
            T3 = BSIM4aigbinv * BSIM4cigbinv - BSIM4bigbinv;
            T4 = BSIM4bigbinv * BSIM4cigbinv;
            T5 = T12 * (BSIM4aigbinv + T3 * Voxdepinv - T4 *
                Voxdepinv * Voxdepinv);

            if (T5 > `EXP_THRESHOLD)
                T6 = `MAX_EXP;
            else if (T5 < -`EXP_THRESHOLD)
                T6 = `MIN_EXP;
            else
                T6 = exp(T5);

            Igbinv = T11 * T2 * T6;
            if(verbose == 1) 
              $strobe("Igbinv=%g\n", Igbinv);

            Igb = Igbinv + Igbacc;

        end  /* End of Gate current */
        else
            Igb = 0.0;


`ifdef NOISE_DERIVATIVES
        if ((BSIM4tnoiMod == 1) && analysis("noise") == `NOISE) begin
            // Derivatives only needed for this mode.

        if (BSIM4igcMod) begin
            T0 = Vtm * BSIM4nigc;
            VxNVt = (Vgs_eff - BSIM4type * BSIM4vth0) / T0;
            if (VxNVt > `EXP_THRESHOLD) begin
                dVaux_dVg = dVgs_eff_dVg;
                dVaux_dVd = 0.0;
                dVaux_dVb = 0.0;
            end 
            else if (VxNVt < -`EXP_THRESHOLD) begin
                dVaux_dVg = 0.0;
                dVaux_dVd = 0.0;
                dVaux_dVb = 0.0;
            end 
            else begin
                dVaux_dVg = ExpVxNVt / (1.0 + ExpVxNVt);
                dVaux_dVd = 0.0;
                dVaux_dVb = 0.0;
                dVaux_dVg = dVaux_dVg * (  dVgs_eff_dVg);
            end

            dT2_dVg = dVgs_eff_dVg * Vaux + Vgs_eff * dVaux_dVg;
            dT2_dVd = Vgs_eff * dVaux_dVd;
            dT2_dVb = Vgs_eff * dVaux_dVb;

            T11 = BSIM4Aechvb;
            T12 = BSIM4Bechvb;
            T3 = BSIM4aigc * BSIM4cigc - BSIM4bigc;
            T4 = BSIM4bigc * BSIM4cigc;
            T5 = T12 * (BSIM4aigc + T3 * Voxdepinv - T4 *
                Voxdepinv * Voxdepinv);

            if (T5 > `EXP_THRESHOLD) begin
                T6 = `MAX_EXP;
                dT6_dVg = 0.0;
                dT6_dVd = 0.0;
                dT6_dVb = 0.0;
            end 
            else if (T5 < -`EXP_THRESHOLD) begin
                T6 = `MIN_EXP;
                dT6_dVg = 0.0;
                dT6_dVd = 0.0;
                dT6_dVb = 0.0;
            end 
            else begin
                T6 = exp(T5);
                dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * Voxdepinv);
                dT6_dVd = dT6_dVg * dVoxdepinv_dVd;
                dT6_dVb = dT6_dVg * dVoxdepinv_dVb;
                dT6_dVg = dT6_dVg * (  dVoxdepinv_dVg);
            end

            dIgc_dVg = T11 * (T2 * dT6_dVg + T6 * dT2_dVg);
            dIgc_dVd = T11 * (T2 * dT6_dVd + T6 * dT2_dVd);
            dIgc_dVb = T11 * (T2 * dT6_dVb + T6 * dT2_dVb);

            if (BSIM4pigcdGiven) begin
                dPigcd_dVg = 0.0;
                dPigcd_dVd = 0.0;
                dPigcd_dVb = 0.0;
            end 
            else begin
                T11 = BSIM4Bechvb * toxel;
                T12 = Vgsteff + 1.0e-20;
                T13 = T11 / T12 / T12;
                T14 = -T13 / T12;
                Pigcd = T13 * (1.0 - 0.5 * Vdseff / T12);
                dPigcd_dVg = T14 * (2.0 + 0.5 * (dVdseff_dVg *
                    Vgsteff - 3.0 * Vdseff) / T12);
                dPigcd_dVd = 0.5 * T14 * dVdseff_dVd +
                    dPigcd_dVg * dVgsteff_dVd;
                dPigcd_dVb = 0.5 * T14 * dVdseff_dVb +
                    dPigcd_dVg * dVgsteff_dVb;
                dPigcd_dVg = dPigcd_dVg * (  dVgsteff_dVg);
            end

            T7 = -Pigcd * Vds;
            dT7_dVg = -Vds * dPigcd_dVg;
            dT7_dVd = -Pigcd - Vds * dPigcd_dVd;
            dT7_dVb = -Vds * dPigcd_dVb;
            T8 = T7 * T7 + 2.0e-4;
            dT8_dVg = 2.0 * T7;
            dT8_dVd = dT8_dVg * dT7_dVd;
            dT8_dVb = dT8_dVg * dT7_dVb;
            dT8_dVg = dT8_dVg * (  dT7_dVg);

            if (T7 > `EXP_THRESHOLD) begin
                T9 = `MAX_EXP;
                dT9_dVg = 0.0;
                dT9_dVd = 0.0;
                dT9_dVb = 0.0;
            end 
            else if (T7 < -`EXP_THRESHOLD) begin
                T9 = `MIN_EXP;
                dT9_dVg = 0.0;
                dT9_dVd = 0.0;
                dT9_dVb = 0.0;
            end 
            else begin
                T9 = exp(T7);
                dT9_dVg = T9 * dT7_dVg;
                dT9_dVd = T9 * dT7_dVd;
                dT9_dVb = T9 * dT7_dVb;
            end

            T0 = T8 * T8;
            T1 = T9 - 1.0 + 1.0e-4;
            T10 = (T1 - T7) / T8;
            dT10_dVg = (dT9_dVg - dT7_dVg - T10 * dT8_dVg) / T8;
            dT10_dVd = (dT9_dVd - dT7_dVd - T10 * dT8_dVd) / T8;
            dT10_dVb = (dT9_dVb - dT7_dVb - T10 * dT8_dVb) / T8;

            Igcs = Igc * T10;
            dIgcs_dVg = dIgc_dVg * T10 + Igc * dT10_dVg;
            dIgcs_dVd = dIgc_dVd * T10 + Igc * dT10_dVd;
            dIgcs_dVb = dIgc_dVb * T10 + Igc * dT10_dVb;

            T1 = T9 - 1.0 - 1.0e-4;
            T10 = (T7 * T9 - T1) / T8;
            dT10_dVg = (dT7_dVg * T9 + (T7 - 1.0) * dT9_dVg -
                T10 * dT8_dVg) / T8;
            dT10_dVd = (dT7_dVd * T9 + (T7 - 1.0) * dT9_dVd -
                T10 * dT8_dVd) / T8;
            dT10_dVb = (dT7_dVb * T9 + (T7 - 1.0) * dT9_dVb -
                T10 * dT8_dVb) / T8;
            Igcd = Igc * T10;
            dIgcd_dVg = dIgc_dVg * T10 + Igc * dT10_dVg;
            dIgcd_dVd = dIgc_dVd * T10 + Igc * dT10_dVd;
            dIgcd_dVb = dIgc_dVb * T10 + Igc * dT10_dVb;

            T0 = vgs - BSIM4vfbsd;
            vgs_eff = sqrt(T0 * T0 + 1.0e-4);
            dvgs_eff_dvg = T0 / vgs_eff;

            T2 = vgs * vgs_eff;
            dT2_dVg = vgs * dvgs_eff_dvg + vgs_eff;
            T11 = BSIM4AechvbEdgeS;
            T12 = BSIM4BechvbEdge;
            T3 = BSIM4aigsd * BSIM4cigsd - BSIM4bigsd;
            T4 = BSIM4bigsd * BSIM4cigsd;
            T5 = T12 * (BSIM4aigsd + T3 * vgs_eff - T4 * vgs_eff * vgs_eff);
            if (T5 > `EXP_THRESHOLD) begin
                T6 = `MAX_EXP;
                dT6_dVg = 0.0;
            end 
            else if (T5 < -`EXP_THRESHOLD) begin
                T6 = `MIN_EXP;
                dT6_dVg = 0.0;
            end 
            else begin
                T6 = exp(T5);
                dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * vgs_eff) * dvgs_eff_dvg;
            end 
            dIgs_dVg = T11 * (T2 * dT6_dVg + T6 * dT2_dVg);
            dIgs_dVs = -dIgs_dVg;

            T0 = vgd - BSIM4vfbsd;
            vgd_eff = sqrt(T0 * T0 + 1.0e-4);
            dvgd_eff_dvg = T0 / vgd_eff;

            T2 = vgd * vgd_eff;
            dT2_dVg = vgd * dvgd_eff_dvg + vgd_eff;
            T5 = T12 * (BSIM4aigsd + T3 * vgd_eff - T4 * vgd_eff * vgd_eff);
            if (T5 > `EXP_THRESHOLD) begin
                T6 = `MAX_EXP;
                dT6_dVg = 0.0;
            end 
            else if (T5 < -`EXP_THRESHOLD) begin
                T6 = `MIN_EXP;
                dT6_dVg = 0.0;
            end 
            else begin
                T6 = exp(T5);
                dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * vgd_eff) * dvgd_eff_dvg;
            end 
            dIgd_dVg = T11 * (T2 * dT6_dVg + T6 * dT2_dVg);
            dIgd_dVd = -dIgd_dVg;
        end 

        if (BSIM4igbMod) begin
            T0 = Vtm * BSIM4nigbacc;
            T1 = -Vgs_eff + Vbseff + Vfb;
            VxNVt = T1 / T0;
            if (VxNVt > `EXP_THRESHOLD) begin
                Vaux = T1;
                dVaux_dVg = -dVgs_eff_dVg;
                dVaux_dVb = 1.0;
            end 
            else if (VxNVt < -`EXP_THRESHOLD) begin
                Vaux = T0 * ln(1.0 + `MIN_EXP);
                dVaux_dVg = 0.0;
                dVaux_dVb = 0.0;
            end 
            else begin
                ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
                dVaux_dVb = ExpVxNVt / (1.0 + ExpVxNVt); 
                dVaux_dVg = -dVaux_dVb * dVgs_eff_dVg;
            end

            T2 = (Vgs_eff - Vbseff) * Vaux;
            dT2_dVg = dVgs_eff_dVg * Vaux + (Vgs_eff - Vbseff) * dVaux_dVg;
            dT2_dVb = -Vaux + (Vgs_eff - Vbseff) * dVaux_dVb;

            T11 = 4.97232e-7 * BSIM4weff * BSIM4leff * BSIM4ToxRatio;
            T12 = -7.45669e11 * toxel;
            T3 = BSIM4aigbacc * BSIM4cigbacc - BSIM4bigbacc;
            T4 = BSIM4bigbacc * BSIM4cigbacc;
            T5 = T12 * (BSIM4aigbacc + T3 * Voxacc - T4 * Voxacc * Voxacc);

            if (T5 > `EXP_THRESHOLD) begin
                T6 = `MAX_EXP;
                dT6_dVg = 0.0;
                dT6_dVb = 0.0;
            end 
            else if (T5 < -`EXP_THRESHOLD) begin
                T6 = `MIN_EXP;
                dT6_dVg = 0.0;
                dT6_dVb = 0.0;
            end 
            else begin
                T6 = exp(T5);
                dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * Voxacc);
                dT6_dVb = dT6_dVg * dVoxacc_dVb;
                dT6_dVg = dT6_dVg * (  dVoxacc_dVg);
            end 

            dIgbacc_dVg = T11 * (T2 * dT6_dVg + T6 * dT2_dVg);
            dIgbacc_dVb = T11 * (T2 * dT6_dVb + T6 * dT2_dVb);

            T0 = Vtm * BSIM4nigbinv;
            T1 = Voxdepinv - BSIM4eigbinv;
            VxNVt = T1 / T0;
            if (VxNVt > `EXP_THRESHOLD) begin
                Vaux = T1;
                dVaux_dVg = dVoxdepinv_dVg;
                dVaux_dVd = dVoxdepinv_dVd;
                dVaux_dVb = dVoxdepinv_dVb;
            end 
            else if (VxNVt < -`EXP_THRESHOLD) begin
                Vaux = T0 * ln(1.0 + `MIN_EXP);
                dVaux_dVg = 0.0;
                dVaux_dVd = 0.0;
                dVaux_dVb = 0.0;
            end 
            else begin
                ExpVxNVt = exp(VxNVt);
                Vaux = T0 * ln(1.0 + ExpVxNVt);
                dVaux_dVg = ExpVxNVt / (1.0 + ExpVxNVt);
                dVaux_dVd = dVaux_dVg * dVoxdepinv_dVd;
                dVaux_dVb = dVaux_dVg * dVoxdepinv_dVb;
                dVaux_dVg = dVaux_dVg * (  dVoxdepinv_dVg);
            end

            T2 = (Vgs_eff - Vbseff) * Vaux;
            dT2_dVg = dVgs_eff_dVg * Vaux + (Vgs_eff - Vbseff) * dVaux_dVg;
            dT2_dVd = (Vgs_eff - Vbseff) * dVaux_dVd;
            dT2_dVb = -Vaux + (Vgs_eff - Vbseff) * dVaux_dVb;

            T11 = T11 * 0.75610;
            T12 = T12 * 1.31724;
            T3 = BSIM4aigbinv * BSIM4cigbinv - BSIM4bigbinv;
            T4 = BSIM4bigbinv * BSIM4cigbinv;
            T5 = T12 * (BSIM4aigbinv + T3 * Voxdepinv - T4 *
                Voxdepinv * Voxdepinv);

            if (T5 > `EXP_THRESHOLD) begin
                T6 = `MAX_EXP;
                dT6_dVg = 0.0;
                dT6_dVd = 0.0;
                dT6_dVb = 0.0;
            end 
            else if (T5 < -`EXP_THRESHOLD) begin
                T6 = `MIN_EXP;
                dT6_dVg = 0.0;
                dT6_dVd = 0.0;
                dT6_dVb = 0.0;
            end 
            else begin
                T6 = exp(T5);
                dT6_dVg = T6 * T12 * (T3 - 2.0 * T4 * Voxdepinv);
                dT6_dVd = dT6_dVg * dVoxdepinv_dVd;
                dT6_dVb = dT6_dVg * dVoxdepinv_dVb;
                dT6_dVg = dT6_dVg * (  dVoxdepinv_dVg);
            end

            dIgbinv_dVg = T11 * (T2 * dT6_dVg + T6 * dT2_dVg);
            dIgbinv_dVd = T11 * (T2 * dT6_dVd + T6 * dT2_dVd);
            dIgbinv_dVb = T11 * (T2 * dT6_dVb + T6 * dT2_dVb);
        end
    end
`endif


    if (BSIM4nf != 1.0) begin
        cdrain = cdrain * BSIM4nf;
        IdovVds =IdovVds * BSIM4nf;
        Isub = Isub * BSIM4nf;
        Igidl = Igidl * BSIM4nf;
        Igisl = Igisl * BSIM4nf;
        Igcs = Igcs * BSIM4nf;
        Igs = Igs * BSIM4nf;
        Igcd = Igcd * BSIM4nf;
        Igd = Igd * BSIM4nf;
        Igb = Igb * BSIM4nf;
    end

    if (BSIM4tnoiMod == 0) begin
        Abulk = Abulk0 * BSIM4abulkCVfactor;
        Vdsat = Vgsteff / Abulk;
        T0 = Vdsat - Vds - `DELTA_4;
        T1 = sqrt(T0 * T0 + 4.0 * `DELTA_4 * Vdsat);
        if (T0 >= 0.0)
            Vdseff = Vdsat - 0.5 * (T0 + T1);
        else begin
            T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
            T4 = 1.0 - T3;
            T5 = Vdsat * T3 / (T1 - T0);
            Vdseff = Vdsat * T4;
        end 
        if (Vds == 0.0)
            Vdseff = 0.0;

        T0 = Abulk * Vdseff;
        T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1.0e-20);
        T2 = Vdseff / T1;
        T3 = T0 * T2;

        BSIM4qinv = Coxeff * BSIM4weffCV * BSIM4nf * BSIM4leffCV *
            (Vgsteff - 0.5 * T0 + Abulk * T3);
    end 

    /*   BSIM4 C-V begins    */

    if (BSIM4xpart < 0) begin
        qgate  = 0.0;
        qdrn = 0.0;
        qsrc = 0.0;
        qbulk = 0.0;
    end 
    else if (BSIM4capMod == 0) begin

        if (Vbseff < 0.0)
            VbseffCV = Vbs;
        else
            VbseffCV = BSIM4phi - Phis;

        Vfb = BSIM4vfbcv;
        Vth = Vfb + BSIM4phi + BSIM4k1ox * sqrtPhis; 
        Vgst = Vgs_eff - Vth;

        CoxWL = BSIM4coxe * BSIM4weffCV * BSIM4leffCV * BSIM4nf;
        Arg1 = Vgs_eff - VbseffCV - Vfb;

        if (Arg1 <= 0.0) begin
            qgate = CoxWL * Arg1;
            qbulk = -qgate;
            qdrn = 0.0;
        end  /* Arg1 <= 0.0, end of accumulation */
        else if (Vgst <= 0.0) begin
            T1 = 0.5 * BSIM4k1ox;
            T2 = sqrt(T1 * T1 + Arg1);
            qgate = CoxWL * BSIM4k1ox * (T2 - T1);
            qbulk = -qgate;
            qdrn = 0.0;
        end  /* Vgst <= 0.0, end of depletion */
        else begin
            One_Third_CoxWL = CoxWL / 3.0;
            Two_Third_CoxWL = 2.0 * One_Third_CoxWL;
            AbulkCV = Abulk0 * BSIM4abulkCVfactor;
            Vdsat = Vgst / AbulkCV;

            if (BSIM4xpart > 0.5) begin
                /* 0/100 Charge partition model */
                if (Vdsat <= Vds)
                begin
                    /* saturation region */
                    T1 = Vdsat / 3.0;
                    qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - T1);
                    T2 = -Two_Third_CoxWL * Vgst;
                    qbulk = -(qgate + T2);
                    qdrn = 0.0;
                end 
                else begin
                    /* linear region */
                    Alphaz = Vgst / Vdsat;
                    T1 = 2.0 * Vdsat - Vds;
                    T2 = Vds / (3.0 * T1);
                    T3 = T2 * Vds;
                    T9 = 0.25 * CoxWL;
                    T4 = T9 * Alphaz;
                    T7 = 2.0 * Vds - T1 - 3.0 * T3;
                    T8 = T3 - T1 - 2.0 * Vds;
                    qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - 0.5 * (Vds - T3));
                    T10 = T4 * T8;
                    qdrn = T4 * T7;
                    qbulk = -(qgate + qdrn + T10);              
                end 
            end 
            else if (BSIM4xpart < 0.5) begin
                /* 40/60 Charge partition model */
                if (Vds >= Vdsat) begin
                    /* saturation region */
                    T1 = Vdsat / 3.0;
                    qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - T1);
                    T2 = -Two_Third_CoxWL * Vgst;
                    qbulk = -(qgate + T2);
                    qdrn = 0.4 * T2;
                end 
                else begin
                    /* linear region  */
                    Alphaz = Vgst / Vdsat;
                    T1 = 2.0 * Vdsat - Vds;
                    T2 = Vds / (3.0 * T1);
                    T3 = T2 * Vds;
                    T9 = 0.25 * CoxWL;
                    T4 = T9 * Alphaz;
                    qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - 0.5 * (Vds - T3));

                    T6 = 8.0 * Vdsat * Vdsat - 6.0 * Vdsat * Vds + 1.2 * Vds * Vds;
                    T8 = T2 / T1;
                    T7 = Vds - T1 - T8 * T6;
                    qdrn = T4 * T7;

                    T7 = 2.0 * (T1 + T3);
                    qbulk = -(qgate - T4 * T7);
                end 
            end 
            else begin
                /* 50/50 partitioning */
                if (Vds >= Vdsat) begin
                    /* saturation region */
                    T1 = Vdsat / 3.0;
                    qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - T1);
                    T2 = -Two_Third_CoxWL * Vgst;
                    qbulk = -(qgate + T2);
                    qdrn = 0.5 * T2;
                end 
                else begin
                    /* linear region */
                    Alphaz = Vgst / Vdsat;
                    T1 = 2.0 * Vdsat - Vds;
                    T2 = Vds / (3.0 * T1);
                    T3 = T2 * Vds;
                    T9 = 0.25 * CoxWL;
                    T4 = T9 * Alphaz;
                    qgate = CoxWL * (Vgs_eff - Vfb - BSIM4phi - 0.5 * (Vds - T3));
                    T7 = T1 + T3;
                    qdrn = -T4 * T7;
                    qbulk = - (qgate + qdrn + qdrn);
                end  /* end of linear region */
            end  /* end of 50/50 partition */
        end  /* end of inversion */
    end  /* end of capMod=0 */ 
    else begin
        if (Vbseff < 0.0)
            VbseffCV = Vbseff;
        else
            VbseffCV = BSIM4phi - Phis;

        CoxWL = BSIM4coxe * BSIM4weffCV * BSIM4leffCV * BSIM4nf;

      if(BSIM4cvchargeMod == 0) begin
        /* Separate VgsteffCV with noff and voffcv */
        local_noff = n * BSIM4noff;
        T0 = Vtm * local_noff;
        local_voffcv = BSIM4voffcv;
        VgstNVt = (Vgst - local_voffcv) / T0;

        if (VgstNVt > `EXP_THRESHOLD) begin
            Vgsteff = Vgst - local_voffcv;
        end 
        else if (VgstNVt < -`EXP_THRESHOLD) begin
            Vgsteff = T0 * ln(1.0 + `MIN_EXP);
        end 
        else begin
            ExpVgst = exp(VgstNVt);
            Vgsteff = T0 * ln(1.0 + ExpVgst);
        end  /* End of VgsteffCV */
      end /* End of VgsteffCV for cvchargeMod = 0 */
      else begin
	 T0 = n * Vtm;
	 T1 = BSIM4mstarcv * Vgst;
	 T2 = T1 / T0;
	 if (T2 > `EXP_THRESHOLD)
	     T10 = T1;
	 else if (T2 < -`EXP_THRESHOLD)
	   begin   
	     T10 = Vtm * ln(1.0 + `MIN_EXP);
	     T10 = T10 * n;
	   end
	 else
	   begin   
	     ExpVgst = exp(T2);
	     T3 = Vtm * ln(1.0 + ExpVgst);
	     T10 = n * T3;
	   end
	 
	 T1 = BSIM4voffcbncv - (1.0 - BSIM4mstarcv) * Vgst;
	 T2 = T1 / T0;
	 if (T2 < -`EXP_THRESHOLD)
	   begin   
	     T3 = BSIM4coxe * `MIN_EXP / BSIM4cdep0;
	     T9 = BSIM4mstarcv + T3 * n;
	   end
	 else if (T2 > `EXP_THRESHOLD)
	   begin   
	     T3 = BSIM4coxe * `MAX_EXP / BSIM4cdep0;
	     T9 = BSIM4mstarcv + T3 * n;
	   end
	 else
	   begin   
	     ExpVgst = exp(T2);
	     T3 = BSIM4coxe / BSIM4cdep0;
	     T4 = T3 * ExpVgst;
	     T5 = T1 * T4 / T0;
	     T9 = BSIM4mstarcv + n * T4;
	   end
	 
	 Vgsteff = T10 / T9;
	end /* End of VgsteffCV for cvchargeMod = 1 */

        if (BSIM4capMod == 1) begin
            Vfb = here_BSIM4vfbzb;
            V3 = Vfb - Vgs_eff + VbseffCV - `DELTA_3;
            if (Vfb <= 0.0)
                T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * Vfb);
            else
                T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * Vfb);

            Vfbeff = Vfb - 0.5 * (V3 + T0);
            Qac0 = CoxWL * (Vfbeff - Vfb);
            T0 = 0.5 * BSIM4k1ox;
            T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
            if (BSIM4k1ox == 0.0) begin
                T1 = 0.0;
            end 
            else if (T3 < 0.0) begin
                T1 = T0 + T3 / BSIM4k1ox;
            end 
            else begin
                T1 = sqrt(T0 * T0 + T3);
            end

            Qsub0 = CoxWL * BSIM4k1ox * (T1 - T0);
            AbulkCV = Abulk0 * BSIM4abulkCVfactor;
            VdsatCV = Vgsteff / AbulkCV;

	    T0 = VdsatCV - Vds - `DELTA_4;
	    T1 = sqrt(T0 * T0 + 4.0 * `DELTA_4 * VdsatCV);
            if (T0 >= 0.0) begin
                VdseffCV = VdsatCV - 0.5 * (T0 + T1);
            end 
            else begin
                T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
                T4 = 1.0 - T3;
                VdseffCV = VdsatCV * T4;
            end

            if (Vds == 0.0)
                VdseffCV = 0.0;

            T0 = AbulkCV * VdseffCV;
            T1 = 12.0 * (Vgsteff - 0.5 * T0 + 1.0e-20);
            T2 = VdseffCV / T1;
            T3 = T0 * T2;

	    qgate = CoxWL * (Vgsteff - 0.5 * VdseffCV + T3);
	    T7 = 1.0 - AbulkCV;
	    qbulk = CoxWL * T7 * (0.5 * VdseffCV - T3);

            if (BSIM4xpart > 0.5) begin
                /* 0/100 Charge petition model */
                T1 = T1 + T1;
                qsrc = -CoxWL * (0.5 * Vgsteff + 0.25 * T0 - T0 * T0 / T1);
            end 
            else if (BSIM4xpart < 0.5) begin
                /* 40/60 Charge petition model */
                T1 = T1 / 12.0;
                T2 = 0.5 * CoxWL / (T1 * T1);
                T3 = Vgsteff * (2.0 * T0 * T0 / 3.0 + Vgsteff *
                    (Vgsteff - 4.0 * T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
                qsrc = -T2 * T3;
            end 
            else begin
                /* 50/50 Charge petition model */
                qsrc = -0.5 * (qgate + qbulk);
            end

            qgate = qgate + (Qac0 + Qsub0);
            qbulk = qbulk - (Qac0 + Qsub0);
            qdrn  = -(qgate + qbulk + qsrc);

        end 

        /* Charge-Thickness capMod (CTM) begins */
        else if (BSIM4capMod == 2) begin
            V3 = here_BSIM4vfbzb - Vgs_eff + VbseffCV - `DELTA_3;
            if (here_BSIM4vfbzb <= 0.0)
                T0 = sqrt(V3 * V3 - 4.0 * `DELTA_3 * here_BSIM4vfbzb);
            else
                T0 = sqrt(V3 * V3 + 4.0 * `DELTA_3 * here_BSIM4vfbzb);

            T1 = 0.5 * (1.0 + V3 / T0);
            Vfbeff = here_BSIM4vfbzb - 0.5 * (V3 + T0);

            Cox = BSIM4coxp;
            Tox = 1.0e8 * BSIM4toxp;
            T0 = (Vgs_eff - VbseffCV - here_BSIM4vfbzb) / Tox;

            tmp = T0 * BSIM4acde;
            if ((-`EXP_THRESHOLD < tmp) && (tmp < `EXP_THRESHOLD)) begin
                Tcen = BSIM4ldeb * exp(tmp);
            end 
            else if (tmp <= -`EXP_THRESHOLD) begin
                Tcen = BSIM4ldeb * `MIN_EXP;
            end 
            else begin
                Tcen = BSIM4ldeb * `MAX_EXP;
            end

            LINK = 1.0e-3 * BSIM4toxp;
            V3 = BSIM4ldeb - Tcen - LINK;
            V4 = sqrt(V3 * V3 + 4.0 * LINK * BSIM4ldeb);
            Tcen = BSIM4ldeb - 0.5 * (V3 + V4);

            Ccen = epssubl / Tcen;
            T2 = Cox / (Cox + Ccen);
            Coxeff = T2 * Ccen;
            T3 = -Ccen / Tcen;
            CoxWLcen = CoxWL * Coxeff / BSIM4coxe;

            Qac0 = CoxWLcen * (Vfbeff - here_BSIM4vfbzb);
            QovCox = Qac0 / Coxeff;

            T0 = 0.5 * BSIM4k1ox;
            T3 = Vgs_eff - Vfbeff - VbseffCV - Vgsteff;
            if (BSIM4k1ox == 0.0) begin
                T1 = 0.0;
                T2 = 0.0;
            end 
            else if (T3 < 0.0) begin
                T1 = T0 + T3 / BSIM4k1ox;
                T2 = CoxWLcen;
            end 
            else begin
                T1 = sqrt(T0 * T0 + T3);
                T2 = CoxWLcen * T0 / T1;
            end

            Qsub0 = CoxWLcen * BSIM4k1ox * (T1 - T0);
            QovCox = Qsub0 / Coxeff;

            /* Gate-bias dependent delta Phis begins */
            if (BSIM4k1ox <= 0.0) begin
                Denomi = 0.25 * BSIM4moin * Vtm;
                T0 = 0.5 * BSIM4sqrtPhi;
            end 
            else begin
                Denomi = BSIM4moin * Vtm * BSIM4k1ox * BSIM4k1ox;
                T0 = BSIM4k1ox * BSIM4sqrtPhi;
            end 
            T1 = 2.0 * T0 + Vgsteff;

            DeltaPhi = Vtm * ln(1.0 + T1 * Vgsteff / Denomi);
            /* End of delta Phis */

	    /* VgDP = Vgsteff - DeltaPhi */
	    T0 = Vgsteff - DeltaPhi - 0.001;
	    T1 = sqrt(T0 * T0 + Vgsteff * 0.004);
	    VgDP = 0.5 * (T0 + T1);

            Tox = Tox + Tox; /* WDLiu: Tcen reevaluated below due to different Vgsteff */
            T0 = (Vgsteff + here_BSIM4vtfbphi2) / Tox;
            tmp = exp(BSIM4bdos * 0.7 * ln(T0));
            T1 = 1.0 + tmp;
            Tcen = BSIM4ados * 1.9e-9 / T1;

            Ccen = epssubl  / Tcen;
            T0 = Cox / (Cox + Ccen);
            Coxeff = T0 * Ccen;
            CoxWLcen = CoxWL * Coxeff / BSIM4coxe;

            AbulkCV = Abulk0 * BSIM4abulkCVfactor;
            VdsatCV = VgDP / AbulkCV;

            T0 = VdsatCV - Vds - `DELTA_4;
            T1 = sqrt(T0 * T0 + 4.0 * `DELTA_4 * VdsatCV);
            if (T0 >= 0.0) begin
                VdseffCV = VdsatCV - 0.5 * (T0 + T1);
            end 
            else begin
                T3 = (`DELTA_4 + `DELTA_4) / (T1 - T0);
                T4 = 1.0 - T3;
                VdseffCV = VdsatCV * T4;
            end

            if (Vds == 0.0) 
                VdseffCV = 0.0;

            T0 = AbulkCV * VdseffCV;
            T1 = VgDP; 
            T2 = 12.0 * (T1 - 0.5 * T0 + 1.0e-20);
            T3 = T0 / T2;
            qgate = CoxWLcen * (T1 - T0 * (0.5 - T3));
            T7 = 1.0 - AbulkCV;
            qbulk = CoxWLcen * T7 * (0.5 * VdseffCV - T0 * VdseffCV / T2);

            if (BSIM4xpart > 0.5) begin
                /* 0/100 partition */
                qsrc = -CoxWLcen * (T1 / 2.0 + T0 / 4.0 - 0.5 * T0 * T0 / T2);
            end 
            else if (BSIM4xpart < 0.5) begin
                /* 40/60 partition */
                T2 = T2 / 12.0;
                T3 = 0.5 * CoxWLcen / (T2 * T2);
                T4 = T1 * (2.0 * T0 * T0 / 3.0 + T1 * (T1 - 4.0 * 
                    T0 / 3.0)) - 2.0 * T0 * T0 * T0 / 15.0;
                qsrc = -T3 * T4;
            end 
            else begin
                /* 50/50 partition */
                qsrc = -0.5 * qgate;
            end

            qgate = qgate + (Qac0 + Qsub0 - qbulk);
            qbulk = qbulk - (Qac0 + Qsub0);
            qdrn = -(qgate + qbulk + qsrc);

        end   /* End of CTM */
    end 


    /* NQS begins */
    if ((BSIM4trnqsMod) || (BSIM4acnqsMod)) begin
        BSIM4qchqs = -(qbulk + qgate);
        qcheq = -(qbulk + qgate);

        CoxWL = BSIM4coxe * BSIM4weffCV * BSIM4nf * BSIM4leffCV;
        T1 = BSIM4gcrg / CoxWL; /* 1 / tau */

        if (BSIM4acnqsMod)
            BSIM4taunet = 1.0 / T1;
    end // if ((BSIM4trnqsMod) || (BSIM4acnqsMod))
//finished:

    /* Calculate junction C-V */
    czbd = BSIM4DunitAreaTempJctCap * BSIM4Adeff; /* bug fix */
    czbs = BSIM4SunitAreaTempJctCap * BSIM4Aseff;
    czbdsw = BSIM4DunitLengthSidewallTempJctCap * BSIM4Pdeff;
    czbdswg = BSIM4DunitLengthGateSidewallTempJctCap *
        BSIM4weffCJ * BSIM4nf;
    czbssw = BSIM4SunitLengthSidewallTempJctCap * BSIM4Pseff;
    czbsswg = BSIM4SunitLengthGateSidewallTempJctCap * BSIM4weffCJ * BSIM4nf;

    MJS = BSIM4SbulkJctBotGradingCoeff;
    MJSWS = BSIM4SbulkJctSideGradingCoeff;
    MJSWGS = BSIM4SbulkJctGateSideGradingCoeff;

    MJD = BSIM4DbulkJctBotGradingCoeff;
    MJSWD = BSIM4DbulkJctSideGradingCoeff;
    MJSWGD = BSIM4DbulkJctGateSideGradingCoeff;

    /* Source Bulk Junction */
    if (vbs_jct == 0.0)
        BSIM4qbs = 0.0;
    else if (vbs_jct < 0.0) begin
        if (czbs > 0.0) begin
            arg = 1.0 - vbs_jct / BSIM4PhiBS;
            if (MJS == 0.5)
                sarg = 1.0 / sqrt(arg);
            else
                sarg = exp(-MJS * ln(arg));
            BSIM4qbs = BSIM4PhiBS * czbs * (1.0 - arg * sarg) / (1.0 - MJS);
        end 
        else begin
            BSIM4qbs = 0.0;
        end 
        if (czbssw > 0.0) begin
            arg = 1.0 - vbs_jct / BSIM4PhiBSWS;
            if (MJSWS == 0.5)
                sarg = 1.0 / sqrt(arg);
            else
                sarg = exp(-MJSWS * ln(arg));
            BSIM4qbs = BSIM4qbs + (BSIM4PhiBSWS * czbssw) * (1.0 - arg * sarg) / (1.0 - MJSWS);
        end 
        if (czbsswg > 0.0) begin
            arg = 1.0 - vbs_jct / BSIM4PhiBSWGS;
            if (MJSWGS == 0.5)
                sarg = 1.0 / sqrt(arg);
            else
                sarg = exp(-MJSWGS * ln(arg));
            BSIM4qbs = BSIM4qbs + (BSIM4PhiBSWGS * czbsswg) * (1.0 - arg * sarg) / (1.0 - MJSWGS);
        end 
    end 
    else begin
        T0 = czbs + czbssw + czbsswg;
        T1 = vbs_jct * (czbs * MJS / BSIM4PhiBS + czbssw * MJSWS /
            BSIM4PhiBSWS + czbsswg * MJSWGS / BSIM4PhiBSWGS);    
        BSIM4qbs = vbs_jct * (T0 + 0.5 * T1);

    end // else: !if(vbs_jct < 0.0)

    /* Drain Bulk Junction */
    if (vbd_jct == 0.0) begin
        BSIM4qbd = 0.0;
    end 
    else if (vbd_jct < 0.0) begin
        if (czbd > 0.0) begin
            arg = 1.0 - vbd_jct / BSIM4PhiBD;
            if (MJD == 0.5)
                sarg = 1.0 / sqrt(arg);
            else
                sarg = exp(-MJD * ln(arg));
            BSIM4qbd = BSIM4PhiBD* czbd * (1.0 - arg * sarg) / (1.0 - MJD);
        end 
        else begin
            BSIM4qbd = 0.0;
        end 
        if (czbdsw > 0.0) begin
            arg = 1.0 - vbd_jct / BSIM4PhiBSWD;
            if (MJSWD == 0.5)
                sarg = 1.0 / sqrt(arg);
            else
                sarg = exp(-MJSWD * ln(arg));

            BSIM4qbd = BSIM4qbd + (BSIM4PhiBSWD * czbdsw)       * (1.0 - arg * sarg) / (1.0 - MJSWD);
        end 
        if (czbdswg > 0.0) begin
            arg = 1.0 - vbd_jct / BSIM4PhiBSWGD;
            if (MJSWGD == 0.5)
                sarg = 1.0 / sqrt(arg);
            else
                sarg = exp(-MJSWGD * ln(arg));

            BSIM4qbd = BSIM4qbd + (BSIM4PhiBSWGD * czbdswg)  * (1.0 - arg * sarg) / (1.0 - MJSWGD);
        end 
    end // if (vbd_jct < 0.0)       
    else begin
        T0 = czbd + czbdsw + czbdswg;
        T1 = vbd_jct * (czbd * MJD / BSIM4PhiBD + czbdsw * MJSWD /
            BSIM4PhiBSWD + czbdswg * MJSWGD / BSIM4PhiBSWGD);
        BSIM4qbd = vbd_jct * (T0 + 0.5 * T1);
    end

    if (BSIM4rgateMod == 3) 
    begin   
            vgdx = vgmd; 
            vgsx = vgms;
    end  
    else  /* For rgateMod == 0, 1 and 2 */
    begin
            vgdx = vgd;
            vgsx = vgs;
    end
    if (BSIM4capMod == 0) begin      
        qgdo = BSIM4cgdo * vgdx;
        qgso = BSIM4cgso * vgsx;
    end 
    else begin 
    /* For both capMod == 1 and 2 */
        T0 = vgdx + `DELTA_1;
        T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
        T2 = 0.5 * (T0 - T1);
        T3 = BSIM4weffCV * BSIM4cgdl;
        T4 = sqrt(1.0 - 4.0 * T2 / BSIM4ckappad);
        qgdo = (BSIM4cgdo + T3) * vgdx - T3 * (T2 + 0.5 * BSIM4ckappad *
            (T4 - 1.0));
        T0 = vgsx + `DELTA_1;
        T1 = sqrt(T0 * T0 + 4.0 * `DELTA_1);
        T2 = 0.5 * (T0 - T1);
        T3 = BSIM4weffCV * BSIM4cgsl;
        T4 = sqrt(1.0 - 4.0 * T2 / BSIM4ckappas);
        qgso = (BSIM4cgso + T3) * vgsx - T3 * (T2 + 0.5 * BSIM4ckappas *
            (T4 - 1.0));
    end

    if (BSIM4nf != 1.0) begin 
        qgdo = qgdo * BSIM4nf;
        qgso = qgso * BSIM4nf;
    end  

    if (BSIM4mode > 0) begin
        if (BSIM4trnqsMod == 0) begin 
            qdrn = qdrn - qgdo;
            if (BSIM4rgateMod == 3) begin
                qgmb = BSIM4cgbo * vgmb;
                qgmid = qgdo + qgso + qgmb;
                qbulk = qbulk - qgmb;
                qsrc = -(qgate + qgmid + qbulk + qdrn);
            end 
            else begin
                qgb = BSIM4cgbo * vgb;
                qgate = qgate + qgdo + qgso + qgb;
                qbulk = qbulk - qgb;
                qsrc = -(qgate + qbulk + qdrn);
            end 
        end 
        else begin
        //BSIM4trnqsMod >0
            qcheq = BSIM4qchqs;
            //CoxWL = BSIM4coxe * BSIM4weffCV * BSIM4nf
            //            * BSIM4leffCV;
 
            if (BSIM4rgateMod == 3) begin
                qgmb = BSIM4cgbo * vgmb;
                qgmid = qgdo + qgso + qgmb;
                qgate = 0.0;
                qbulk = -qgmb;
                qdrn = -qgdo;
                qsrc = -(qgmid + qbulk + qdrn);
            end 
            else begin
                qgb = BSIM4cgbo * vgb;
                qgate = qgdo + qgso + qgb;
                qbulk = -qgb;
                qdrn = -qgdo;
                qsrc = -(qgate + qbulk + qdrn);
            end 
        end 
    end /* end of BSIM4mode >0 */ 
    else begin
        if (BSIM4trnqsMod == 0) begin
            qsrc = qdrn - qgso;
            if (BSIM4rgateMod == 3) begin
                qgmb = BSIM4cgbo * vgmb;
                qgmid = qgdo + qgso + qgmb;
                qbulk = qbulk - qgmb;
                qdrn = -(qgate + qgmid + qbulk + qsrc);
            end 
            else begin
                qgb = BSIM4cgbo * vgb;
                qgate = qgate + qgdo + qgso + qgb;
                qbulk = qbulk - qgb;
                qdrn = -(qgate + qbulk + qsrc);
            end 
        end 
        else begin
            if (BSIM4rgateMod == 3) begin
                qgmb = BSIM4cgbo * vgmb;
                qgmid = qgdo + qgso + qgmb;
                qgate = 0.0;
                qbulk = -qgmb;
                qdrn = -qgdo;
                qsrc = -qgso;
            end 
            else begin
                qgb = BSIM4cgbo * vgb;
                qgate = qgdo + qgso + qgb;
                qbulk = -qgb;
                qdrn = -qgdo;
                qsrc = -qgso;
            end

        end // else: !if(BSIM4trnqsMod == 0)

    end // else: !if(BSIM4mode > 0)

    if(BSIM4mode < 0) begin
        cdrain = - cdrain;
        //BSIM4cbs = - BSIM4cbs;
        //BSIM4cbd = - BSIM4cbd;
        //Igidl = - Igidl; //TODO check?
    end

    I(di,si) <+ BSIM4type * cdrain; 
    I(gi,si) <+ BSIM4type * Igs;
    I(gi,di) <+ BSIM4type * Igd;
    I(di,bi) <+ BSIM4type * (Isub + Igidl);    
    I(si,bi) <+ BSIM4type * Igisl;   

    if (BSIM4igcMod) begin
        I(gi,si) <+ BSIM4type * Igcs;
        I(gi,di) <+ BSIM4type * Igcd;
    end

    I(gi, bi)	<+ BSIM4type * Igb;

    if (BSIM4rdsMod) begin
        Issi = V(s,si) * (BSIM4sourceConductance /
            (1 + Rs * BSIM4sourceConductance));
        Iddi = V(d,di) * (BSIM4drainConductance /
            (1 + Rd * BSIM4drainConductance));
        if(verbose == 1) begin 
          $strobe("In rdsmod=1 Issi=%g\n", Issi);
          $strobe("In rdsmod Iddi=%g\n", Iddi);      
        end
       I(s,si) <+ Issi;
       I(d,di) <+ Iddi;    
    end 
    else begin
       V(s,si) <+ 0.0;
       V(d,di) <+ 0.0; 
    end

    case (BSIM4rgateMod)
    0: begin // No gate resistance
       V(g,gm)  <+ 0.0;
       V(gm,gi) <+ 0.0;
    end
    1: begin // Constant resistance
`ifdef __XYCE_VAMS__
       I(g,gm)  <+ V(g,gm) * BSIM4grgeltd;
`else
       V(g,gm)  <+ I(g,gm) / BSIM4grgeltd;
`endif
       
       V(gm,gi) <+ 0.0;
    end
    2: begin // Variable resistance
       V(g,gm)   <+ 0.0;
`ifdef __XYCE_VAMS__
       I(gm,gi)  <+ V(gm,gi) * (BSIM4gcrg + BSIM4grgeltd);
`else
       V(gm,gi)  <+ I(gm,gi) / (BSIM4gcrg + BSIM4grgeltd);
`endif
    end
    3: begin // 2 internal gate nodes, TODO check `gcgmgmb needs?
       if(verbose == 1) begin 
        $strobe("BSIM4grgeltd=%g\n",BSIM4grgeltd);
        $strobe("BSIM4gcrg=%g\n",BSIM4gcrg);
       end
`ifdef __XYCE_VAMS__
       I(g,gm)  <+ V(g,gm)  * BSIM4grgeltd;
       I(gm,gi) <+ V(gm,gi) * BSIM4gcrg;           
`else
       V(g,gm)  <+ I(g,gm)  / BSIM4grgeltd;
       V(gm,gi) <+ I(gm,gi) / BSIM4gcrg;           
`endif
       
    end
    endcase // case(BSIM4rgateMod)
        
    if (BSIM4rbodyMod) begin
    //using I(a,b)<+... instead of V(a,b)<+.. for node collapse condition, or else Xyce fail
`ifdef __XYCE_VAMS__
//using I, both ok for me
        I(sbulk,bi) <+ V(sbulk,bi) * BSIM4grbps;
        I(sbulk,b)  <+ V(sbulk,b)  * BSIM4grbsb;
        I(b,bi)     <+ V(b,bi)     * BSIM4grbpb;
        I(b,dbulk)  <+ V(b,dbulk)  * BSIM4grbdb;
        I(bi,dbulk) <+ V(bi,dbulk) * BSIM4grbpd;  
`else
        V(sbulk,bi) <+ I(sbulk,bi) / BSIM4grbps;
        V(sbulk,b)  <+ I(sbulk,b)  / BSIM4grbsb;
        V(b,bi)     <+ I(b,bi)     / BSIM4grbpb;
        V(b,dbulk)  <+ I(b,dbulk)  / BSIM4grbdb;
        V(bi,dbulk) <+ I(bi,dbulk) / BSIM4grbpd;       
`endif
    end
    else begin
      V(sbulk,b)  <+ 0.0;
      V(b,bi)     <+ 0.0;
      V(b,dbulk)  <+ 0.0;
      //remove 2 below to avoid voltage loop
      //V(sbulk,bi) <+ 0.0;
      //V(bi,dbulk) <+ 0.0;     
    end
    //using the same notation for both topologies
    I(sbulk,si) <+ BSIM4type*BSIM4cbs;    
    I(dbulk,di) <+ BSIM4type*BSIM4cbd;    

    if(verbose == 1) begin 
      $strobe("BSIM4Ibs,gbs=%g,%g\n", BSIM4cbs, BSIM4gbs);
      $strobe("BSIM4Ibd,gbd=%g,%g\n", BSIM4cbd, BSIM4gbd);
    if (BSIM4rbodyMod) begin
      $strobe("Vbody(bi,db,sb)=%g,%g,%g\n", V(bi,s),V(dbulk,s),V(sbulk,s));
      $strobe("rbodymod,grbxx=%g,%g,%g,%g,%g,%g\n", BSIM4rbodyMod,BSIM4grbps,BSIM4grbsb,BSIM4grbpb,BSIM4grbdb,BSIM4grbpd);
    end
    end
    // Charge contributions      
    //
    I(gi,si) <+ BSIM4type * ddt(qgate);      
    I(di,si) <+ BSIM4type * ddt(qdrn);
    I(bi,si) <+ BSIM4type * ddt(qbulk);

    I(sbulk,si) <+ BSIM4type * ddt(BSIM4qbs);
    I(dbulk,di) <+ BSIM4type * ddt(BSIM4qbd);

    if(verbose == 1) begin 
      $strobe("qgate=%g\n", qgate);
      $strobe("qdrn =%g\n", qdrn);   
      $strobe("qsrc =%g\n", qsrc);
      $strobe("qgmid=%g\n", qgmid);
      $strobe("qbulk=%g\n", qbulk);
      $strobe("qgb  =%g\n", qgb);
      $strobe("qgmb =%g\n", qgmb);
      $strobe("qgdo =%g\n", qgdo);
      $strobe("qgso =%g\n", qgso);
      $strobe("here->BSIM4qbs=%g\n", BSIM4qbs);
      $strobe("here->BSIM4qbd=%g\n", BSIM4qbd);
      $strobe("BSIM4type=%d\n", BSIM4type);            
      $strobe("BSIM4mode=%d\n", BSIM4mode);            
    end

    // Noise
    if (BSIM4tnoiMod == 0) begin
        if (BSIM4rdsMod == 0) begin 
            if (BSIM4sourceConductance != 1000)
                gspr = BSIM4sourceConductance; 
            else
                gspr = 0;
            if (BSIM4drainConductance != 1000)
                gdpr = BSIM4drainConductance; 
            else
                gspr = 0;

            if (grdsw > 0.0) 
                inv_grdsw = 1.0 / grdsw; /* used below */
            else 
                inv_grdsw = 0.0; 
        end 
        else begin
            gspr = BSIM4gstot; 
            gdpr = BSIM4gdtot; 
            inv_grdsw = 0.0; 
        end 
        npart_beta = 0.0;
        npart_theta = 0.0;
    end 
    else begin 
        T5 = here_Vgsteff / EsatL; 
        T5 = T5 * T5;

        npart_beta  = BSIM4rnoia * (1.0 + T5 * BSIM4tnoia * Leff);
        npart_theta = BSIM4rnoib * (1.0 + T5 * BSIM4tnoib * Leff);

        if (BSIM4rdsMod == 0) begin
            gspr = BSIM4sourceConductance; 
            gdpr = BSIM4drainConductance; 
        end 
        else begin
            gspr = BSIM4gstot;
            gdpr = BSIM4gdtot;
        end 
        if (vds >= 0.0)
            gspr = gspr / (1.0 + npart_theta * npart_theta * gspr / IdovVds); 
        else 
            gdpr = gdpr / (1.0 + npart_theta * npart_theta * gdpr / IdovVds);
    end  

    I(di, d) <+ white_noise(4 * `P_K * T * gdpr, "Rd");
    I(si, s) <+ white_noise(4 * `P_K * T * gspr, "Rs");

    if ((BSIM4rgateMod == 1) || (BSIM4rgateMod == 2)) 
        I(gi, g) <+ white_noise(4 * `P_K * T * BSIM4grgeltd, "Rg");
    else if (BSIM4rgateMod == 3)
        I(gm, g) <+ white_noise(4 * `P_K * T * BSIM4grgeltd, "Rg");

    if (BSIM4rbodyMod) begin
        V(bi, sbulk) <+ white_noise(4 * `P_K * T * BSIM4rbps, "Rbulk");
        V(bi, dbulk) <+ white_noise(4 * `P_K * T * BSIM4rbpd, "Rbulk");
        V(bi, b)     <+ white_noise(4 * `P_K * T * BSIM4rbpb, "Rbulk");
        V(b, sbulk)  <+ white_noise(4 * `P_K * T * BSIM4rbsb, "Rbulk");
        V(b, dbulk)  <+ white_noise(4 * `P_K * T * BSIM4rbdb, "Rbulk");
    end

    case(BSIM4tnoiMod) 
        0: begin
            T0 = ueff * abs(BSIM4qinv);
            T1 = T0 * inv_grdsw + Leff * Leff;
            thermalNoiseContrib = (T0 / T1) * BSIM4ntnoi;
        end
        1: begin
            T0 = Gm + Gmb + Gds;
            T0 = T0 * T0;
            igsquare = npart_theta * npart_theta * T0 / IdovVds;
            T1 = npart_beta * (Gm + Gmb) + Gds;
            T2 = T1 * T1 / IdovVds; 
            thermalNoiseContrib = T2 - igsquare;
        end 
    endcase

    I(di,si) <+ white_noise(4 * `P_K * T * thermalNoiseContrib, 
        "thermal");

    if (BSIM4mode >= 0) begin
        I(gi,si) <+ white_noise(2 * `P_Q * abs(Igs + Igcs), "shot");
        I(gi,di) <+ white_noise(2 * `P_Q * abs(Igd + Igcd), "shot");
    end
    else begin
        I(gi,si) <+ white_noise(2 * `P_Q * abs(Igs + Igcs), "shot");
        I(gi,di) <+ white_noise(2 * `P_Q * abs(Igd + Igcd), "shot");
    end
    I(gi,bi) <+ white_noise(2 * `P_Q * abs(Igb), "shot");

    case (BSIM4fnoiMod)
        0: begin
            flickerNoiseContrib = BSIM4kf * pow(abs(cdrain), BSIM4af) /
                (BSIM4coxe * Leff * Leff);
        end
        1: begin
            if (vds < 0.0)
                vds = -vds;
            esat = 2.0 * BSIM4vsattemp / ueff;
            if(BSIM4em<=0.0) 
                DelClm = 0.0; 
            else begin
                T0 = ((((Vds - here_Vdseff) / BSIM4litl) + BSIM4em) / esat);
                DelClm = BSIM4litl * ln(max(T0, `N_MINLOG));
            end
            T1 = `P_Q * `P_Q * `P_K * abs(cdrain) * T * ueff;
            T2 = 1.0e10 * here_Abulk * BSIM4coxe * Leff * Leff;
            N0 = BSIM4coxe * here_Vgsteff / `P_Q;
            Nl = BSIM4coxe * here_Vgsteff * 
                (1.0 - AbovVgst2Vtm * here_Vdseff) / `P_Q;
            T3 = BSIM4oxideTrapDensityA * ln(max(((N0 + BSIM4nstar) /
                (Nl + BSIM4nstar)), `N_MINLOG));
            T4 = BSIM4oxideTrapDensityB * (N0 - Nl); 
            T5 = BSIM4oxideTrapDensityC * 0.5 * (N0 * N0 - Nl * Nl); 
            T6 = `P_K * T * cdrain * cdrain; 
            T7 = 1.0e10 * Leff * Leff * Weff; 
            T8 = BSIM4oxideTrapDensityA + BSIM4oxideTrapDensityB * Nl +
                BSIM4oxideTrapDensityC * Nl * Nl; 
            T9 = (Nl + BSIM4nstar) * (Nl + BSIM4nstar); 
            Ssi = T1 / T2 * (T3 + T4 + T5) + T6 / T7 * DelClm * T8 / T9;

            T10 = BSIM4oxideTrapDensityA * `P_K * T; 
            T11 = Weff * Leff * 1.0e10 * BSIM4nstar * BSIM4nstar; 
            Swi = T10 / T11 * cdrain * cdrain; 
            T1 = Swi + Ssi; 
            if (T1 > 0.0)
                flickerNoiseContrib = (Ssi * Swi) / T1; 
            else
                flickerNoiseContrib = 0.0;
        end
        endcase

        I(di,si) <+ flicker_noise(flickerNoiseContrib, BSIM4ef, "flicker");

    end
   
endmodule // end of bsim4_va





